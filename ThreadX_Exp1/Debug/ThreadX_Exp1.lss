
ThreadX_Exp1.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003600  00400000  00400000  00010000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000434  20400000  00403600  00020000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000317c  20400434  00403a34  00020434  2**2
                  ALLOC
  3 .stack        00002000  204035b0  00406bb0  00020434  2**0
                  ALLOC
  4 .heap         00000200  204055b0  00408bb0  00020434  2**0
                  ALLOC
  5 .ARM.attributes 0000002e  00000000  00000000  00020434  2**0
                  CONTENTS, READONLY
  6 .comment      00000059  00000000  00000000  00020462  2**0
                  CONTENTS, READONLY
  7 .debug_info   0004ab77  00000000  00000000  000204bb  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00009ce4  00000000  00000000  0006b032  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00007f6e  00000000  00000000  00074d16  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00000ab8  00000000  00000000  0007cc88  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000748  00000000  00000000  0007d740  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  00008a0c  00000000  00000000  0007de88  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0001155a  00000000  00000000  00086894  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00092964  00000000  00000000  00097dee  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00001334  00000000  00000000  0012a754  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <exception_table>:
  400000:	b0 55 40 20 d9 2d 40 00 d5 2d 40 00 d5 2d 40 00     .U@ .-@..-@..-@.
  400010:	d5 2d 40 00 d5 2d 40 00 d5 2d 40 00 00 00 00 00     .-@..-@..-@.....
	...
  40002c:	d5 2d 40 00 d5 2d 40 00 00 00 00 00 a1 2b 40 00     .-@..-@......+@.
  40003c:	55 2b 40 00 d5 2d 40 00 d5 2d 40 00 d5 2d 40 00     U+@..-@..-@..-@.
  40004c:	d5 2d 40 00 d5 2d 40 00 d5 2d 40 00 d5 2d 40 00     .-@..-@..-@..-@.
  40005c:	d5 2d 40 00 d5 2d 40 00 00 00 00 00 71 2d 40 00     .-@..-@.....q-@.
  40006c:	85 2d 40 00 99 2d 40 00 d5 2d 40 00 d5 2d 40 00     .-@..-@..-@..-@.
  40007c:	d5 2d 40 00 ad 2d 40 00 c1 2d 40 00 d5 2d 40 00     .-@..-@..-@..-@.
  40008c:	d5 2d 40 00 d5 2d 40 00 d5 2d 40 00 d5 2d 40 00     .-@..-@..-@..-@.
  40009c:	d5 2d 40 00 d5 2d 40 00 d5 2d 40 00 d5 2d 40 00     .-@..-@..-@..-@.
  4000ac:	d5 2d 40 00 d5 2d 40 00 d5 2d 40 00 d5 2d 40 00     .-@..-@..-@..-@.
  4000bc:	d5 2d 40 00 d5 2d 40 00 d5 2d 40 00 d5 2d 40 00     .-@..-@..-@..-@.
  4000cc:	d5 2d 40 00 d5 2d 40 00 d5 2d 40 00 d5 2d 40 00     .-@..-@..-@..-@.
  4000dc:	d5 2d 40 00 d5 2d 40 00 d5 2d 40 00 d5 2d 40 00     .-@..-@..-@..-@.
  4000ec:	d5 2d 40 00 d5 2d 40 00 d5 2d 40 00 d5 2d 40 00     .-@..-@..-@..-@.
  4000fc:	d5 2d 40 00 d5 2d 40 00 d5 2d 40 00 d5 2d 40 00     .-@..-@..-@..-@.
  40010c:	d5 2d 40 00 d5 2d 40 00 d5 2d 40 00 00 00 00 00     .-@..-@..-@.....
  40011c:	00 00 00 00 d5 2d 40 00 d5 2d 40 00 d5 2d 40 00     .....-@..-@..-@.
  40012c:	d5 2d 40 00 d5 2d 40 00 d5 2d 40 00 d5 2d 40 00     .-@..-@..-@..-@.
  40013c:	d5 2d 40 00 d5 2d 40 00 d5 2d 40 00 d5 2d 40 00     .-@..-@..-@..-@.
  40014c:	d5 2d 40 00 d5 2d 40 00 d5 2d 40 00 d5 2d 40 00     .-@..-@..-@..-@.
  40015c:	d5 2d 40 00 d5 2d 40 00 d5 2d 40 00                 .-@..-@..-@.

00400168 <__do_global_dtors_aux>:
  400168:	b510      	push	{r4, lr}
  40016a:	4c05      	ldr	r4, [pc, #20]	; (400180 <__do_global_dtors_aux+0x18>)
  40016c:	7823      	ldrb	r3, [r4, #0]
  40016e:	b933      	cbnz	r3, 40017e <__do_global_dtors_aux+0x16>
  400170:	4b04      	ldr	r3, [pc, #16]	; (400184 <__do_global_dtors_aux+0x1c>)
  400172:	b113      	cbz	r3, 40017a <__do_global_dtors_aux+0x12>
  400174:	4804      	ldr	r0, [pc, #16]	; (400188 <__do_global_dtors_aux+0x20>)
  400176:	f3af 8000 	nop.w
  40017a:	2301      	movs	r3, #1
  40017c:	7023      	strb	r3, [r4, #0]
  40017e:	bd10      	pop	{r4, pc}
  400180:	20400434 	.word	0x20400434
  400184:	00000000 	.word	0x00000000
  400188:	00403600 	.word	0x00403600

0040018c <frame_dummy>:
  40018c:	4b0c      	ldr	r3, [pc, #48]	; (4001c0 <frame_dummy+0x34>)
  40018e:	b143      	cbz	r3, 4001a2 <frame_dummy+0x16>
  400190:	480c      	ldr	r0, [pc, #48]	; (4001c4 <frame_dummy+0x38>)
  400192:	490d      	ldr	r1, [pc, #52]	; (4001c8 <frame_dummy+0x3c>)
  400194:	b510      	push	{r4, lr}
  400196:	f3af 8000 	nop.w
  40019a:	480c      	ldr	r0, [pc, #48]	; (4001cc <frame_dummy+0x40>)
  40019c:	6803      	ldr	r3, [r0, #0]
  40019e:	b923      	cbnz	r3, 4001aa <frame_dummy+0x1e>
  4001a0:	bd10      	pop	{r4, pc}
  4001a2:	480a      	ldr	r0, [pc, #40]	; (4001cc <frame_dummy+0x40>)
  4001a4:	6803      	ldr	r3, [r0, #0]
  4001a6:	b933      	cbnz	r3, 4001b6 <frame_dummy+0x2a>
  4001a8:	4770      	bx	lr
  4001aa:	4b09      	ldr	r3, [pc, #36]	; (4001d0 <frame_dummy+0x44>)
  4001ac:	2b00      	cmp	r3, #0
  4001ae:	d0f7      	beq.n	4001a0 <frame_dummy+0x14>
  4001b0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  4001b4:	4718      	bx	r3
  4001b6:	4b06      	ldr	r3, [pc, #24]	; (4001d0 <frame_dummy+0x44>)
  4001b8:	2b00      	cmp	r3, #0
  4001ba:	d0f5      	beq.n	4001a8 <frame_dummy+0x1c>
  4001bc:	4718      	bx	r3
  4001be:	bf00      	nop
  4001c0:	00000000 	.word	0x00000000
  4001c4:	00403600 	.word	0x00403600
  4001c8:	20400438 	.word	0x20400438
  4001cc:	00403600 	.word	0x00403600
  4001d0:	00000000 	.word	0x00000000

004001d4 <_txe_block_allocate>:

    /* Default status to success.  */
    status =  TX_SUCCESS;

    /* Check for an invalid pool pointer.  */
    if (pool_ptr == TX_NULL)
  4001d4:	b1c0      	cbz	r0, 400208 <_txe_block_allocate+0x34>
{
  4001d6:	b510      	push	{r4, lr}
  4001d8:	4603      	mov	r3, r0
        /* Pool pointer is invalid, return appropriate error code.  */
        status =  TX_POOL_ERROR;
    }

    /* Check for an invalid pool pointer.  */
    else if (pool_ptr -> tx_block_pool_id != TX_BLOCK_POOL_ID)
  4001da:	6804      	ldr	r4, [r0, #0]
  4001dc:	480e      	ldr	r0, [pc, #56]	; (400218 <_txe_block_allocate+0x44>)
  4001de:	4284      	cmp	r4, r0
  4001e0:	d001      	beq.n	4001e6 <_txe_block_allocate+0x12>
    {

        /* Pool pointer is invalid, return appropriate error code.  */
        status =  TX_POOL_ERROR;
  4001e2:	2002      	movs	r0, #2
  4001e4:	bd10      	pop	{r4, pc}
    }

    /* Check for an invalid destination for return pointer.  */
    else if (block_ptr == TX_NULL)
  4001e6:	b189      	cbz	r1, 40020c <_txe_block_allocate+0x38>
    else
    {

        /* Check for a wait option error.  Only threads are allowed any form of
           suspension.  */
        if (wait_option != TX_NO_WAIT)
  4001e8:	b152      	cbz	r2, 400200 <_txe_block_allocate+0x2c>
#elif defined(__GNUC__) /* GCC and ARM Compiler 6 */

__attribute__( ( always_inline ) ) static inline unsigned int __get_ipsr_value(void)
{
unsigned int  ipsr_value;
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
  4001ea:	f3ef 8005 	mrs	r0, IPSR
        {

            /* Is the call from an ISR or Initialization?  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
  4001ee:	4c0b      	ldr	r4, [pc, #44]	; (40021c <_txe_block_allocate+0x48>)
  4001f0:	6824      	ldr	r4, [r4, #0]
  4001f2:	4320      	orrs	r0, r4
  4001f4:	d10c      	bne.n	400210 <_txe_block_allocate+0x3c>
#ifndef TX_TIMER_PROCESS_IN_ISR
            else
            {

                /* Pickup thread pointer.  */
                TX_THREAD_GET_CURRENT(current_thread)
  4001f6:	480a      	ldr	r0, [pc, #40]	; (400220 <_txe_block_allocate+0x4c>)

                /* Is the current thread the timer thread?  */
                if (current_thread == &_tx_timer_thread)
  4001f8:	6804      	ldr	r4, [r0, #0]
  4001fa:	480a      	ldr	r0, [pc, #40]	; (400224 <_txe_block_allocate+0x50>)
  4001fc:	4284      	cmp	r4, r0
  4001fe:	d009      	beq.n	400214 <_txe_block_allocate+0x40>
  400200:	4618      	mov	r0, r3
    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
    {

        /* Call actual block allocate function.  */
        status =  _tx_block_allocate(pool_ptr, block_ptr, wait_option);
  400202:	4b09      	ldr	r3, [pc, #36]	; (400228 <_txe_block_allocate+0x54>)
  400204:	4798      	blx	r3
  400206:	bd10      	pop	{r4, pc}
        status =  TX_POOL_ERROR;
  400208:	2002      	movs	r0, #2
  40020a:	4770      	bx	lr
        status =  TX_PTR_ERROR;
  40020c:	2003      	movs	r0, #3
  40020e:	bd10      	pop	{r4, pc}
                status =  TX_WAIT_ERROR;
  400210:	2004      	movs	r0, #4
  400212:	bd10      	pop	{r4, pc}
                    status =  TX_WAIT_ERROR;
  400214:	2004      	movs	r0, #4
    }

    /* Return completion status.  */
    return(status);
}
  400216:	bd10      	pop	{r4, pc}
  400218:	424c4f43 	.word	0x424c4f43
  40021c:	20400000 	.word	0x20400000
  400220:	20400590 	.word	0x20400590
  400224:	20400634 	.word	0x20400634
  400228:	00400ba5 	.word	0x00400ba5

0040022c <_txe_block_pool_create>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_block_pool_create(TX_BLOCK_POOL *pool_ptr, CHAR *name_ptr, ULONG block_size,
                    VOID *pool_start, ULONG pool_size, UINT pool_control_block_size)
{
  40022c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  400230:	b082      	sub	sp, #8
        /* Pool pointer is invalid, return appropriate error code.  */
        status =  TX_POOL_ERROR;
    }

    /* Check for invalid control block size.  */
    else if (pool_control_block_size != (sizeof(TX_BLOCK_POOL)))
  400232:	9c09      	ldr	r4, [sp, #36]	; 0x24
  400234:	2c30      	cmp	r4, #48	; 0x30
  400236:	d100      	bne.n	40023a <_txe_block_pool_create+0xe>
  400238:	b918      	cbnz	r0, 400242 <_txe_block_pool_create+0x16>
    {

        /* Pool pointer is invalid, return appropriate error code.  */
        status =  TX_POOL_ERROR;
  40023a:	2002      	movs	r0, #2
        status =  _tx_block_pool_create(pool_ptr, name_ptr, block_size, pool_start, pool_size);
    }

    /* Return completion status.  */
    return(status);
}
  40023c:	b002      	add	sp, #8
  40023e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
{
unsigned int posture;
#ifdef TX_PORT_USE_BASEPRI
    __asm__ volatile ("MRS  %0, BASEPRI ": "=r" (posture));
#else
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  400242:	f3ef 8410 	mrs	r4, PRIMASK
    int_posture = __get_interrupt_posture();

#ifdef TX_PORT_USE_BASEPRI
    __set_basepri_value(TX_PORT_BASEPRI);
#else
    __asm__ volatile ("CPSID i" : : : "memory");
  400246:	b672      	cpsid	i
        _tx_thread_preempt_disable++;
  400248:	4e2a      	ldr	r6, [pc, #168]	; (4002f4 <_txe_block_pool_create+0xc8>)
  40024a:	6835      	ldr	r5, [r6, #0]
  40024c:	3501      	adds	r5, #1
  40024e:	6035      	str	r5, [r6, #0]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  400250:	f384 8810 	msr	PRIMASK, r4
        next_pool =   _tx_block_pool_created_ptr;
  400254:	4c28      	ldr	r4, [pc, #160]	; (4002f8 <_txe_block_pool_create+0xcc>)
  400256:	6824      	ldr	r4, [r4, #0]
        for (i = ((ULONG) 0); i < _tx_block_pool_created_count; i++)
  400258:	4d28      	ldr	r5, [pc, #160]	; (4002fc <_txe_block_pool_create+0xd0>)
  40025a:	682e      	ldr	r6, [r5, #0]
            if (pool_ptr == next_pool)
  40025c:	42a0      	cmp	r0, r4
  40025e:	d007      	beq.n	400270 <_txe_block_pool_create+0x44>
  400260:	b136      	cbz	r6, 400270 <_txe_block_pool_create+0x44>
  400262:	2500      	movs	r5, #0
                next_pool =  next_pool -> tx_block_pool_created_next;
  400264:	6aa4      	ldr	r4, [r4, #40]	; 0x28
        for (i = ((ULONG) 0); i < _tx_block_pool_created_count; i++)
  400266:	3501      	adds	r5, #1
            if (pool_ptr == next_pool)
  400268:	42a0      	cmp	r0, r4
  40026a:	d001      	beq.n	400270 <_txe_block_pool_create+0x44>
  40026c:	42b5      	cmp	r5, r6
  40026e:	d3f9      	bcc.n	400264 <_txe_block_pool_create+0x38>
  400270:	461e      	mov	r6, r3
  400272:	4617      	mov	r7, r2
  400274:	4688      	mov	r8, r1
  400276:	4605      	mov	r5, r0
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  400278:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  40027c:	b672      	cpsid	i
        _tx_thread_preempt_disable--;
  40027e:	491d      	ldr	r1, [pc, #116]	; (4002f4 <_txe_block_pool_create+0xc8>)
  400280:	680a      	ldr	r2, [r1, #0]
  400282:	3a01      	subs	r2, #1
  400284:	600a      	str	r2, [r1, #0]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  400286:	f383 8810 	msr	PRIMASK, r3
        _tx_thread_system_preempt_check();
  40028a:	4b1d      	ldr	r3, [pc, #116]	; (400300 <_txe_block_pool_create+0xd4>)
  40028c:	4798      	blx	r3
        if (pool_ptr == next_pool)
  40028e:	42a5      	cmp	r5, r4
  400290:	d028      	beq.n	4002e4 <_txe_block_pool_create+0xb8>
        else if (pool_start == TX_NULL)
  400292:	b34e      	cbz	r6, 4002e8 <_txe_block_pool_create+0xbc>
            if ((((block_size/(sizeof(void *)))*(sizeof(void *))) + (sizeof(void *))) >
  400294:	f027 0303 	bic.w	r3, r7, #3
  400298:	3304      	adds	r3, #4
                                            ((pool_size/(sizeof(void *)))*(sizeof(void *))))
  40029a:	9a08      	ldr	r2, [sp, #32]
  40029c:	f022 0203 	bic.w	r2, r2, #3
            if ((((block_size/(sizeof(void *)))*(sizeof(void *))) + (sizeof(void *))) >
  4002a0:	4293      	cmp	r3, r2
  4002a2:	d823      	bhi.n	4002ec <_txe_block_pool_create+0xc0>
                TX_THREAD_GET_CURRENT(thread_ptr)
  4002a4:	4b17      	ldr	r3, [pc, #92]	; (400304 <_txe_block_pool_create+0xd8>)
                if (thread_ptr == &_tx_timer_thread)
  4002a6:	6818      	ldr	r0, [r3, #0]
                    status =  TX_CALLER_ERROR;
  4002a8:	4b17      	ldr	r3, [pc, #92]	; (400308 <_txe_block_pool_create+0xdc>)
  4002aa:	4298      	cmp	r0, r3
  4002ac:	bf0c      	ite	eq
  4002ae:	2013      	moveq	r0, #19
  4002b0:	2000      	movne	r0, #0
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
  4002b2:	f3ef 8305 	mrs	r3, IPSR
                if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
  4002b6:	4a15      	ldr	r2, [pc, #84]	; (40030c <_txe_block_pool_create+0xe0>)
  4002b8:	6812      	ldr	r2, [r2, #0]
  4002ba:	4313      	orrs	r3, r2
  4002bc:	d007      	beq.n	4002ce <_txe_block_pool_create+0xa2>
  4002be:	f3ef 8305 	mrs	r3, IPSR
                    if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
  4002c2:	4a12      	ldr	r2, [pc, #72]	; (40030c <_txe_block_pool_create+0xe0>)
  4002c4:	6812      	ldr	r2, [r2, #0]
  4002c6:	4313      	orrs	r3, r2
  4002c8:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
  4002cc:	d310      	bcc.n	4002f0 <_txe_block_pool_create+0xc4>
    if (status == TX_SUCCESS)
  4002ce:	2800      	cmp	r0, #0
  4002d0:	d1b4      	bne.n	40023c <_txe_block_pool_create+0x10>
        status =  _tx_block_pool_create(pool_ptr, name_ptr, block_size, pool_start, pool_size);
  4002d2:	9b08      	ldr	r3, [sp, #32]
  4002d4:	9300      	str	r3, [sp, #0]
  4002d6:	4633      	mov	r3, r6
  4002d8:	463a      	mov	r2, r7
  4002da:	4641      	mov	r1, r8
  4002dc:	4628      	mov	r0, r5
  4002de:	4c0c      	ldr	r4, [pc, #48]	; (400310 <_txe_block_pool_create+0xe4>)
  4002e0:	47a0      	blx	r4
    return(status);
  4002e2:	e7ab      	b.n	40023c <_txe_block_pool_create+0x10>
            status =  TX_POOL_ERROR;
  4002e4:	2002      	movs	r0, #2
  4002e6:	e7a9      	b.n	40023c <_txe_block_pool_create+0x10>
            status =  TX_PTR_ERROR;
  4002e8:	2003      	movs	r0, #3
  4002ea:	e7a7      	b.n	40023c <_txe_block_pool_create+0x10>
                status =  TX_SIZE_ERROR;
  4002ec:	2005      	movs	r0, #5
  4002ee:	e7a5      	b.n	40023c <_txe_block_pool_create+0x10>
                        status =  TX_CALLER_ERROR;
  4002f0:	2013      	movs	r0, #19
  4002f2:	e7a3      	b.n	40023c <_txe_block_pool_create+0x10>
  4002f4:	2040058c 	.word	0x2040058c
  4002f8:	204004e8 	.word	0x204004e8
  4002fc:	204004dc 	.word	0x204004dc
  400300:	00402469 	.word	0x00402469
  400304:	20400590 	.word	0x20400590
  400308:	20400634 	.word	0x20400634
  40030c:	20400000 	.word	0x20400000
  400310:	00400cd1 	.word	0x00400cd1

00400314 <_txe_block_release>:
UCHAR               **indirect_ptr;
UCHAR               *work_ptr;


    /* First check the supplied pointer.  */
    if (block_ptr == TX_NULL)
  400314:	b160      	cbz	r0, 400330 <_txe_block_release+0x1c>
{
  400316:	b508      	push	{r3, lr}
        /* Pickup the pool pointer which is just previous to the starting
           address of block that the caller sees.  */
        work_ptr =      TX_VOID_TO_UCHAR_POINTER_CONVERT(block_ptr);
        work_ptr =      TX_UCHAR_POINTER_SUB(work_ptr, (sizeof(UCHAR *)));
        indirect_ptr =  TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(work_ptr);
        work_ptr =      *indirect_ptr;
  400318:	f850 3c04 	ldr.w	r3, [r0, #-4]
        pool_ptr =      TX_UCHAR_TO_BLOCK_POOL_POINTER_CONVERT(work_ptr);

        /* Check for an invalid pool pointer.  */
        if (pool_ptr == TX_NULL)
  40031c:	b153      	cbz	r3, 400334 <_txe_block_release+0x20>
            /* Pool pointer is invalid, return appropriate error code.  */
            status =  TX_PTR_ERROR;
        }

        /* Now check for invalid pool ID.  */
        else if  (pool_ptr -> tx_block_pool_id != TX_BLOCK_POOL_ID)
  40031e:	6819      	ldr	r1, [r3, #0]
  400320:	4b05      	ldr	r3, [pc, #20]	; (400338 <_txe_block_release+0x24>)
  400322:	4299      	cmp	r1, r3
  400324:	d001      	beq.n	40032a <_txe_block_release+0x16>
        {

            /* Pool pointer is invalid, return appropriate error code.  */
            status =  TX_PTR_ERROR;
  400326:	2003      	movs	r0, #3
        }
    }

    /* Return completion status.  */
    return(status);
}
  400328:	bd08      	pop	{r3, pc}
            status =  _tx_block_release(block_ptr);
  40032a:	4b04      	ldr	r3, [pc, #16]	; (40033c <_txe_block_release+0x28>)
  40032c:	4798      	blx	r3
  40032e:	bd08      	pop	{r3, pc}
        status =  TX_PTR_ERROR;
  400330:	2003      	movs	r0, #3
  400332:	4770      	bx	lr
            status =  TX_PTR_ERROR;
  400334:	2003      	movs	r0, #3
  400336:	bd08      	pop	{r3, pc}
  400338:	424c4f43 	.word	0x424c4f43
  40033c:	00400d99 	.word	0x00400d99

00400340 <_txe_byte_allocate>:

    /* Default status to success.  */
    status =  TX_SUCCESS;

    /* Check for an invalid byte pool pointer.  */
    if (pool_ptr == TX_NULL)
  400340:	2800      	cmp	r0, #0
  400342:	d02e      	beq.n	4003a2 <_txe_byte_allocate+0x62>
{
  400344:	b538      	push	{r3, r4, r5, lr}
  400346:	4604      	mov	r4, r0
        /* Byte pool pointer is invalid, return appropriate error code.  */
        status =  TX_POOL_ERROR;
    }

    /* Now check for invalid pool ID.  */
    else if  (pool_ptr -> tx_byte_pool_id != TX_BYTE_POOL_ID)
  400348:	6805      	ldr	r5, [r0, #0]
  40034a:	481b      	ldr	r0, [pc, #108]	; (4003b8 <_txe_byte_allocate+0x78>)
  40034c:	4285      	cmp	r5, r0
  40034e:	d001      	beq.n	400354 <_txe_byte_allocate+0x14>
    {

        /* Byte pool pointer is invalid, return appropriate error code.  */
        status =  TX_POOL_ERROR;
  400350:	2002      	movs	r0, #2
  400352:	bd38      	pop	{r3, r4, r5, pc}
    }

    /* Check for an invalid destination for return pointer.  */
    else if (memory_ptr == TX_NULL)
  400354:	b339      	cbz	r1, 4003a6 <_txe_byte_allocate+0x66>
        /* Null destination pointer, return appropriate error.  */
        status =  TX_PTR_ERROR;
    }

    /* Check for an invalid memory size.  */
    else if (memory_size == ((ULONG) 0))
  400356:	b342      	cbz	r2, 4003aa <_txe_byte_allocate+0x6a>
        /* Error in size, return appropriate error.  */
        status =  TX_SIZE_ERROR;
    }

    /* Determine if the size is greater than the pool size.  */
    else if (memory_size > pool_ptr -> tx_byte_pool_size)
  400358:	69e0      	ldr	r0, [r4, #28]
  40035a:	4282      	cmp	r2, r0
  40035c:	d827      	bhi.n	4003ae <_txe_byte_allocate+0x6e>
    else
    {

        /* Check for a wait option error.  Only threads are allowed any form of
           suspension.  */
        if (wait_option != TX_NO_WAIT)
  40035e:	b12b      	cbz	r3, 40036c <_txe_byte_allocate+0x2c>
  400360:	f3ef 8005 	mrs	r0, IPSR
        {

            /* Is call from ISR or Initialization?  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
  400364:	4d15      	ldr	r5, [pc, #84]	; (4003bc <_txe_byte_allocate+0x7c>)
  400366:	682d      	ldr	r5, [r5, #0]
  400368:	4328      	orrs	r0, r5
  40036a:	d122      	bne.n	4003b2 <_txe_byte_allocate+0x72>
    /* Check for timer execution.  */
    if (status == TX_SUCCESS)
    {

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(thread_ptr)
  40036c:	4814      	ldr	r0, [pc, #80]	; (4003c0 <_txe_byte_allocate+0x80>)

        /* Check for invalid caller of this function.  First check for a calling thread.  */
        if (thread_ptr == &_tx_timer_thread)
  40036e:	6805      	ldr	r5, [r0, #0]
  400370:	4814      	ldr	r0, [pc, #80]	; (4003c4 <_txe_byte_allocate+0x84>)
  400372:	4285      	cmp	r5, r0
  400374:	d011      	beq.n	40039a <_txe_byte_allocate+0x5a>
  400376:	f3ef 8005 	mrs	r0, IPSR
    /* Is everything still okay?  */
    if (status == TX_SUCCESS)
    {

        /* Check for interrupt call.  */
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
  40037a:	4d10      	ldr	r5, [pc, #64]	; (4003bc <_txe_byte_allocate+0x7c>)
  40037c:	682d      	ldr	r5, [r5, #0]
  40037e:	4328      	orrs	r0, r5
  400380:	d007      	beq.n	400392 <_txe_byte_allocate+0x52>
  400382:	f3ef 8005 	mrs	r0, IPSR
        {

            /* Now, make sure the call is from an interrupt and not initialization.  */
            if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
  400386:	4d0d      	ldr	r5, [pc, #52]	; (4003bc <_txe_byte_allocate+0x7c>)
  400388:	682d      	ldr	r5, [r5, #0]
  40038a:	4328      	orrs	r0, r5
  40038c:	f1b0 3ff0 	cmp.w	r0, #4042322160	; 0xf0f0f0f0
  400390:	d305      	bcc.n	40039e <_txe_byte_allocate+0x5e>
  400392:	4620      	mov	r0, r4
    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
    {

        /* Call actual byte memory allocate function.  */
        status =  _tx_byte_allocate(pool_ptr, memory_ptr, memory_size,  wait_option);
  400394:	4c0c      	ldr	r4, [pc, #48]	; (4003c8 <_txe_byte_allocate+0x88>)
  400396:	47a0      	blx	r4
  400398:	bd38      	pop	{r3, r4, r5, pc}
            status =  TX_CALLER_ERROR;
  40039a:	2013      	movs	r0, #19
    }

    /* Return completion status.  */
    return(status);
  40039c:	bd38      	pop	{r3, r4, r5, pc}
                status =  TX_CALLER_ERROR;
  40039e:	2013      	movs	r0, #19
  4003a0:	bd38      	pop	{r3, r4, r5, pc}
        status =  TX_POOL_ERROR;
  4003a2:	2002      	movs	r0, #2
  4003a4:	4770      	bx	lr
        status =  TX_PTR_ERROR;
  4003a6:	2003      	movs	r0, #3
  4003a8:	bd38      	pop	{r3, r4, r5, pc}
        status =  TX_SIZE_ERROR;
  4003aa:	2005      	movs	r0, #5
  4003ac:	bd38      	pop	{r3, r4, r5, pc}
        status =  TX_SIZE_ERROR;
  4003ae:	2005      	movs	r0, #5
  4003b0:	bd38      	pop	{r3, r4, r5, pc}
                status =  TX_WAIT_ERROR;
  4003b2:	2004      	movs	r0, #4
}
  4003b4:	bd38      	pop	{r3, r4, r5, pc}
  4003b6:	bf00      	nop
  4003b8:	42595445 	.word	0x42595445
  4003bc:	20400000 	.word	0x20400000
  4003c0:	20400590 	.word	0x20400590
  4003c4:	20400634 	.word	0x20400634
  4003c8:	00400dfd 	.word	0x00400dfd

004003cc <_txe_byte_pool_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_byte_pool_create(TX_BYTE_POOL *pool_ptr, CHAR *name_ptr, VOID *pool_start, ULONG pool_size, UINT pool_control_block_size)
{
  4003cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        /* Byte pool pointer is invalid, return appropriate error code.  */
        status =  TX_POOL_ERROR;
    }

    /* Now see if the pool control block size is valid.  */
    else if (pool_control_block_size != (sizeof(TX_BYTE_POOL)))
  4003d0:	9c06      	ldr	r4, [sp, #24]
  4003d2:	2c34      	cmp	r4, #52	; 0x34
  4003d4:	d100      	bne.n	4003d8 <_txe_byte_pool_create+0xc>
  4003d6:	b910      	cbnz	r0, 4003de <_txe_byte_pool_create+0x12>
    {

        /* Byte pool pointer is invalid, return appropriate error code.  */
        status =  TX_POOL_ERROR;
  4003d8:	2002      	movs	r0, #2
  4003da:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  4003de:	f3ef 8410 	mrs	r4, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  4003e2:	b672      	cpsid	i

        /* Disable interrupts.  */
        TX_DISABLE

        /* Increment the preempt disable flag.  */
        _tx_thread_preempt_disable++;
  4003e4:	4e28      	ldr	r6, [pc, #160]	; (400488 <_txe_byte_pool_create+0xbc>)
  4003e6:	6835      	ldr	r5, [r6, #0]
  4003e8:	3501      	adds	r5, #1
  4003ea:	6035      	str	r5, [r6, #0]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  4003ec:	f384 8810 	msr	PRIMASK, r4

        /* Restore interrupts.  */
        TX_RESTORE

        /* Next see if it is already in the created list.  */
        next_pool =   _tx_byte_pool_created_ptr;
  4003f0:	4c26      	ldr	r4, [pc, #152]	; (40048c <_txe_byte_pool_create+0xc0>)
  4003f2:	6824      	ldr	r4, [r4, #0]
        for (i = ((ULONG) 0); i < _tx_byte_pool_created_count; i++)
  4003f4:	4d26      	ldr	r5, [pc, #152]	; (400490 <_txe_byte_pool_create+0xc4>)
  4003f6:	682e      	ldr	r6, [r5, #0]
        {

            /* Determine if this byte pool matches the pool in the list.  */
            if (pool_ptr == next_pool)
  4003f8:	42a0      	cmp	r0, r4
  4003fa:	d007      	beq.n	40040c <_txe_byte_pool_create+0x40>
  4003fc:	b136      	cbz	r6, 40040c <_txe_byte_pool_create+0x40>
  4003fe:	2500      	movs	r5, #0
            }
            else
            {

                /* Move to the next pool.  */
                next_pool =  next_pool -> tx_byte_pool_created_next;
  400400:	6ae4      	ldr	r4, [r4, #44]	; 0x2c
        for (i = ((ULONG) 0); i < _tx_byte_pool_created_count; i++)
  400402:	3501      	adds	r5, #1
            if (pool_ptr == next_pool)
  400404:	42a0      	cmp	r0, r4
  400406:	d001      	beq.n	40040c <_txe_byte_pool_create+0x40>
  400408:	42b5      	cmp	r5, r6
  40040a:	d3f9      	bcc.n	400400 <_txe_byte_pool_create+0x34>
  40040c:	461f      	mov	r7, r3
  40040e:	4616      	mov	r6, r2
  400410:	4688      	mov	r8, r1
  400412:	4605      	mov	r5, r0
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  400414:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  400418:	b672      	cpsid	i

        /* Disable interrupts.  */
        TX_DISABLE

        /* Decrement the preempt disable flag.  */
        _tx_thread_preempt_disable--;
  40041a:	491b      	ldr	r1, [pc, #108]	; (400488 <_txe_byte_pool_create+0xbc>)
  40041c:	680a      	ldr	r2, [r1, #0]
  40041e:	3a01      	subs	r2, #1
  400420:	600a      	str	r2, [r1, #0]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  400422:	f383 8810 	msr	PRIMASK, r3

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
  400426:	4b1b      	ldr	r3, [pc, #108]	; (400494 <_txe_byte_pool_create+0xc8>)
  400428:	4798      	blx	r3

        /* At this point, check to see if there is a duplicate pool.  */
        if (pool_ptr == next_pool)
  40042a:	42a5      	cmp	r5, r4
  40042c:	d020      	beq.n	400470 <_txe_byte_pool_create+0xa4>
            /* Pool is already created, return appropriate error code.  */
            status =  TX_POOL_ERROR;
        }

        /* Check for an invalid starting address.  */
        else if (pool_start == TX_NULL)
  40042e:	b316      	cbz	r6, 400476 <_txe_byte_pool_create+0xaa>
            /* Null starting address pointer, return appropriate error.  */
            status =  TX_PTR_ERROR;
        }

        /* Check for invalid pool size.  */
        else if (pool_size < TX_BYTE_POOL_MIN)
  400430:	2f63      	cmp	r7, #99	; 0x63
  400432:	d923      	bls.n	40047c <_txe_byte_pool_create+0xb0>
        {

#ifndef TX_TIMER_PROCESS_IN_ISR

            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(thread_ptr)
  400434:	4b18      	ldr	r3, [pc, #96]	; (400498 <_txe_byte_pool_create+0xcc>)

            /* Check for invalid caller of this function.  First check for a calling thread.  */
            if (thread_ptr == &_tx_timer_thread)
  400436:	6818      	ldr	r0, [r3, #0]
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
  400438:	4b18      	ldr	r3, [pc, #96]	; (40049c <_txe_byte_pool_create+0xd0>)
  40043a:	4298      	cmp	r0, r3
  40043c:	bf0c      	ite	eq
  40043e:	2013      	moveq	r0, #19
  400440:	2000      	movne	r0, #0
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
  400442:	f3ef 8305 	mrs	r3, IPSR
            }
#endif

            /* Check for interrupt call.  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
  400446:	4a16      	ldr	r2, [pc, #88]	; (4004a0 <_txe_byte_pool_create+0xd4>)
  400448:	6812      	ldr	r2, [r2, #0]
  40044a:	4313      	orrs	r3, r2
  40044c:	d007      	beq.n	40045e <_txe_byte_pool_create+0x92>
  40044e:	f3ef 8305 	mrs	r3, IPSR
            {

                /* Now, make sure the call is from an interrupt and not initialization.  */
                if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
  400452:	4a13      	ldr	r2, [pc, #76]	; (4004a0 <_txe_byte_pool_create+0xd4>)
  400454:	6812      	ldr	r2, [r2, #0]
  400456:	4313      	orrs	r3, r2
  400458:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
  40045c:	d311      	bcc.n	400482 <_txe_byte_pool_create+0xb6>
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
  40045e:	b988      	cbnz	r0, 400484 <_txe_byte_pool_create+0xb8>
    {

        /* Call actual byte pool create function.  */
        status =  _tx_byte_pool_create(pool_ptr, name_ptr, pool_start, pool_size);
  400460:	463b      	mov	r3, r7
  400462:	4632      	mov	r2, r6
  400464:	4641      	mov	r1, r8
  400466:	4628      	mov	r0, r5
  400468:	4c0e      	ldr	r4, [pc, #56]	; (4004a4 <_txe_byte_pool_create+0xd8>)
  40046a:	47a0      	blx	r4
    }

    /* Return completion status.  */
    return(status);
  40046c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            status =  TX_POOL_ERROR;
  400470:	2002      	movs	r0, #2
  400472:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            status =  TX_PTR_ERROR;
  400476:	2003      	movs	r0, #3
  400478:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            status =  TX_SIZE_ERROR;
  40047c:	2005      	movs	r0, #5
  40047e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                    status =  TX_CALLER_ERROR;
  400482:	2013      	movs	r0, #19
}
  400484:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  400488:	2040058c 	.word	0x2040058c
  40048c:	204004d4 	.word	0x204004d4
  400490:	204004f0 	.word	0x204004f0
  400494:	00402469 	.word	0x00402469
  400498:	20400590 	.word	0x20400590
  40049c:	20400634 	.word	0x20400634
  4004a0:	20400000 	.word	0x20400000
  4004a4:	00400f61 	.word	0x00400f61

004004a8 <_txe_event_flags_create>:
        /* Event flags group pointer is invalid, return appropriate error code.  */
        status =  TX_GROUP_ERROR;
    }

    /* Now check for proper control block size.  */
    else if (event_control_block_size != (sizeof(TX_EVENT_FLAGS_GROUP)))
  4004a8:	2a28      	cmp	r2, #40	; 0x28
  4004aa:	d100      	bne.n	4004ae <_txe_event_flags_create+0x6>
  4004ac:	b908      	cbnz	r0, 4004b2 <_txe_event_flags_create+0xa>
    {

        /* Event flags group pointer is invalid, return appropriate error code.  */
        status =  TX_GROUP_ERROR;
  4004ae:	2006      	movs	r0, #6
  4004b0:	4770      	bx	lr
{
  4004b2:	b570      	push	{r4, r5, r6, lr}
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  4004b4:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  4004b8:	b672      	cpsid	i

        /* Disable interrupts.  */
        TX_DISABLE

        /* Increment the preempt disable flag.  */
        _tx_thread_preempt_disable++;
  4004ba:	4c21      	ldr	r4, [pc, #132]	; (400540 <_txe_event_flags_create+0x98>)
  4004bc:	6822      	ldr	r2, [r4, #0]
  4004be:	3201      	adds	r2, #1
  4004c0:	6022      	str	r2, [r4, #0]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  4004c2:	f383 8810 	msr	PRIMASK, r3

        /* Restore interrupts.  */
        TX_RESTORE

        /* Next see if it is already in the created list.  */
        next_group =   _tx_event_flags_created_ptr;
  4004c6:	4b1f      	ldr	r3, [pc, #124]	; (400544 <_txe_event_flags_create+0x9c>)
  4004c8:	681c      	ldr	r4, [r3, #0]
        for (i = ((ULONG) 0); i < _tx_event_flags_created_count; i++)
  4004ca:	4b1f      	ldr	r3, [pc, #124]	; (400548 <_txe_event_flags_create+0xa0>)
  4004cc:	681a      	ldr	r2, [r3, #0]
        {

            /* Determine if this group matches the event flags group in the list.  */
            if (group_ptr == next_group)
  4004ce:	42a0      	cmp	r0, r4
  4004d0:	d007      	beq.n	4004e2 <_txe_event_flags_create+0x3a>
  4004d2:	b132      	cbz	r2, 4004e2 <_txe_event_flags_create+0x3a>
  4004d4:	2300      	movs	r3, #0
            }
            else
            {

                /* Move to the next group.  */
                next_group =  next_group -> tx_event_flags_group_created_next;
  4004d6:	69a4      	ldr	r4, [r4, #24]
        for (i = ((ULONG) 0); i < _tx_event_flags_created_count; i++)
  4004d8:	3301      	adds	r3, #1
            if (group_ptr == next_group)
  4004da:	42a0      	cmp	r0, r4
  4004dc:	d001      	beq.n	4004e2 <_txe_event_flags_create+0x3a>
  4004de:	4293      	cmp	r3, r2
  4004e0:	d3f9      	bcc.n	4004d6 <_txe_event_flags_create+0x2e>
  4004e2:	460e      	mov	r6, r1
  4004e4:	4605      	mov	r5, r0
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  4004e6:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  4004ea:	b672      	cpsid	i

        /* Disable interrupts.  */
        TX_DISABLE

        /* Decrement the preempt disable flag.  */
        _tx_thread_preempt_disable--;
  4004ec:	4914      	ldr	r1, [pc, #80]	; (400540 <_txe_event_flags_create+0x98>)
  4004ee:	680a      	ldr	r2, [r1, #0]
  4004f0:	3a01      	subs	r2, #1
  4004f2:	600a      	str	r2, [r1, #0]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  4004f4:	f383 8810 	msr	PRIMASK, r3

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
  4004f8:	4b14      	ldr	r3, [pc, #80]	; (40054c <_txe_event_flags_create+0xa4>)
  4004fa:	4798      	blx	r3

        /* At this point, check to see if there is a duplicate event flag group.  */
        if (group_ptr == next_group)
  4004fc:	42a5      	cmp	r5, r4
  4004fe:	d01a      	beq.n	400536 <_txe_event_flags_create+0x8e>
        {

#ifndef TX_TIMER_PROCESS_IN_ISR

            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(thread_ptr)
  400500:	4b13      	ldr	r3, [pc, #76]	; (400550 <_txe_event_flags_create+0xa8>)

            /* Check for invalid caller of this function.  First check for a calling thread.  */
            if (thread_ptr == &_tx_timer_thread)
  400502:	6818      	ldr	r0, [r3, #0]
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
  400504:	4b13      	ldr	r3, [pc, #76]	; (400554 <_txe_event_flags_create+0xac>)
  400506:	4298      	cmp	r0, r3
  400508:	bf0c      	ite	eq
  40050a:	2013      	moveq	r0, #19
  40050c:	2000      	movne	r0, #0
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
  40050e:	f3ef 8305 	mrs	r3, IPSR
            }
#endif

            /* Check for interrupt call.  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
  400512:	4a11      	ldr	r2, [pc, #68]	; (400558 <_txe_event_flags_create+0xb0>)
  400514:	6812      	ldr	r2, [r2, #0]
  400516:	4313      	orrs	r3, r2
  400518:	d007      	beq.n	40052a <_txe_event_flags_create+0x82>
  40051a:	f3ef 8305 	mrs	r3, IPSR
            {

                /* Now, make sure the call is from an interrupt and not initialization.  */
                if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
  40051e:	4a0e      	ldr	r2, [pc, #56]	; (400558 <_txe_event_flags_create+0xb0>)
  400520:	6812      	ldr	r2, [r2, #0]
  400522:	4313      	orrs	r3, r2
  400524:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
  400528:	d307      	bcc.n	40053a <_txe_event_flags_create+0x92>
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
  40052a:	b938      	cbnz	r0, 40053c <_txe_event_flags_create+0x94>
    {

        /* Call actual event flags create function.  */
        status =  _tx_event_flags_create(group_ptr, name_ptr);
  40052c:	4631      	mov	r1, r6
  40052e:	4628      	mov	r0, r5
  400530:	4b0a      	ldr	r3, [pc, #40]	; (40055c <_txe_event_flags_create+0xb4>)
  400532:	4798      	blx	r3
    }

    /* Return completion status.  */
    return(status);
  400534:	bd70      	pop	{r4, r5, r6, pc}
            status =  TX_GROUP_ERROR;
  400536:	2006      	movs	r0, #6
  400538:	bd70      	pop	{r4, r5, r6, pc}
                    status =  TX_CALLER_ERROR;
  40053a:	2013      	movs	r0, #19
}
  40053c:	bd70      	pop	{r4, r5, r6, pc}
  40053e:	bf00      	nop
  400540:	2040058c 	.word	0x2040058c
  400544:	204004c0 	.word	0x204004c0
  400548:	204004e4 	.word	0x204004e4
  40054c:	00402469 	.word	0x00402469
  400550:	20400590 	.word	0x20400590
  400554:	20400634 	.word	0x20400634
  400558:	20400000 	.word	0x20400000
  40055c:	0040117d 	.word	0x0040117d

00400560 <_txe_event_flags_get>:

    /* Default status to success.  */
    status =  TX_SUCCESS;

    /* Check for an invalid event flag group pointer.  */
    if (group_ptr == TX_NULL)
  400560:	b308      	cbz	r0, 4005a6 <_txe_event_flags_get+0x46>
{
  400562:	b530      	push	{r4, r5, lr}
  400564:	b083      	sub	sp, #12
  400566:	4604      	mov	r4, r0
        /* Event flags group pointer is invalid, return appropriate error code.  */
        status =  TX_GROUP_ERROR;
    }

    /* Now check for invalid event group ID.  */
    else if (group_ptr -> tx_event_flags_group_id != TX_EVENT_FLAGS_ID)
  400568:	6805      	ldr	r5, [r0, #0]
  40056a:	4813      	ldr	r0, [pc, #76]	; (4005b8 <_txe_event_flags_get+0x58>)
  40056c:	4285      	cmp	r5, r0
  40056e:	d002      	beq.n	400576 <_txe_event_flags_get+0x16>
    {

        /* Event flags group pointer is invalid, return appropriate error code.  */
        status =  TX_GROUP_ERROR;
  400570:	2006      	movs	r0, #6
        status =  _tx_event_flags_get(group_ptr, requested_flags, get_option, actual_flags_ptr, wait_option);
    }

    /* Return completion status.  */
    return(status);
}
  400572:	b003      	add	sp, #12
  400574:	bd30      	pop	{r4, r5, pc}
    else if (actual_flags_ptr == TX_NULL)
  400576:	b1c3      	cbz	r3, 4005aa <_txe_event_flags_get+0x4a>
        if (wait_option != TX_NO_WAIT)
  400578:	9806      	ldr	r0, [sp, #24]
  40057a:	b150      	cbz	r0, 400592 <_txe_event_flags_get+0x32>
  40057c:	f3ef 8005 	mrs	r0, IPSR
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
  400580:	4d0e      	ldr	r5, [pc, #56]	; (4005bc <_txe_event_flags_get+0x5c>)
  400582:	682d      	ldr	r5, [r5, #0]
  400584:	4328      	orrs	r0, r5
  400586:	d112      	bne.n	4005ae <_txe_event_flags_get+0x4e>
                TX_THREAD_GET_CURRENT(current_thread)
  400588:	480d      	ldr	r0, [pc, #52]	; (4005c0 <_txe_event_flags_get+0x60>)
                if (current_thread == &_tx_timer_thread)
  40058a:	6805      	ldr	r5, [r0, #0]
  40058c:	480d      	ldr	r0, [pc, #52]	; (4005c4 <_txe_event_flags_get+0x64>)
  40058e:	4285      	cmp	r5, r0
  400590:	d00f      	beq.n	4005b2 <_txe_event_flags_get+0x52>
        if (get_option > TX_AND_CLEAR)
  400592:	2a03      	cmp	r2, #3
  400594:	d901      	bls.n	40059a <_txe_event_flags_get+0x3a>
            status =  TX_OPTION_ERROR;
  400596:	2008      	movs	r0, #8
    return(status);
  400598:	e7eb      	b.n	400572 <_txe_event_flags_get+0x12>
  40059a:	4620      	mov	r0, r4
        status =  _tx_event_flags_get(group_ptr, requested_flags, get_option, actual_flags_ptr, wait_option);
  40059c:	9c06      	ldr	r4, [sp, #24]
  40059e:	9400      	str	r4, [sp, #0]
  4005a0:	4c09      	ldr	r4, [pc, #36]	; (4005c8 <_txe_event_flags_get+0x68>)
  4005a2:	47a0      	blx	r4
  4005a4:	e7e5      	b.n	400572 <_txe_event_flags_get+0x12>
        status =  TX_GROUP_ERROR;
  4005a6:	2006      	movs	r0, #6
  4005a8:	4770      	bx	lr
        status =  TX_PTR_ERROR;
  4005aa:	2003      	movs	r0, #3
  4005ac:	e7e1      	b.n	400572 <_txe_event_flags_get+0x12>
                status =  TX_WAIT_ERROR;
  4005ae:	2004      	movs	r0, #4
  4005b0:	e7df      	b.n	400572 <_txe_event_flags_get+0x12>
                    status =  TX_WAIT_ERROR;
  4005b2:	2004      	movs	r0, #4
  4005b4:	e7dd      	b.n	400572 <_txe_event_flags_get+0x12>
  4005b6:	bf00      	nop
  4005b8:	4456444e 	.word	0x4456444e
  4005bc:	20400000 	.word	0x20400000
  4005c0:	20400590 	.word	0x20400590
  4005c4:	20400634 	.word	0x20400634
  4005c8:	004011d5 	.word	0x004011d5

004005cc <_txe_event_flags_set>:

    /* Default status to success.  */
    status =  TX_SUCCESS;

    /* Check for an invalid event flag group pointer.  */
    if (group_ptr == TX_NULL)
  4005cc:	b170      	cbz	r0, 4005ec <_txe_event_flags_set+0x20>
{
  4005ce:	b510      	push	{r4, lr}
  4005d0:	4603      	mov	r3, r0
        /* Event flags group pointer is invalid, return appropriate error code.  */
        status =  TX_GROUP_ERROR;
    }

    /* Now check for invalid event flag group ID.  */
    else if (group_ptr -> tx_event_flags_group_id != TX_EVENT_FLAGS_ID)
  4005d2:	6804      	ldr	r4, [r0, #0]
  4005d4:	4807      	ldr	r0, [pc, #28]	; (4005f4 <_txe_event_flags_set+0x28>)
  4005d6:	4284      	cmp	r4, r0
  4005d8:	d001      	beq.n	4005de <_txe_event_flags_set+0x12>
    {

        /* Event flags group pointer is invalid, return appropriate error code.  */
        status =  TX_GROUP_ERROR;
  4005da:	2006      	movs	r0, #6
  4005dc:	bd10      	pop	{r4, pc}

        /* Check for invalid set option.  */
        if (set_option != TX_AND)
        {

            if (set_option != TX_OR)
  4005de:	f032 0002 	bics.w	r0, r2, #2
  4005e2:	d105      	bne.n	4005f0 <_txe_event_flags_set+0x24>
  4005e4:	4618      	mov	r0, r3
    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
    {

        /* Call actual event flags set function.  */
        status =  _tx_event_flags_set(group_ptr, flags_to_set, set_option);
  4005e6:	4b04      	ldr	r3, [pc, #16]	; (4005f8 <_txe_event_flags_set+0x2c>)
  4005e8:	4798      	blx	r3
  4005ea:	bd10      	pop	{r4, pc}
        status =  TX_GROUP_ERROR;
  4005ec:	2006      	movs	r0, #6
  4005ee:	4770      	bx	lr
                status =  TX_OPTION_ERROR;
  4005f0:	2008      	movs	r0, #8
    }

    /* Return completion status.  */
    return(status);
}
  4005f2:	bd10      	pop	{r4, pc}
  4005f4:	4456444e 	.word	0x4456444e
  4005f8:	004012b5 	.word	0x004012b5

004005fc <_txe_mutex_create>:
        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
    }

    /* Now check to make sure the control block is the correct size.  */
    else if (mutex_control_block_size != (sizeof(TX_MUTEX)))
  4005fc:	2b34      	cmp	r3, #52	; 0x34
  4005fe:	d100      	bne.n	400602 <_txe_mutex_create+0x6>
  400600:	b908      	cbnz	r0, 400606 <_txe_mutex_create+0xa>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
  400602:	201c      	movs	r0, #28
  400604:	4770      	bx	lr
{
  400606:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  400608:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  40060c:	b672      	cpsid	i

        /* Disable interrupts.  */
        TX_DISABLE

        /* Increment the preempt disable flag.  */
        _tx_thread_preempt_disable++;
  40060e:	4d24      	ldr	r5, [pc, #144]	; (4006a0 <_txe_mutex_create+0xa4>)
  400610:	682c      	ldr	r4, [r5, #0]
  400612:	3401      	adds	r4, #1
  400614:	602c      	str	r4, [r5, #0]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  400616:	f383 8810 	msr	PRIMASK, r3

        /* Restore interrupts.  */
        TX_RESTORE

        /* Next see if it is already in the created list.  */
        next_mutex =   _tx_mutex_created_ptr;
  40061a:	4b22      	ldr	r3, [pc, #136]	; (4006a4 <_txe_mutex_create+0xa8>)
  40061c:	681c      	ldr	r4, [r3, #0]
        for (i = ((ULONG) 0); i < _tx_mutex_created_count; i++)
  40061e:	4b22      	ldr	r3, [pc, #136]	; (4006a8 <_txe_mutex_create+0xac>)
  400620:	681d      	ldr	r5, [r3, #0]
        {

            /* Determine if this mutex matches the mutex in the list.  */
            if (mutex_ptr == next_mutex)
  400622:	42a0      	cmp	r0, r4
  400624:	d007      	beq.n	400636 <_txe_mutex_create+0x3a>
  400626:	b135      	cbz	r5, 400636 <_txe_mutex_create+0x3a>
  400628:	2300      	movs	r3, #0
            }
            else
            {

                /* Move to the next mutex.  */
                next_mutex =  next_mutex -> tx_mutex_created_next;
  40062a:	6a24      	ldr	r4, [r4, #32]
        for (i = ((ULONG) 0); i < _tx_mutex_created_count; i++)
  40062c:	3301      	adds	r3, #1
            if (mutex_ptr == next_mutex)
  40062e:	42a0      	cmp	r0, r4
  400630:	d001      	beq.n	400636 <_txe_mutex_create+0x3a>
  400632:	42ab      	cmp	r3, r5
  400634:	d3f9      	bcc.n	40062a <_txe_mutex_create+0x2e>
  400636:	4616      	mov	r6, r2
  400638:	460f      	mov	r7, r1
  40063a:	4605      	mov	r5, r0
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  40063c:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  400640:	b672      	cpsid	i

        /* Disable interrupts.  */
        TX_DISABLE

        /* Decrement the preempt disable flag.  */
        _tx_thread_preempt_disable--;
  400642:	4917      	ldr	r1, [pc, #92]	; (4006a0 <_txe_mutex_create+0xa4>)
  400644:	680a      	ldr	r2, [r1, #0]
  400646:	3a01      	subs	r2, #1
  400648:	600a      	str	r2, [r1, #0]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  40064a:	f383 8810 	msr	PRIMASK, r3

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
  40064e:	4b17      	ldr	r3, [pc, #92]	; (4006ac <_txe_mutex_create+0xb0>)
  400650:	4798      	blx	r3

        /* At this point, check to see if there is a duplicate mutex.  */
        if (mutex_ptr == next_mutex)
  400652:	42a5      	cmp	r5, r4
  400654:	d01f      	beq.n	400696 <_txe_mutex_create+0x9a>

            /* Check for a valid inherit option.  */
            if (inherit != TX_INHERIT)
            {

                if (inherit != TX_NO_INHERIT)
  400656:	2e01      	cmp	r6, #1
  400658:	d81f      	bhi.n	40069a <_txe_mutex_create+0x9e>
    {

#ifndef TX_TIMER_PROCESS_IN_ISR

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(thread_ptr)
  40065a:	4b15      	ldr	r3, [pc, #84]	; (4006b0 <_txe_mutex_create+0xb4>)

        /* Check for invalid caller of this function.  First check for a calling thread.  */
        if (thread_ptr == &_tx_timer_thread)
  40065c:	6818      	ldr	r0, [r3, #0]
  40065e:	4b15      	ldr	r3, [pc, #84]	; (4006b4 <_txe_mutex_create+0xb8>)
  400660:	4298      	cmp	r0, r3
  400662:	bf0c      	ite	eq
  400664:	2013      	moveq	r0, #19
  400666:	2000      	movne	r0, #0
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
  400668:	f3ef 8305 	mrs	r3, IPSR
            status =  TX_CALLER_ERROR;
        }
#endif

        /* Check for interrupt call.  */
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
  40066c:	4a12      	ldr	r2, [pc, #72]	; (4006b8 <_txe_mutex_create+0xbc>)
  40066e:	6812      	ldr	r2, [r2, #0]
  400670:	4313      	orrs	r3, r2
  400672:	d007      	beq.n	400684 <_txe_mutex_create+0x88>
  400674:	f3ef 8305 	mrs	r3, IPSR
        {

            /* Now, make sure the call is from an interrupt and not initialization.  */
            if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
  400678:	4a0f      	ldr	r2, [pc, #60]	; (4006b8 <_txe_mutex_create+0xbc>)
  40067a:	6812      	ldr	r2, [r2, #0]
  40067c:	4313      	orrs	r3, r2
  40067e:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
  400682:	d306      	bcc.n	400692 <_txe_mutex_create+0x96>
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
  400684:	b950      	cbnz	r0, 40069c <_txe_mutex_create+0xa0>
    {

        /* Call actual mutex create function.  */
        status =  _tx_mutex_create(mutex_ptr, name_ptr, inherit);
  400686:	4632      	mov	r2, r6
  400688:	4639      	mov	r1, r7
  40068a:	4628      	mov	r0, r5
  40068c:	4b0b      	ldr	r3, [pc, #44]	; (4006bc <_txe_mutex_create+0xc0>)
  40068e:	4798      	blx	r3
  400690:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                status =  TX_CALLER_ERROR;
  400692:	2013      	movs	r0, #19
    }

    /* Return completion status.  */
    return(status);
  400694:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            status =  TX_MUTEX_ERROR;
  400696:	201c      	movs	r0, #28
  400698:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                    status =  TX_INHERIT_ERROR;
  40069a:	201f      	movs	r0, #31
}
  40069c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40069e:	bf00      	nop
  4006a0:	2040058c 	.word	0x2040058c
  4006a4:	204004c8 	.word	0x204004c8
  4006a8:	204004c4 	.word	0x204004c4
  4006ac:	00402469 	.word	0x00402469
  4006b0:	20400590 	.word	0x20400590
  4006b4:	20400634 	.word	0x20400634
  4006b8:	20400000 	.word	0x20400000
  4006bc:	00401655 	.word	0x00401655

004006c0 <_txe_mutex_get>:

    /* Default status to success.  */
    status =  TX_SUCCESS;

    /* Check for an invalid mutex pointer.  */
    if (mutex_ptr == TX_NULL)
  4006c0:	b338      	cbz	r0, 400712 <_txe_mutex_get+0x52>
{
  4006c2:	b508      	push	{r3, lr}
  4006c4:	4603      	mov	r3, r0
        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
    }

    /* Now check for a valid mutex ID.  */
    else if (mutex_ptr -> tx_mutex_id != TX_MUTEX_ID)
  4006c6:	6800      	ldr	r0, [r0, #0]
  4006c8:	4a15      	ldr	r2, [pc, #84]	; (400720 <_txe_mutex_get+0x60>)
  4006ca:	4290      	cmp	r0, r2
  4006cc:	d001      	beq.n	4006d2 <_txe_mutex_get+0x12>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
  4006ce:	201c      	movs	r0, #28
  4006d0:	bd08      	pop	{r3, pc}
    else
    {

        /* Check for a wait option error.  Only threads are allowed any form of
           suspension.  */
        if (wait_option != TX_NO_WAIT)
  4006d2:	b151      	cbz	r1, 4006ea <_txe_mutex_get+0x2a>
  4006d4:	f3ef 8205 	mrs	r2, IPSR
        {

            /* Is the call from an ISR or Initialization?  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
  4006d8:	4812      	ldr	r0, [pc, #72]	; (400724 <_txe_mutex_get+0x64>)
  4006da:	6800      	ldr	r0, [r0, #0]
  4006dc:	4302      	orrs	r2, r0
  4006de:	d11a      	bne.n	400716 <_txe_mutex_get+0x56>
#ifndef TX_TIMER_PROCESS_IN_ISR
            else
            {

                /* Pickup thread pointer.  */
                TX_THREAD_GET_CURRENT(current_thread)
  4006e0:	4a11      	ldr	r2, [pc, #68]	; (400728 <_txe_mutex_get+0x68>)

                /* Is the current thread the timer thread?  */
                if (current_thread == &_tx_timer_thread)
  4006e2:	6810      	ldr	r0, [r2, #0]
  4006e4:	4a11      	ldr	r2, [pc, #68]	; (40072c <_txe_mutex_get+0x6c>)
  4006e6:	4290      	cmp	r0, r2
  4006e8:	d017      	beq.n	40071a <_txe_mutex_get+0x5a>
  4006ea:	f3ef 8205 	mrs	r2, IPSR
    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
    {

        /* Check for interrupt call.  */
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
  4006ee:	480d      	ldr	r0, [pc, #52]	; (400724 <_txe_mutex_get+0x64>)
  4006f0:	6800      	ldr	r0, [r0, #0]
  4006f2:	4302      	orrs	r2, r0
  4006f4:	d103      	bne.n	4006fe <_txe_mutex_get+0x3e>
  4006f6:	4618      	mov	r0, r3
    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
    {

        /* Call actual get mutex function.  */
        status =  _tx_mutex_get(mutex_ptr, wait_option);
  4006f8:	4b0d      	ldr	r3, [pc, #52]	; (400730 <_txe_mutex_get+0x70>)
  4006fa:	4798      	blx	r3
  4006fc:	bd08      	pop	{r3, pc}
  4006fe:	f3ef 8205 	mrs	r2, IPSR
            if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
  400702:	4808      	ldr	r0, [pc, #32]	; (400724 <_txe_mutex_get+0x64>)
  400704:	6800      	ldr	r0, [r0, #0]
  400706:	4302      	orrs	r2, r0
  400708:	f1b2 3ff0 	cmp.w	r2, #4042322160	; 0xf0f0f0f0
  40070c:	d2f3      	bcs.n	4006f6 <_txe_mutex_get+0x36>
                status =  TX_CALLER_ERROR;
  40070e:	2013      	movs	r0, #19
    }

    /* Return completion status.  */
    return(status);
  400710:	bd08      	pop	{r3, pc}
        status =  TX_MUTEX_ERROR;
  400712:	201c      	movs	r0, #28
  400714:	4770      	bx	lr
                status =  TX_WAIT_ERROR;
  400716:	2004      	movs	r0, #4
  400718:	bd08      	pop	{r3, pc}
                    status =  TX_WAIT_ERROR;
  40071a:	2004      	movs	r0, #4
}
  40071c:	bd08      	pop	{r3, pc}
  40071e:	bf00      	nop
  400720:	4d555445 	.word	0x4d555445
  400724:	20400000 	.word	0x20400000
  400728:	20400590 	.word	0x20400590
  40072c:	20400634 	.word	0x20400634
  400730:	004016c1 	.word	0x004016c1

00400734 <_txe_mutex_put>:

    /* Default status to success.  */
    status =  TX_SUCCESS;

    /* Check for an invalid mutex pointer.  */
    if (mutex_ptr == TX_NULL)
  400734:	b1c8      	cbz	r0, 40076a <_txe_mutex_put+0x36>
{
  400736:	b508      	push	{r3, lr}
  400738:	4603      	mov	r3, r0
        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
    }

    /* Now check for invalid mutex ID.  */
    else if (mutex_ptr -> tx_mutex_id != TX_MUTEX_ID)
  40073a:	6801      	ldr	r1, [r0, #0]
  40073c:	4a0d      	ldr	r2, [pc, #52]	; (400774 <_txe_mutex_put+0x40>)
  40073e:	4291      	cmp	r1, r2
  400740:	d001      	beq.n	400746 <_txe_mutex_put+0x12>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
  400742:	201c      	movs	r0, #28
  400744:	bd08      	pop	{r3, pc}
  400746:	f3ef 8205 	mrs	r2, IPSR
    }
    else
    {

        /* Check for interrupt call.  */
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
  40074a:	490b      	ldr	r1, [pc, #44]	; (400778 <_txe_mutex_put+0x44>)
  40074c:	6809      	ldr	r1, [r1, #0]
  40074e:	430a      	orrs	r2, r1
  400750:	d007      	beq.n	400762 <_txe_mutex_put+0x2e>
  400752:	f3ef 8205 	mrs	r2, IPSR
        {

            /* Now, make sure the call is from an interrupt and not initialization.  */
            if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
  400756:	4908      	ldr	r1, [pc, #32]	; (400778 <_txe_mutex_put+0x44>)
  400758:	6809      	ldr	r1, [r1, #0]
  40075a:	430a      	orrs	r2, r1
  40075c:	f1b2 3ff0 	cmp.w	r2, #4042322160	; 0xf0f0f0f0
  400760:	d305      	bcc.n	40076e <_txe_mutex_put+0x3a>
  400762:	4618      	mov	r0, r3
    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
    {

        /* Call actual put mutex function.  */
        status =  _tx_mutex_put(mutex_ptr);
  400764:	4b05      	ldr	r3, [pc, #20]	; (40077c <_txe_mutex_put+0x48>)
  400766:	4798      	blx	r3
  400768:	bd08      	pop	{r3, pc}
        status =  TX_MUTEX_ERROR;
  40076a:	201c      	movs	r0, #28
  40076c:	4770      	bx	lr
                status =  TX_CALLER_ERROR;
  40076e:	2013      	movs	r0, #19
    }

    /* Return completion status.  */
    return(status);
}
  400770:	bd08      	pop	{r3, pc}
  400772:	bf00      	nop
  400774:	4d555445 	.word	0x4d555445
  400778:	20400000 	.word	0x20400000
  40077c:	00401949 	.word	0x00401949

00400780 <_txe_queue_create>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_queue_create(TX_QUEUE *queue_ptr, CHAR *name_ptr, UINT message_size,
                        VOID *queue_start, ULONG queue_size, UINT queue_control_block_size)
{
  400780:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  400784:	b082      	sub	sp, #8
        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
    }

    /* Now check for a valid control block size.  */
    else if (queue_control_block_size != (sizeof(TX_QUEUE)))
  400786:	9c09      	ldr	r4, [sp, #36]	; 0x24
  400788:	2c3c      	cmp	r4, #60	; 0x3c
  40078a:	d100      	bne.n	40078e <_txe_queue_create+0xe>
  40078c:	b918      	cbnz	r0, 400796 <_txe_queue_create+0x16>
    {

        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
  40078e:	2009      	movs	r0, #9
        status =  _tx_queue_create(queue_ptr, name_ptr, message_size, queue_start, queue_size);
    }

    /* Return completion status.  */
    return(status);
}
  400790:	b002      	add	sp, #8
  400792:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  400796:	f3ef 8410 	mrs	r4, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  40079a:	b672      	cpsid	i
        _tx_thread_preempt_disable++;
  40079c:	4e2b      	ldr	r6, [pc, #172]	; (40084c <_txe_queue_create+0xcc>)
  40079e:	6835      	ldr	r5, [r6, #0]
  4007a0:	3501      	adds	r5, #1
  4007a2:	6035      	str	r5, [r6, #0]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  4007a4:	f384 8810 	msr	PRIMASK, r4
        next_queue =   _tx_queue_created_ptr;
  4007a8:	4c29      	ldr	r4, [pc, #164]	; (400850 <_txe_queue_create+0xd0>)
  4007aa:	6824      	ldr	r4, [r4, #0]
        for (i = ((ULONG) 0); i < _tx_queue_created_count; i++)
  4007ac:	4d29      	ldr	r5, [pc, #164]	; (400854 <_txe_queue_create+0xd4>)
  4007ae:	682e      	ldr	r6, [r5, #0]
            if (queue_ptr == next_queue)
  4007b0:	42a0      	cmp	r0, r4
  4007b2:	d007      	beq.n	4007c4 <_txe_queue_create+0x44>
  4007b4:	b136      	cbz	r6, 4007c4 <_txe_queue_create+0x44>
  4007b6:	2500      	movs	r5, #0
                next_queue =  next_queue -> tx_queue_created_next;
  4007b8:	6b24      	ldr	r4, [r4, #48]	; 0x30
        for (i = ((ULONG) 0); i < _tx_queue_created_count; i++)
  4007ba:	3501      	adds	r5, #1
            if (queue_ptr == next_queue)
  4007bc:	42a0      	cmp	r0, r4
  4007be:	d001      	beq.n	4007c4 <_txe_queue_create+0x44>
  4007c0:	42b5      	cmp	r5, r6
  4007c2:	d3f9      	bcc.n	4007b8 <_txe_queue_create+0x38>
  4007c4:	461e      	mov	r6, r3
  4007c6:	4617      	mov	r7, r2
  4007c8:	4688      	mov	r8, r1
  4007ca:	4605      	mov	r5, r0
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  4007cc:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  4007d0:	b672      	cpsid	i
        _tx_thread_preempt_disable--;
  4007d2:	491e      	ldr	r1, [pc, #120]	; (40084c <_txe_queue_create+0xcc>)
  4007d4:	680a      	ldr	r2, [r1, #0]
  4007d6:	3a01      	subs	r2, #1
  4007d8:	600a      	str	r2, [r1, #0]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  4007da:	f383 8810 	msr	PRIMASK, r3
        _tx_thread_system_preempt_check();
  4007de:	4b1e      	ldr	r3, [pc, #120]	; (400858 <_txe_queue_create+0xd8>)
  4007e0:	4798      	blx	r3
        if (queue_ptr == next_queue)
  4007e2:	42a5      	cmp	r5, r4
  4007e4:	d027      	beq.n	400836 <_txe_queue_create+0xb6>
        else if (queue_start == TX_NULL)
  4007e6:	b346      	cbz	r6, 40083a <_txe_queue_create+0xba>
        else if (message_size > TX_16_ULONG)
  4007e8:	1e7b      	subs	r3, r7, #1
  4007ea:	2b0f      	cmp	r3, #15
  4007ec:	d827      	bhi.n	40083e <_txe_queue_create+0xbe>
        else if ((queue_size/(sizeof(ULONG))) < message_size)
  4007ee:	9b08      	ldr	r3, [sp, #32]
  4007f0:	ebb7 0f93 	cmp.w	r7, r3, lsr #2
  4007f4:	d825      	bhi.n	400842 <_txe_queue_create+0xc2>
            TX_THREAD_GET_CURRENT(thread_ptr)
  4007f6:	4b19      	ldr	r3, [pc, #100]	; (40085c <_txe_queue_create+0xdc>)
            if (thread_ptr == &_tx_timer_thread)
  4007f8:	6818      	ldr	r0, [r3, #0]
                status =  TX_CALLER_ERROR;
  4007fa:	4b19      	ldr	r3, [pc, #100]	; (400860 <_txe_queue_create+0xe0>)
  4007fc:	4298      	cmp	r0, r3
  4007fe:	bf0c      	ite	eq
  400800:	2013      	moveq	r0, #19
  400802:	2000      	movne	r0, #0
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
  400804:	f3ef 8305 	mrs	r3, IPSR
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
  400808:	4a16      	ldr	r2, [pc, #88]	; (400864 <_txe_queue_create+0xe4>)
  40080a:	6812      	ldr	r2, [r2, #0]
  40080c:	4313      	orrs	r3, r2
  40080e:	d007      	beq.n	400820 <_txe_queue_create+0xa0>
  400810:	f3ef 8205 	mrs	r2, IPSR
                if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
  400814:	4b13      	ldr	r3, [pc, #76]	; (400864 <_txe_queue_create+0xe4>)
  400816:	681b      	ldr	r3, [r3, #0]
  400818:	4313      	orrs	r3, r2
  40081a:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
  40081e:	d312      	bcc.n	400846 <_txe_queue_create+0xc6>
    if (status == TX_SUCCESS)
  400820:	2800      	cmp	r0, #0
  400822:	d1b5      	bne.n	400790 <_txe_queue_create+0x10>
        status =  _tx_queue_create(queue_ptr, name_ptr, message_size, queue_start, queue_size);
  400824:	9b08      	ldr	r3, [sp, #32]
  400826:	9300      	str	r3, [sp, #0]
  400828:	4633      	mov	r3, r6
  40082a:	463a      	mov	r2, r7
  40082c:	4641      	mov	r1, r8
  40082e:	4628      	mov	r0, r5
  400830:	4c0d      	ldr	r4, [pc, #52]	; (400868 <_txe_queue_create+0xe8>)
  400832:	47a0      	blx	r4
    return(status);
  400834:	e7ac      	b.n	400790 <_txe_queue_create+0x10>
            status =  TX_QUEUE_ERROR;
  400836:	2009      	movs	r0, #9
  400838:	e7aa      	b.n	400790 <_txe_queue_create+0x10>
            status =  TX_PTR_ERROR;
  40083a:	2003      	movs	r0, #3
  40083c:	e7a8      	b.n	400790 <_txe_queue_create+0x10>
            status =  TX_SIZE_ERROR;
  40083e:	2005      	movs	r0, #5
  400840:	e7a6      	b.n	400790 <_txe_queue_create+0x10>
            status =  TX_SIZE_ERROR;
  400842:	2005      	movs	r0, #5
  400844:	e7a4      	b.n	400790 <_txe_queue_create+0x10>
                    status =  TX_CALLER_ERROR;
  400846:	2013      	movs	r0, #19
  400848:	e7a2      	b.n	400790 <_txe_queue_create+0x10>
  40084a:	bf00      	nop
  40084c:	2040058c 	.word	0x2040058c
  400850:	204004ec 	.word	0x204004ec
  400854:	204004cc 	.word	0x204004cc
  400858:	00402469 	.word	0x00402469
  40085c:	20400590 	.word	0x20400590
  400860:	20400634 	.word	0x20400634
  400864:	20400000 	.word	0x20400000
  400868:	00401c09 	.word	0x00401c09

0040086c <_txe_queue_receive>:

    /* Default status to success.  */
    status =  TX_SUCCESS;

    /* Check for an invalid queue pointer.  */
    if (queue_ptr == TX_NULL)
  40086c:	b1c0      	cbz	r0, 4008a0 <_txe_queue_receive+0x34>
{
  40086e:	b510      	push	{r4, lr}
  400870:	4603      	mov	r3, r0
        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
    }

    /* Now check for invalid queue ID.  */
    else if (queue_ptr -> tx_queue_id != TX_QUEUE_ID)
  400872:	6804      	ldr	r4, [r0, #0]
  400874:	480e      	ldr	r0, [pc, #56]	; (4008b0 <_txe_queue_receive+0x44>)
  400876:	4284      	cmp	r4, r0
  400878:	d001      	beq.n	40087e <_txe_queue_receive+0x12>
    {

        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
  40087a:	2009      	movs	r0, #9
  40087c:	bd10      	pop	{r4, pc}
    }

    /* Check for an invalid destination for message.  */
    else if (destination_ptr == TX_NULL)
  40087e:	b189      	cbz	r1, 4008a4 <_txe_queue_receive+0x38>
    else
    {

        /* Check for a wait option error.  Only threads are allowed any form of
           suspension.  */
        if (wait_option != TX_NO_WAIT)
  400880:	b152      	cbz	r2, 400898 <_txe_queue_receive+0x2c>
  400882:	f3ef 8005 	mrs	r0, IPSR
        {

            /* Is the call from an ISR or Initialization?  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
  400886:	4c0b      	ldr	r4, [pc, #44]	; (4008b4 <_txe_queue_receive+0x48>)
  400888:	6824      	ldr	r4, [r4, #0]
  40088a:	4320      	orrs	r0, r4
  40088c:	d10c      	bne.n	4008a8 <_txe_queue_receive+0x3c>
#ifndef TX_TIMER_PROCESS_IN_ISR
            else
            {

                /* Pickup thread pointer.  */
                TX_THREAD_GET_CURRENT(current_thread)
  40088e:	480a      	ldr	r0, [pc, #40]	; (4008b8 <_txe_queue_receive+0x4c>)

                /* Is the current thread the timer thread?  */
                if (current_thread == &_tx_timer_thread)
  400890:	6804      	ldr	r4, [r0, #0]
  400892:	480a      	ldr	r0, [pc, #40]	; (4008bc <_txe_queue_receive+0x50>)
  400894:	4284      	cmp	r4, r0
  400896:	d009      	beq.n	4008ac <_txe_queue_receive+0x40>
  400898:	4618      	mov	r0, r3
    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
    {

        /* Call actual queue receive function.  */
        status =  _tx_queue_receive(queue_ptr, destination_ptr, wait_option);
  40089a:	4b09      	ldr	r3, [pc, #36]	; (4008c0 <_txe_queue_receive+0x54>)
  40089c:	4798      	blx	r3
  40089e:	bd10      	pop	{r4, pc}
        status =  TX_QUEUE_ERROR;
  4008a0:	2009      	movs	r0, #9
  4008a2:	4770      	bx	lr
        status =  TX_PTR_ERROR;
  4008a4:	2003      	movs	r0, #3
  4008a6:	bd10      	pop	{r4, pc}
                status =  TX_WAIT_ERROR;
  4008a8:	2004      	movs	r0, #4
  4008aa:	bd10      	pop	{r4, pc}
                    status =  TX_WAIT_ERROR;
  4008ac:	2004      	movs	r0, #4
    }

    /* Return completion status.  */
    return(status);
}
  4008ae:	bd10      	pop	{r4, pc}
  4008b0:	51554555 	.word	0x51554555
  4008b4:	20400000 	.word	0x20400000
  4008b8:	20400590 	.word	0x20400590
  4008bc:	20400634 	.word	0x20400634
  4008c0:	00401c81 	.word	0x00401c81

004008c4 <_txe_queue_send>:

    /* Default status to success.  */
    status =  TX_SUCCESS;

    /* Check for an invalid queue pointer.  */
    if (queue_ptr == TX_NULL)
  4008c4:	b1c0      	cbz	r0, 4008f8 <_txe_queue_send+0x34>
{
  4008c6:	b510      	push	{r4, lr}
  4008c8:	4603      	mov	r3, r0
        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
    }

    /* Now check for invalid queue ID.  */
    else if (queue_ptr -> tx_queue_id != TX_QUEUE_ID)
  4008ca:	6804      	ldr	r4, [r0, #0]
  4008cc:	480e      	ldr	r0, [pc, #56]	; (400908 <_txe_queue_send+0x44>)
  4008ce:	4284      	cmp	r4, r0
  4008d0:	d001      	beq.n	4008d6 <_txe_queue_send+0x12>
    {

        /* Queue pointer is invalid, return appropriate error code.  */
        status =  TX_QUEUE_ERROR;
  4008d2:	2009      	movs	r0, #9
  4008d4:	bd10      	pop	{r4, pc}
    }

    /* Check for an invalid source for message.  */
    else if (source_ptr == TX_NULL)
  4008d6:	b189      	cbz	r1, 4008fc <_txe_queue_send+0x38>
    else
    {

        /* Check for a wait option error.  Only threads are allowed any form of
           suspension.  */
        if (wait_option != TX_NO_WAIT)
  4008d8:	b152      	cbz	r2, 4008f0 <_txe_queue_send+0x2c>
  4008da:	f3ef 8005 	mrs	r0, IPSR
        {

            /* Is the call from an ISR or Initialization?  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
  4008de:	4c0b      	ldr	r4, [pc, #44]	; (40090c <_txe_queue_send+0x48>)
  4008e0:	6824      	ldr	r4, [r4, #0]
  4008e2:	4320      	orrs	r0, r4
  4008e4:	d10c      	bne.n	400900 <_txe_queue_send+0x3c>
#ifndef TX_TIMER_PROCESS_IN_ISR
            else
            {

                /* Pickup thread pointer.  */
                TX_THREAD_GET_CURRENT(current_thread)
  4008e6:	480a      	ldr	r0, [pc, #40]	; (400910 <_txe_queue_send+0x4c>)

                /* Is the current thread the timer thread?  */
                if (current_thread == &_tx_timer_thread)
  4008e8:	6804      	ldr	r4, [r0, #0]
  4008ea:	480a      	ldr	r0, [pc, #40]	; (400914 <_txe_queue_send+0x50>)
  4008ec:	4284      	cmp	r4, r0
  4008ee:	d009      	beq.n	400904 <_txe_queue_send+0x40>
  4008f0:	4618      	mov	r0, r3
    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
    {

        /* Call actual queue send function.  */
        status =  _tx_queue_send(queue_ptr, source_ptr, wait_option);
  4008f2:	4b09      	ldr	r3, [pc, #36]	; (400918 <_txe_queue_send+0x54>)
  4008f4:	4798      	blx	r3
  4008f6:	bd10      	pop	{r4, pc}
        status =  TX_QUEUE_ERROR;
  4008f8:	2009      	movs	r0, #9
  4008fa:	4770      	bx	lr
        status =  TX_PTR_ERROR;
  4008fc:	2003      	movs	r0, #3
  4008fe:	bd10      	pop	{r4, pc}
                status =  TX_WAIT_ERROR;
  400900:	2004      	movs	r0, #4
  400902:	bd10      	pop	{r4, pc}
                    status =  TX_WAIT_ERROR;
  400904:	2004      	movs	r0, #4
    }

    /* Return completion status.  */
    return(status);
}
  400906:	bd10      	pop	{r4, pc}
  400908:	51554555 	.word	0x51554555
  40090c:	20400000 	.word	0x20400000
  400910:	20400590 	.word	0x20400590
  400914:	20400634 	.word	0x20400634
  400918:	00401e7d 	.word	0x00401e7d

0040091c <_txe_semaphore_create>:
        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
    }

    /* Now check for a valid semaphore ID.  */
    else if (semaphore_control_block_size != (sizeof(TX_SEMAPHORE)))
  40091c:	2b20      	cmp	r3, #32
  40091e:	d100      	bne.n	400922 <_txe_semaphore_create+0x6>
  400920:	b908      	cbnz	r0, 400926 <_txe_semaphore_create+0xa>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
  400922:	200c      	movs	r0, #12
  400924:	4770      	bx	lr
{
  400926:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  400928:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  40092c:	b672      	cpsid	i

        /* Disable interrupts.  */
        TX_DISABLE

        /* Increment the preempt disable flag.  */
        _tx_thread_preempt_disable++;
  40092e:	4d21      	ldr	r5, [pc, #132]	; (4009b4 <_txe_semaphore_create+0x98>)
  400930:	682c      	ldr	r4, [r5, #0]
  400932:	3401      	adds	r4, #1
  400934:	602c      	str	r4, [r5, #0]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  400936:	f383 8810 	msr	PRIMASK, r3

        /* Restore interrupts.  */
        TX_RESTORE

        /* Next see if it is already in the created list.  */
        next_semaphore =  _tx_semaphore_created_ptr;
  40093a:	4b1f      	ldr	r3, [pc, #124]	; (4009b8 <_txe_semaphore_create+0x9c>)
  40093c:	681c      	ldr	r4, [r3, #0]
        for (i = ((ULONG) 0); i < _tx_semaphore_created_count; i++)
  40093e:	4b1f      	ldr	r3, [pc, #124]	; (4009bc <_txe_semaphore_create+0xa0>)
  400940:	681d      	ldr	r5, [r3, #0]
        {

            /* Determine if this semaphore matches the current semaphore in the list.  */
            if (semaphore_ptr == next_semaphore)
  400942:	42a0      	cmp	r0, r4
  400944:	d007      	beq.n	400956 <_txe_semaphore_create+0x3a>
  400946:	b135      	cbz	r5, 400956 <_txe_semaphore_create+0x3a>
  400948:	2300      	movs	r3, #0
            }
            else
            {

                /* Move to next semaphore.  */
                next_semaphore =  next_semaphore -> tx_semaphore_created_next;
  40094a:	6964      	ldr	r4, [r4, #20]
        for (i = ((ULONG) 0); i < _tx_semaphore_created_count; i++)
  40094c:	3301      	adds	r3, #1
            if (semaphore_ptr == next_semaphore)
  40094e:	42a0      	cmp	r0, r4
  400950:	d001      	beq.n	400956 <_txe_semaphore_create+0x3a>
  400952:	42ab      	cmp	r3, r5
  400954:	d3f9      	bcc.n	40094a <_txe_semaphore_create+0x2e>
  400956:	4617      	mov	r7, r2
  400958:	460e      	mov	r6, r1
  40095a:	4605      	mov	r5, r0
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  40095c:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  400960:	b672      	cpsid	i

        /* Disable interrupts.  */
        TX_DISABLE

        /* Decrement the preempt disable flag.  */
        _tx_thread_preempt_disable--;
  400962:	4914      	ldr	r1, [pc, #80]	; (4009b4 <_txe_semaphore_create+0x98>)
  400964:	680a      	ldr	r2, [r1, #0]
  400966:	3a01      	subs	r2, #1
  400968:	600a      	str	r2, [r1, #0]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  40096a:	f383 8810 	msr	PRIMASK, r3

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
  40096e:	4b14      	ldr	r3, [pc, #80]	; (4009c0 <_txe_semaphore_create+0xa4>)
  400970:	4798      	blx	r3

        /* At this point, check to see if there is a duplicate semaphore.  */
        if (semaphore_ptr == next_semaphore)
  400972:	42a5      	cmp	r5, r4
  400974:	d01a      	beq.n	4009ac <_txe_semaphore_create+0x90>
#ifndef TX_TIMER_PROCESS_IN_ISR
        else
        {

            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(thread_ptr)
  400976:	4b13      	ldr	r3, [pc, #76]	; (4009c4 <_txe_semaphore_create+0xa8>)

            /* Check for invalid caller of this function.  First check for a calling thread.  */
            if (thread_ptr == &_tx_timer_thread)
  400978:	681a      	ldr	r2, [r3, #0]
  40097a:	4b13      	ldr	r3, [pc, #76]	; (4009c8 <_txe_semaphore_create+0xac>)
  40097c:	429a      	cmp	r2, r3
  40097e:	d017      	beq.n	4009b0 <_txe_semaphore_create+0x94>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
  400980:	f3ef 8305 	mrs	r3, IPSR
    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
    {

        /* Check for interrupt call.  */
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
  400984:	4a11      	ldr	r2, [pc, #68]	; (4009cc <_txe_semaphore_create+0xb0>)
  400986:	6812      	ldr	r2, [r2, #0]
  400988:	4313      	orrs	r3, r2
  40098a:	d105      	bne.n	400998 <_txe_semaphore_create+0x7c>
    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
    {

        /* Call actual semaphore create function.  */
        status =  _tx_semaphore_create(semaphore_ptr, name_ptr, initial_count);
  40098c:	463a      	mov	r2, r7
  40098e:	4631      	mov	r1, r6
  400990:	4628      	mov	r0, r5
  400992:	4b0f      	ldr	r3, [pc, #60]	; (4009d0 <_txe_semaphore_create+0xb4>)
  400994:	4798      	blx	r3
  400996:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  400998:	f3ef 8305 	mrs	r3, IPSR
            if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
  40099c:	4a0b      	ldr	r2, [pc, #44]	; (4009cc <_txe_semaphore_create+0xb0>)
  40099e:	6812      	ldr	r2, [r2, #0]
  4009a0:	4313      	orrs	r3, r2
  4009a2:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
  4009a6:	d2f1      	bcs.n	40098c <_txe_semaphore_create+0x70>
                status =  TX_CALLER_ERROR;
  4009a8:	2013      	movs	r0, #19
    }

    /* Return completion status.  */
    return(status);
  4009aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            status =  TX_SEMAPHORE_ERROR;
  4009ac:	200c      	movs	r0, #12
  4009ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                status =  TX_CALLER_ERROR;
  4009b0:	2013      	movs	r0, #19
}
  4009b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4009b4:	2040058c 	.word	0x2040058c
  4009b8:	204004d0 	.word	0x204004d0
  4009bc:	204004e0 	.word	0x204004e0
  4009c0:	00402469 	.word	0x00402469
  4009c4:	20400590 	.word	0x20400590
  4009c8:	20400634 	.word	0x20400634
  4009cc:	20400000 	.word	0x20400000
  4009d0:	00402065 	.word	0x00402065

004009d4 <_txe_semaphore_get>:

    /* Default status to success.  */
    status =  TX_SUCCESS;

    /* Check for an invalid semaphore pointer.  */
    if (semaphore_ptr == TX_NULL)
  4009d4:	b1b8      	cbz	r0, 400a06 <_txe_semaphore_get+0x32>
{
  4009d6:	b508      	push	{r3, lr}
  4009d8:	4603      	mov	r3, r0
        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
    }

    /* Now check for invalid semaphore ID.  */
    else if (semaphore_ptr -> tx_semaphore_id != TX_SEMAPHORE_ID)
  4009da:	6800      	ldr	r0, [r0, #0]
  4009dc:	4a0d      	ldr	r2, [pc, #52]	; (400a14 <_txe_semaphore_get+0x40>)
  4009de:	4290      	cmp	r0, r2
  4009e0:	d001      	beq.n	4009e6 <_txe_semaphore_get+0x12>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
  4009e2:	200c      	movs	r0, #12
  4009e4:	bd08      	pop	{r3, pc}
    else
    {

        /* Check for a wait option error.  Only threads are allowed any form of
           suspension.  */
        if (wait_option != TX_NO_WAIT)
  4009e6:	b151      	cbz	r1, 4009fe <_txe_semaphore_get+0x2a>
  4009e8:	f3ef 8205 	mrs	r2, IPSR
        {

            /* Is the call from an ISR or Initialization?  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
  4009ec:	480a      	ldr	r0, [pc, #40]	; (400a18 <_txe_semaphore_get+0x44>)
  4009ee:	6800      	ldr	r0, [r0, #0]
  4009f0:	4302      	orrs	r2, r0
  4009f2:	d10a      	bne.n	400a0a <_txe_semaphore_get+0x36>
#ifndef TX_TIMER_PROCESS_IN_ISR
            else
            {

                /* Pickup thread pointer.  */
                TX_THREAD_GET_CURRENT(current_thread)
  4009f4:	4a09      	ldr	r2, [pc, #36]	; (400a1c <_txe_semaphore_get+0x48>)

                /* Is the current thread the timer thread?  */
                if (current_thread == &_tx_timer_thread)
  4009f6:	6810      	ldr	r0, [r2, #0]
  4009f8:	4a09      	ldr	r2, [pc, #36]	; (400a20 <_txe_semaphore_get+0x4c>)
  4009fa:	4290      	cmp	r0, r2
  4009fc:	d007      	beq.n	400a0e <_txe_semaphore_get+0x3a>
  4009fe:	4618      	mov	r0, r3
    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
    {

        /* Call actual get semaphore function.  */
        status =  _tx_semaphore_get(semaphore_ptr, wait_option);
  400a00:	4b08      	ldr	r3, [pc, #32]	; (400a24 <_txe_semaphore_get+0x50>)
  400a02:	4798      	blx	r3
  400a04:	bd08      	pop	{r3, pc}
        status =  TX_SEMAPHORE_ERROR;
  400a06:	200c      	movs	r0, #12
  400a08:	4770      	bx	lr
                status =  TX_WAIT_ERROR;
  400a0a:	2004      	movs	r0, #4
  400a0c:	bd08      	pop	{r3, pc}
                    status =  TX_WAIT_ERROR;
  400a0e:	2004      	movs	r0, #4
    }

    /* Return completion status.  */
    return(status);
}
  400a10:	bd08      	pop	{r3, pc}
  400a12:	bf00      	nop
  400a14:	53454d41 	.word	0x53454d41
  400a18:	20400000 	.word	0x20400000
  400a1c:	20400590 	.word	0x20400590
  400a20:	20400634 	.word	0x20400634
  400a24:	004020c1 	.word	0x004020c1

00400a28 <_txe_semaphore_put>:

UINT        status;


    /* Check for an invalid semaphore pointer.  */
    if (semaphore_ptr == TX_NULL)
  400a28:	b148      	cbz	r0, 400a3e <_txe_semaphore_put+0x16>
{
  400a2a:	b508      	push	{r3, lr}
        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
    }

    /* Now check for invalid semaphore ID.  */
    else if (semaphore_ptr -> tx_semaphore_id != TX_SEMAPHORE_ID)
  400a2c:	6801      	ldr	r1, [r0, #0]
  400a2e:	4a05      	ldr	r2, [pc, #20]	; (400a44 <_txe_semaphore_put+0x1c>)
  400a30:	4291      	cmp	r1, r2
  400a32:	d001      	beq.n	400a38 <_txe_semaphore_put+0x10>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
  400a34:	200c      	movs	r0, #12
        status =  _tx_semaphore_put(semaphore_ptr);
    }

    /* Return completion status.  */
    return(status);
}
  400a36:	bd08      	pop	{r3, pc}
        status =  _tx_semaphore_put(semaphore_ptr);
  400a38:	4b03      	ldr	r3, [pc, #12]	; (400a48 <_txe_semaphore_put+0x20>)
  400a3a:	4798      	blx	r3
  400a3c:	bd08      	pop	{r3, pc}
        status =  TX_SEMAPHORE_ERROR;
  400a3e:	200c      	movs	r0, #12
  400a40:	4770      	bx	lr
  400a42:	bf00      	nop
  400a44:	53454d41 	.word	0x53454d41
  400a48:	00402155 	.word	0x00402155

00400a4c <_txe_thread_create>:
UINT    _txe_thread_create(TX_THREAD *thread_ptr, CHAR *name_ptr,
                VOID (*entry_function)(ULONG id), ULONG entry_input,
                VOID *stack_start, ULONG stack_size,
                UINT priority, UINT preempt_threshold,
                ULONG time_slice, UINT auto_start, UINT thread_control_block_size)
{
  400a4c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  400a50:	b087      	sub	sp, #28
  400a52:	9d10      	ldr	r5, [sp, #64]	; 0x40
        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
    }

    /* Now check for invalid thread control block size.  */
    else if (thread_control_block_size != (sizeof(TX_THREAD)))
  400a54:	9c16      	ldr	r4, [sp, #88]	; 0x58
  400a56:	2cb4      	cmp	r4, #180	; 0xb4
  400a58:	d100      	bne.n	400a5c <_txe_thread_create+0x10>
  400a5a:	b918      	cbnz	r0, 400a64 <_txe_thread_create+0x18>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
  400a5c:	200e      	movs	r0, #14
                        time_slice, auto_start);
    }

    /* Return completion status.  */
    return(status);
}
  400a5e:	b007      	add	sp, #28
  400a60:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  400a64:	f3ef 8410 	mrs	r4, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  400a68:	b672      	cpsid	i
        _tx_thread_preempt_disable++;
  400a6a:	4f46      	ldr	r7, [pc, #280]	; (400b84 <_txe_thread_create+0x138>)
  400a6c:	683e      	ldr	r6, [r7, #0]
  400a6e:	3601      	adds	r6, #1
  400a70:	603e      	str	r6, [r7, #0]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  400a72:	f384 8810 	msr	PRIMASK, r4
        next_thread =  _tx_thread_created_ptr;
  400a76:	4c44      	ldr	r4, [pc, #272]	; (400b88 <_txe_thread_create+0x13c>)
  400a78:	6824      	ldr	r4, [r4, #0]
        for (i = ((ULONG) 0); i < _tx_thread_created_count; i++)
  400a7a:	4e44      	ldr	r6, [pc, #272]	; (400b8c <_txe_thread_create+0x140>)
  400a7c:	f8d6 c000 	ldr.w	ip, [r6]
  400a80:	f1bc 0f00 	cmp.w	ip, #0
  400a84:	d025      	beq.n	400ad2 <_txe_thread_create+0x86>
        work_ptr =     TX_UCHAR_POINTER_ADD(work_ptr, (stack_size - ((ULONG) 1)));
  400a86:	9e11      	ldr	r6, [sp, #68]	; 0x44
  400a88:	f106 3eff 	add.w	lr, r6, #4294967295
  400a8c:	44ae      	add	lr, r5
  400a8e:	2600      	movs	r6, #0
  400a90:	46b0      	mov	r8, r6
                    break_flag =  TX_TRUE;
  400a92:	f04f 0a01 	mov.w	sl, #1
                    stack_start =  TX_NULL;
  400a96:	46b1      	mov	r9, r6
  400a98:	e004      	b.n	400aa4 <_txe_thread_create+0x58>
            next_thread =  next_thread -> tx_thread_created_next;
  400a9a:	f8d4 4088 	ldr.w	r4, [r4, #136]	; 0x88
        for (i = ((ULONG) 0); i < _tx_thread_created_count; i++)
  400a9e:	3601      	adds	r6, #1
  400aa0:	4566      	cmp	r6, ip
  400aa2:	d016      	beq.n	400ad2 <_txe_thread_create+0x86>
            if (thread_ptr == next_thread)
  400aa4:	42a0      	cmp	r0, r4
  400aa6:	d013      	beq.n	400ad0 <_txe_thread_create+0x84>
            if (break_flag == TX_TRUE)
  400aa8:	f1b8 0f00 	cmp.w	r8, #0
  400aac:	d111      	bne.n	400ad2 <_txe_thread_create+0x86>
            if (stack_start >= next_thread -> tx_thread_stack_start)
  400aae:	f8d4 b00c 	ldr.w	fp, [r4, #12]
  400ab2:	45ab      	cmp	fp, r5
  400ab4:	d804      	bhi.n	400ac0 <_txe_thread_create+0x74>
                if (stack_start < next_thread -> tx_thread_stack_end)
  400ab6:	6927      	ldr	r7, [r4, #16]
  400ab8:	42af      	cmp	r7, r5
  400aba:	d901      	bls.n	400ac0 <_txe_thread_create+0x74>
                    break_flag =  TX_TRUE;
  400abc:	46d0      	mov	r8, sl
                    stack_start =  TX_NULL;
  400abe:	464d      	mov	r5, r9
            if (stack_end >= next_thread -> tx_thread_stack_start)
  400ac0:	45de      	cmp	lr, fp
  400ac2:	d3ea      	bcc.n	400a9a <_txe_thread_create+0x4e>
                if (stack_end < next_thread -> tx_thread_stack_end)
  400ac4:	6927      	ldr	r7, [r4, #16]
  400ac6:	45be      	cmp	lr, r7
  400ac8:	d2e7      	bcs.n	400a9a <_txe_thread_create+0x4e>
                    break_flag =  TX_TRUE;
  400aca:	46d0      	mov	r8, sl
                    stack_start =  TX_NULL;
  400acc:	464d      	mov	r5, r9
  400ace:	e7e4      	b.n	400a9a <_txe_thread_create+0x4e>
  400ad0:	4604      	mov	r4, r0
  400ad2:	461e      	mov	r6, r3
  400ad4:	4617      	mov	r7, r2
  400ad6:	4688      	mov	r8, r1
  400ad8:	4681      	mov	r9, r0
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  400ada:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  400ade:	b672      	cpsid	i
        _tx_thread_preempt_disable--;
  400ae0:	4928      	ldr	r1, [pc, #160]	; (400b84 <_txe_thread_create+0x138>)
  400ae2:	680a      	ldr	r2, [r1, #0]
  400ae4:	3a01      	subs	r2, #1
  400ae6:	600a      	str	r2, [r1, #0]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  400ae8:	f383 8810 	msr	PRIMASK, r3
        _tx_thread_system_preempt_check();
  400aec:	4b28      	ldr	r3, [pc, #160]	; (400b90 <_txe_thread_create+0x144>)
  400aee:	4798      	blx	r3
        if (thread_ptr == next_thread)
  400af0:	45a1      	cmp	r9, r4
  400af2:	d03a      	beq.n	400b6a <_txe_thread_create+0x11e>
        else if (entry_function == TX_NULL)
  400af4:	2f00      	cmp	r7, #0
  400af6:	d03a      	beq.n	400b6e <_txe_thread_create+0x122>
  400af8:	2d00      	cmp	r5, #0
  400afa:	d038      	beq.n	400b6e <_txe_thread_create+0x122>
        else if (stack_size < ((ULONG) TX_MINIMUM_STACK))
  400afc:	9b11      	ldr	r3, [sp, #68]	; 0x44
  400afe:	2bc7      	cmp	r3, #199	; 0xc7
  400b00:	d937      	bls.n	400b72 <_txe_thread_create+0x126>
        else if (priority >= ((UINT) TX_MAX_PRIORITIES))
  400b02:	9b12      	ldr	r3, [sp, #72]	; 0x48
  400b04:	2b1f      	cmp	r3, #31
  400b06:	d836      	bhi.n	400b76 <_txe_thread_create+0x12a>
        else if (preempt_threshold > priority)
  400b08:	9a13      	ldr	r2, [sp, #76]	; 0x4c
  400b0a:	4293      	cmp	r3, r2
  400b0c:	d335      	bcc.n	400b7a <_txe_thread_create+0x12e>
        else if (auto_start > TX_AUTO_START)
  400b0e:	9b15      	ldr	r3, [sp, #84]	; 0x54
  400b10:	2b01      	cmp	r3, #1
  400b12:	d901      	bls.n	400b18 <_txe_thread_create+0xcc>
            status =  TX_START_ERROR;
  400b14:	2010      	movs	r0, #16
  400b16:	e7a2      	b.n	400a5e <_txe_thread_create+0x12>
            TX_THREAD_GET_CURRENT(current_thread)
  400b18:	4b1e      	ldr	r3, [pc, #120]	; (400b94 <_txe_thread_create+0x148>)
            if (current_thread == &_tx_timer_thread)
  400b1a:	6818      	ldr	r0, [r3, #0]
                status =  TX_CALLER_ERROR;
  400b1c:	4b1e      	ldr	r3, [pc, #120]	; (400b98 <_txe_thread_create+0x14c>)
  400b1e:	4298      	cmp	r0, r3
  400b20:	bf0c      	ite	eq
  400b22:	2013      	moveq	r0, #19
  400b24:	2000      	movne	r0, #0
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
  400b26:	f3ef 8305 	mrs	r3, IPSR
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
  400b2a:	4a1c      	ldr	r2, [pc, #112]	; (400b9c <_txe_thread_create+0x150>)
  400b2c:	6812      	ldr	r2, [r2, #0]
  400b2e:	4313      	orrs	r3, r2
  400b30:	d007      	beq.n	400b42 <_txe_thread_create+0xf6>
  400b32:	f3ef 8205 	mrs	r2, IPSR
                if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
  400b36:	4b19      	ldr	r3, [pc, #100]	; (400b9c <_txe_thread_create+0x150>)
  400b38:	681b      	ldr	r3, [r3, #0]
  400b3a:	4313      	orrs	r3, r2
  400b3c:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
  400b40:	d31d      	bcc.n	400b7e <_txe_thread_create+0x132>
    if (status == TX_SUCCESS)
  400b42:	2800      	cmp	r0, #0
  400b44:	d18b      	bne.n	400a5e <_txe_thread_create+0x12>
        status =  _tx_thread_create(thread_ptr, name_ptr, entry_function, entry_input,
  400b46:	9b15      	ldr	r3, [sp, #84]	; 0x54
  400b48:	9305      	str	r3, [sp, #20]
  400b4a:	9b14      	ldr	r3, [sp, #80]	; 0x50
  400b4c:	9304      	str	r3, [sp, #16]
  400b4e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  400b50:	9303      	str	r3, [sp, #12]
  400b52:	9b12      	ldr	r3, [sp, #72]	; 0x48
  400b54:	9302      	str	r3, [sp, #8]
  400b56:	9b11      	ldr	r3, [sp, #68]	; 0x44
  400b58:	9301      	str	r3, [sp, #4]
  400b5a:	9500      	str	r5, [sp, #0]
  400b5c:	4633      	mov	r3, r6
  400b5e:	463a      	mov	r2, r7
  400b60:	4641      	mov	r1, r8
  400b62:	4648      	mov	r0, r9
  400b64:	4c0e      	ldr	r4, [pc, #56]	; (400ba0 <_txe_thread_create+0x154>)
  400b66:	47a0      	blx	r4
    return(status);
  400b68:	e779      	b.n	400a5e <_txe_thread_create+0x12>
            status =  TX_THREAD_ERROR;
  400b6a:	200e      	movs	r0, #14
  400b6c:	e777      	b.n	400a5e <_txe_thread_create+0x12>
            status =  TX_PTR_ERROR;
  400b6e:	2003      	movs	r0, #3
  400b70:	e775      	b.n	400a5e <_txe_thread_create+0x12>
            status =  TX_SIZE_ERROR;
  400b72:	2005      	movs	r0, #5
  400b74:	e773      	b.n	400a5e <_txe_thread_create+0x12>
            status =  TX_PRIORITY_ERROR;
  400b76:	200f      	movs	r0, #15
  400b78:	e771      	b.n	400a5e <_txe_thread_create+0x12>
            status =  TX_THRESH_ERROR;
  400b7a:	2018      	movs	r0, #24
  400b7c:	e76f      	b.n	400a5e <_txe_thread_create+0x12>
                    status =  TX_CALLER_ERROR;
  400b7e:	2013      	movs	r0, #19
  400b80:	e76d      	b.n	400a5e <_txe_thread_create+0x12>
  400b82:	bf00      	nop
  400b84:	2040058c 	.word	0x2040058c
  400b88:	2040057c 	.word	0x2040057c
  400b8c:	20400584 	.word	0x20400584
  400b90:	00402469 	.word	0x00402469
  400b94:	20400590 	.word	0x20400590
  400b98:	20400634 	.word	0x20400634
  400b9c:	20400000 	.word	0x20400000
  400ba0:	004021b9 	.word	0x004021b9

00400ba4 <_tx_block_allocate>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_block_allocate(TX_BLOCK_POOL *pool_ptr, VOID **block_ptr, ULONG wait_option)
{
  400ba4:	b538      	push	{r3, r4, r5, lr}
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  400ba6:	f3ef 8410 	mrs	r4, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  400baa:	b672      	cpsid	i
    lower_tbu =  *((ULONG *) (log_entry_ptr + TX_EL_EVENT_TIME_LOWER_OFFSET));
    upper_tbu =  *((ULONG *) (log_entry_ptr + TX_EL_EVENT_TIME_UPPER_OFFSET));
#endif

    /* Determine if there is an available block.  */
    if (pool_ptr -> tx_block_pool_available != ((UINT) 0))
  400bac:	6883      	ldr	r3, [r0, #8]
  400bae:	b933      	cbnz	r3, 400bbe <_tx_block_allocate+0x1a>
    else
    {

        /* Default the return pointer to NULL.  */
        return_ptr =   TX_INDIRECT_VOID_TO_UCHAR_POINTER_CONVERT(block_ptr);
        *return_ptr =  TX_NULL;
  400bb0:	2300      	movs	r3, #0
  400bb2:	600b      	str	r3, [r1, #0]

        /* Determine if the request specifies suspension.  */
        if (wait_option != TX_NO_WAIT)
  400bb4:	b97a      	cbnz	r2, 400bd6 <_tx_block_allocate+0x32>
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  400bb6:	f384 8810 	msr	PRIMASK, r4
        }
        else
        {

            /* Immediate return, return error completion.  */
            status =  TX_NO_MEMORY;
  400bba:	2010      	movs	r0, #16
        }
    }

    /* Return completion status.  */
    return(status);
}
  400bbc:	bd38      	pop	{r3, r4, r5, pc}
        pool_ptr -> tx_block_pool_available--;
  400bbe:	3b01      	subs	r3, #1
  400bc0:	6083      	str	r3, [r0, #8]
        work_ptr =  pool_ptr -> tx_block_pool_available_list;
  400bc2:	6903      	ldr	r3, [r0, #16]
        temp_ptr =  TX_UCHAR_POINTER_ADD(work_ptr, (sizeof(UCHAR *)));
  400bc4:	1d1a      	adds	r2, r3, #4
        *return_ptr =  temp_ptr;
  400bc6:	600a      	str	r2, [r1, #0]
        pool_ptr -> tx_block_pool_available_list =  *next_block_ptr;
  400bc8:	681a      	ldr	r2, [r3, #0]
  400bca:	6102      	str	r2, [r0, #16]
        *next_block_ptr =  temp_ptr;
  400bcc:	6018      	str	r0, [r3, #0]
  400bce:	f384 8810 	msr	PRIMASK, r4
        status =  TX_SUCCESS;
  400bd2:	2000      	movs	r0, #0
  400bd4:	bd38      	pop	{r3, r4, r5, pc}
            if (_tx_thread_preempt_disable != ((UINT) 0))
  400bd6:	4b18      	ldr	r3, [pc, #96]	; (400c38 <_tx_block_allocate+0x94>)
  400bd8:	681b      	ldr	r3, [r3, #0]
  400bda:	b11b      	cbz	r3, 400be4 <_tx_block_allocate+0x40>
  400bdc:	f384 8810 	msr	PRIMASK, r4
                status =  TX_NO_MEMORY;
  400be0:	2010      	movs	r0, #16
  400be2:	bd38      	pop	{r3, r4, r5, pc}
                TX_THREAD_GET_CURRENT(thread_ptr)
  400be4:	4b15      	ldr	r3, [pc, #84]	; (400c3c <_tx_block_allocate+0x98>)
  400be6:	681d      	ldr	r5, [r3, #0]
                thread_ptr -> tx_thread_suspend_cleanup =  &(_tx_block_pool_cleanup);
  400be8:	4b15      	ldr	r3, [pc, #84]	; (400c40 <_tx_block_allocate+0x9c>)
  400bea:	66ab      	str	r3, [r5, #104]	; 0x68
                thread_ptr -> tx_thread_suspend_control_block =  (VOID *) pool_ptr;
  400bec:	66e8      	str	r0, [r5, #108]	; 0x6c
                thread_ptr -> tx_thread_additional_suspend_info =  (VOID *) block_ptr;
  400bee:	67e9      	str	r1, [r5, #124]	; 0x7c
                thread_ptr -> tx_thread_suspension_sequence++;
  400bf0:	f8d5 30b0 	ldr.w	r3, [r5, #176]	; 0xb0
  400bf4:	3301      	adds	r3, #1
  400bf6:	f8c5 30b0 	str.w	r3, [r5, #176]	; 0xb0
                suspended_count =  (pool_ptr -> tx_block_pool_suspended_count);
  400bfa:	6a43      	ldr	r3, [r0, #36]	; 0x24
                (pool_ptr -> tx_block_pool_suspended_count)++;
  400bfc:	1c59      	adds	r1, r3, #1
  400bfe:	6241      	str	r1, [r0, #36]	; 0x24
                if (suspended_count == TX_NO_SUSPENSIONS)
  400c00:	b99b      	cbnz	r3, 400c2a <_tx_block_allocate+0x86>
                    pool_ptr -> tx_block_pool_suspension_list =     thread_ptr;
  400c02:	6205      	str	r5, [r0, #32]
                    thread_ptr -> tx_thread_suspended_next =        thread_ptr;
  400c04:	672d      	str	r5, [r5, #112]	; 0x70
                    thread_ptr -> tx_thread_suspended_previous =    thread_ptr;
  400c06:	676d      	str	r5, [r5, #116]	; 0x74
                thread_ptr -> tx_thread_state =       TX_BLOCK_MEMORY;
  400c08:	2308      	movs	r3, #8
  400c0a:	632b      	str	r3, [r5, #48]	; 0x30
                thread_ptr -> tx_thread_suspending =  TX_TRUE;
  400c0c:	2301      	movs	r3, #1
  400c0e:	63ab      	str	r3, [r5, #56]	; 0x38
                thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
  400c10:	64ea      	str	r2, [r5, #76]	; 0x4c
                _tx_thread_preempt_disable++;
  400c12:	4a09      	ldr	r2, [pc, #36]	; (400c38 <_tx_block_allocate+0x94>)
  400c14:	6813      	ldr	r3, [r2, #0]
  400c16:	3301      	adds	r3, #1
  400c18:	6013      	str	r3, [r2, #0]
  400c1a:	f384 8810 	msr	PRIMASK, r4
                _tx_thread_system_suspend(thread_ptr);
  400c1e:	4628      	mov	r0, r5
  400c20:	4b08      	ldr	r3, [pc, #32]	; (400c44 <_tx_block_allocate+0xa0>)
  400c22:	4798      	blx	r3
                status =  thread_ptr -> tx_thread_suspend_status;
  400c24:	f8d5 0084 	ldr.w	r0, [r5, #132]	; 0x84
  400c28:	bd38      	pop	{r3, r4, r5, pc}
                    next_thread =                                   pool_ptr -> tx_block_pool_suspension_list;
  400c2a:	6a03      	ldr	r3, [r0, #32]
                    thread_ptr -> tx_thread_suspended_next =        next_thread;
  400c2c:	672b      	str	r3, [r5, #112]	; 0x70
                    previous_thread =                               next_thread -> tx_thread_suspended_previous;
  400c2e:	6f59      	ldr	r1, [r3, #116]	; 0x74
                    thread_ptr -> tx_thread_suspended_previous =    previous_thread;
  400c30:	6769      	str	r1, [r5, #116]	; 0x74
                    previous_thread -> tx_thread_suspended_next =   thread_ptr;
  400c32:	670d      	str	r5, [r1, #112]	; 0x70
                    next_thread -> tx_thread_suspended_previous =   thread_ptr;
  400c34:	675d      	str	r5, [r3, #116]	; 0x74
  400c36:	e7e7      	b.n	400c08 <_tx_block_allocate+0x64>
  400c38:	2040058c 	.word	0x2040058c
  400c3c:	20400590 	.word	0x20400590
  400c40:	00400c49 	.word	0x00400c49
  400c44:	004025d9 	.word	0x004025d9

00400c48 <_tx_block_pool_cleanup>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_block_pool_cleanup(TX_THREAD *thread_ptr, ULONG suspension_sequence)
{
  400c48:	b510      	push	{r4, lr}
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  400c4a:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  400c4e:	b672      	cpsid	i

    /* Disable interrupts to remove the suspended thread from the block pool.  */
    TX_DISABLE

    /* Determine if the cleanup is still required.  */
    if (thread_ptr -> tx_thread_suspend_cleanup == &(_tx_block_pool_cleanup))
  400c50:	6e84      	ldr	r4, [r0, #104]	; 0x68
  400c52:	4a1b      	ldr	r2, [pc, #108]	; (400cc0 <_tx_block_pool_cleanup+0x78>)
  400c54:	4294      	cmp	r4, r2
  400c56:	d002      	beq.n	400c5e <_tx_block_pool_cleanup+0x16>
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  400c58:	f383 8810 	msr	PRIMASK, r3
  400c5c:	bd10      	pop	{r4, pc}
    {

        /* Check for valid suspension sequence.  */
        if (suspension_sequence == thread_ptr -> tx_thread_suspension_sequence)
  400c5e:	f8d0 20b0 	ldr.w	r2, [r0, #176]	; 0xb0
  400c62:	428a      	cmp	r2, r1
  400c64:	d1f8      	bne.n	400c58 <_tx_block_pool_cleanup+0x10>
        {

            /* Setup pointer to block pool control block.  */
            pool_ptr =  TX_VOID_TO_BLOCK_POOL_POINTER_CONVERT(thread_ptr -> tx_thread_suspend_control_block);
  400c66:	6ec2      	ldr	r2, [r0, #108]	; 0x6c

            /* Check for a NULL byte pool pointer.  */
            if (pool_ptr != TX_NULL)
  400c68:	2a00      	cmp	r2, #0
  400c6a:	d0f5      	beq.n	400c58 <_tx_block_pool_cleanup+0x10>
            {

                /* Check for valid pool ID.  */
                if (pool_ptr -> tx_block_pool_id == TX_BLOCK_POOL_ID)
  400c6c:	6814      	ldr	r4, [r2, #0]
  400c6e:	4915      	ldr	r1, [pc, #84]	; (400cc4 <_tx_block_pool_cleanup+0x7c>)
  400c70:	428c      	cmp	r4, r1
  400c72:	d1f1      	bne.n	400c58 <_tx_block_pool_cleanup+0x10>
                {

                    /* Determine if there are any thread suspensions.  */
                    if (pool_ptr -> tx_block_pool_suspended_count != TX_NO_SUSPENSIONS)
  400c74:	6a51      	ldr	r1, [r2, #36]	; 0x24
  400c76:	2900      	cmp	r1, #0
  400c78:	d0ee      	beq.n	400c58 <_tx_block_pool_cleanup+0x10>
#endif

                        /* Yes, we still have thread suspension!  */

                        /* Clear the suspension cleanup flag.  */
                        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
  400c7a:	2100      	movs	r1, #0
  400c7c:	6681      	str	r1, [r0, #104]	; 0x68

                        /* Decrement the suspended count.  */
                        pool_ptr -> tx_block_pool_suspended_count--;
  400c7e:	6a51      	ldr	r1, [r2, #36]	; 0x24
  400c80:	3901      	subs	r1, #1
  400c82:	6251      	str	r1, [r2, #36]	; 0x24
                        suspended_count =  pool_ptr -> tx_block_pool_suspended_count;

                        /* Remove the suspended thread from the list.  */

                        /* See if this is the only suspended thread on the list.  */
                        if (suspended_count == TX_NO_SUSPENSIONS)
  400c84:	b991      	cbnz	r1, 400cac <_tx_block_pool_cleanup+0x64>
                        {

                            /* Yes, the only suspended thread.  */

                            /* Update the head pointer.  */
                            pool_ptr -> tx_block_pool_suspension_list =  TX_NULL;
  400c86:	6211      	str	r1, [r2, #32]
                            }
                        }

                        /* Now we need to determine if this cleanup is from a terminate, timeout,
                           or from a wait abort.  */
                        if (thread_ptr -> tx_thread_state == TX_BLOCK_MEMORY)
  400c88:	6b02      	ldr	r2, [r0, #48]	; 0x30
  400c8a:	2a08      	cmp	r2, #8
  400c8c:	d1e4      	bne.n	400c58 <_tx_block_pool_cleanup+0x10>
                            /* Increment the number of timeouts on this block pool.  */
                            pool_ptr -> tx_block_pool_performance_timeout_count++;
#endif

                            /* Setup return status.  */
                            thread_ptr -> tx_thread_suspend_status =  TX_NO_MEMORY;
  400c8e:	2210      	movs	r2, #16
  400c90:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84

                            /* Resume the thread!  */
                            _tx_thread_system_ni_resume(thread_ptr);
#else
                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
  400c94:	490c      	ldr	r1, [pc, #48]	; (400cc8 <_tx_block_pool_cleanup+0x80>)
  400c96:	680a      	ldr	r2, [r1, #0]
  400c98:	3201      	adds	r2, #1
  400c9a:	600a      	str	r2, [r1, #0]
  400c9c:	f383 8810 	msr	PRIMASK, r3

                            /* Restore interrupts.  */
                            TX_RESTORE

                            /* Resume the thread!  */
                            _tx_thread_system_resume(thread_ptr);
  400ca0:	4b0a      	ldr	r3, [pc, #40]	; (400ccc <_tx_block_pool_cleanup+0x84>)
  400ca2:	4798      	blx	r3
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  400ca4:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  400ca8:	b672      	cpsid	i
  400caa:	e7d5      	b.n	400c58 <_tx_block_pool_cleanup+0x10>
                            next_thread =                                   thread_ptr -> tx_thread_suspended_next;
  400cac:	6f01      	ldr	r1, [r0, #112]	; 0x70
                            previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
  400cae:	6f44      	ldr	r4, [r0, #116]	; 0x74
                            next_thread -> tx_thread_suspended_previous =   previous_thread;
  400cb0:	674c      	str	r4, [r1, #116]	; 0x74
                            previous_thread -> tx_thread_suspended_next =   next_thread;
  400cb2:	6721      	str	r1, [r4, #112]	; 0x70
                            if (pool_ptr -> tx_block_pool_suspension_list == thread_ptr)
  400cb4:	6a14      	ldr	r4, [r2, #32]
  400cb6:	42a0      	cmp	r0, r4
                                pool_ptr -> tx_block_pool_suspension_list =     next_thread;
  400cb8:	bf08      	it	eq
  400cba:	6211      	streq	r1, [r2, #32]
  400cbc:	e7e4      	b.n	400c88 <_tx_block_pool_cleanup+0x40>
  400cbe:	bf00      	nop
  400cc0:	00400c49 	.word	0x00400c49
  400cc4:	424c4f43 	.word	0x424c4f43
  400cc8:	2040058c 	.word	0x2040058c
  400ccc:	004024a5 	.word	0x004024a5

00400cd0 <_tx_block_pool_create>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_block_pool_create(TX_BLOCK_POOL *pool_ptr, CHAR *name_ptr, ULONG block_size,
                    VOID *pool_start, ULONG pool_size)
{
  400cd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  400cd2:	4607      	mov	r7, r0
  400cd4:	460d      	mov	r5, r1
  400cd6:	4614      	mov	r4, r2
  400cd8:	461e      	mov	r6, r3
TX_BLOCK_POOL       *next_pool;
TX_BLOCK_POOL       *previous_pool;


    /* Initialize block pool control block to all zeros.  */
    TX_MEMSET(pool_ptr, 0, (sizeof(TX_BLOCK_POOL)));
  400cda:	2230      	movs	r2, #48	; 0x30
  400cdc:	2100      	movs	r1, #0
  400cde:	4b2a      	ldr	r3, [pc, #168]	; (400d88 <_tx_block_pool_create+0xb8>)
  400ce0:	4798      	blx	r3

    /* Round the block size up to something that is evenly divisible by
       an ALIGN_TYPE (typically this is a 32-bit ULONG). This helps guarantee proper alignment.  */
    block_size =  (((block_size + (sizeof(ALIGN_TYPE))) - ((ALIGN_TYPE) 1))/(sizeof(ALIGN_TYPE))) * (sizeof(ALIGN_TYPE));
  400ce2:	f104 0e03 	add.w	lr, r4, #3
  400ce6:	f02e 0e03 	bic.w	lr, lr, #3

    /* Round the pool size down to something that is evenly divisible by
       an ALIGN_TYPE (typically this is a 32-bit ULONG).  */
    pool_size =   (pool_size/(sizeof(ALIGN_TYPE))) * (sizeof(ALIGN_TYPE));
  400cea:	9a06      	ldr	r2, [sp, #24]
  400cec:	f022 0203 	bic.w	r2, r2, #3

    /* Setup the basic block pool fields.  */
    pool_ptr -> tx_block_pool_name =             name_ptr;
  400cf0:	607d      	str	r5, [r7, #4]
    pool_ptr -> tx_block_pool_start =            TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
  400cf2:	617e      	str	r6, [r7, #20]
    pool_ptr -> tx_block_pool_size =             pool_size;
  400cf4:	61ba      	str	r2, [r7, #24]
    pool_ptr -> tx_block_pool_block_size =       (UINT) block_size;
  400cf6:	f8c7 e01c 	str.w	lr, [r7, #28]

    /* Calculate the total number of blocks.  */
    total_blocks =  pool_size/(block_size + (sizeof(UCHAR *)));
  400cfa:	f10e 0404 	add.w	r4, lr, #4
  400cfe:	fbb2 f2f4 	udiv	r2, r2, r4

    /* Walk through the pool area, setting up the available block list.  */
    blocks =            ((UINT) 0);
    block_ptr =         TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
    next_block_ptr =    TX_UCHAR_POINTER_ADD(block_ptr, (block_size + (sizeof(UCHAR *))));
  400d02:	eb06 0c04 	add.w	ip, r6, r4
    while(blocks < (UINT) total_blocks)
  400d06:	2a00      	cmp	r2, #0
  400d08:	d038      	beq.n	400d7c <_tx_block_pool_create+0xac>
  400d0a:	4660      	mov	r0, ip
  400d0c:	2300      	movs	r3, #0
  400d0e:	461d      	mov	r5, r3
  400d10:	e000      	b.n	400d14 <_tx_block_pool_create+0x44>
    {

        /* Yes, we have another block.  Increment the block count.  */
        blocks++;
  400d12:	460d      	mov	r5, r1
  400d14:	1c69      	adds	r1, r5, #1

        /* Setup the link to the next block.  */
        block_link_ptr =  TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(block_ptr);
        *block_link_ptr =  next_block_ptr;
  400d16:	50f0      	str	r0, [r6, r3]

        /* Advance to the next block.  */
        block_ptr =   next_block_ptr;

        /* Update the next block pointer.  */
        next_block_ptr =  TX_UCHAR_POINTER_ADD(block_ptr, (block_size + (sizeof(UCHAR *))));
  400d18:	4420      	add	r0, r4
  400d1a:	4423      	add	r3, r4
    while(blocks < (UINT) total_blocks)
  400d1c:	428a      	cmp	r2, r1
  400d1e:	d1f8      	bne.n	400d12 <_tx_block_pool_create+0x42>
  400d20:	fb05 f404 	mul.w	r4, r5, r4
    }

    /* Save the remaining information in the pool control block.  */
    pool_ptr -> tx_block_pool_available =  blocks;
  400d24:	60b9      	str	r1, [r7, #8]
    pool_ptr -> tx_block_pool_total =      blocks;
  400d26:	60f9      	str	r1, [r7, #12]

    /* Quickly check to make sure at least one block is in the pool.  */
    if (blocks != ((UINT) 0))
  400d28:	b909      	cbnz	r1, 400d2e <_tx_block_pool_create+0x5e>
    }
    else
    {

        /* Not enough memory for one block, return appropriate error.  */
        status =  TX_SIZE_ERROR;
  400d2a:	2005      	movs	r0, #5
    }

    /* Return completion status.  */
    return(status);
  400d2c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        block_ptr =  TX_UCHAR_POINTER_SUB(block_ptr,(block_size + (sizeof(UCHAR *))));
  400d2e:	f1ce 2eff 	rsb	lr, lr, #4278255360	; 0xff00ff00
  400d32:	f50e 0e7f 	add.w	lr, lr, #16711680	; 0xff0000
  400d36:	f10e 0efc 	add.w	lr, lr, #252	; 0xfc
        *block_link_ptr =  TX_NULL;
  400d3a:	4464      	add	r4, ip
  400d3c:	2300      	movs	r3, #0
  400d3e:	f844 300e 	str.w	r3, [r4, lr]
        pool_ptr -> tx_block_pool_available_list =  TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
  400d42:	613e      	str	r6, [r7, #16]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  400d44:	f3ef 8110 	mrs	r1, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  400d48:	b672      	cpsid	i
        pool_ptr -> tx_block_pool_id =  TX_BLOCK_POOL_ID;
  400d4a:	4b10      	ldr	r3, [pc, #64]	; (400d8c <_tx_block_pool_create+0xbc>)
  400d4c:	603b      	str	r3, [r7, #0]
        if (_tx_block_pool_created_count == TX_EMPTY)
  400d4e:	4b10      	ldr	r3, [pc, #64]	; (400d90 <_tx_block_pool_create+0xc0>)
  400d50:	681b      	ldr	r3, [r3, #0]
  400d52:	b95b      	cbnz	r3, 400d6c <_tx_block_pool_create+0x9c>
            _tx_block_pool_created_ptr =                  pool_ptr;
  400d54:	4b0f      	ldr	r3, [pc, #60]	; (400d94 <_tx_block_pool_create+0xc4>)
  400d56:	601f      	str	r7, [r3, #0]
            pool_ptr -> tx_block_pool_created_next =      pool_ptr;
  400d58:	62bf      	str	r7, [r7, #40]	; 0x28
            pool_ptr -> tx_block_pool_created_previous =  pool_ptr;
  400d5a:	62ff      	str	r7, [r7, #44]	; 0x2c
        _tx_block_pool_created_count++;
  400d5c:	4a0c      	ldr	r2, [pc, #48]	; (400d90 <_tx_block_pool_create+0xc0>)
  400d5e:	6813      	ldr	r3, [r2, #0]
  400d60:	3301      	adds	r3, #1
  400d62:	6013      	str	r3, [r2, #0]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  400d64:	f381 8810 	msr	PRIMASK, r1
        status =  TX_SUCCESS;
  400d68:	2000      	movs	r0, #0
  400d6a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            next_pool =      _tx_block_pool_created_ptr;
  400d6c:	4b09      	ldr	r3, [pc, #36]	; (400d94 <_tx_block_pool_create+0xc4>)
  400d6e:	681b      	ldr	r3, [r3, #0]
            previous_pool =  next_pool -> tx_block_pool_created_previous;
  400d70:	6ada      	ldr	r2, [r3, #44]	; 0x2c
            next_pool -> tx_block_pool_created_previous =  pool_ptr;
  400d72:	62df      	str	r7, [r3, #44]	; 0x2c
            previous_pool -> tx_block_pool_created_next =  pool_ptr;
  400d74:	6297      	str	r7, [r2, #40]	; 0x28
            pool_ptr -> tx_block_pool_created_previous =  previous_pool;
  400d76:	62fa      	str	r2, [r7, #44]	; 0x2c
            pool_ptr -> tx_block_pool_created_next =      next_pool;
  400d78:	62bb      	str	r3, [r7, #40]	; 0x28
  400d7a:	e7ef      	b.n	400d5c <_tx_block_pool_create+0x8c>
    pool_ptr -> tx_block_pool_available =  blocks;
  400d7c:	2300      	movs	r3, #0
  400d7e:	60bb      	str	r3, [r7, #8]
    pool_ptr -> tx_block_pool_total =      blocks;
  400d80:	60fb      	str	r3, [r7, #12]
        status =  TX_SIZE_ERROR;
  400d82:	2005      	movs	r0, #5
}
  400d84:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  400d86:	bf00      	nop
  400d88:	00403361 	.word	0x00403361
  400d8c:	424c4f43 	.word	0x424c4f43
  400d90:	204004dc 	.word	0x204004dc
  400d94:	204004e8 	.word	0x204004e8

00400d98 <_tx_block_release>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_block_release(VOID *block_ptr)
{
  400d98:	b510      	push	{r4, lr}
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  400d9a:	f3ef 8410 	mrs	r4, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  400d9e:	b672      	cpsid	i
    /* Pickup the pool pointer which is just previous to the starting
       address of the block that the caller sees.  */
    work_ptr =        TX_VOID_TO_UCHAR_POINTER_CONVERT(block_ptr);
    work_ptr =        TX_UCHAR_POINTER_SUB(work_ptr, (sizeof(UCHAR *)));
    next_block_ptr =  TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(work_ptr);
    pool_ptr =        TX_UCHAR_TO_BLOCK_POOL_POINTER_CONVERT((*next_block_ptr));
  400da0:	f850 2c04 	ldr.w	r2, [r0, #-4]

    /* Log this kernel call.  */
    TX_EL_BLOCK_RELEASE_INSERT

    /* Determine if there are any threads suspended on the block pool.  */
    thread_ptr =  pool_ptr -> tx_block_pool_suspension_list;
  400da4:	6a13      	ldr	r3, [r2, #32]
    if (thread_ptr != TX_NULL)
  400da6:	b1db      	cbz	r3, 400de0 <_tx_block_release+0x48>
    {

        /* Remove the suspended thread from the list.  */

        /* Decrement the number of threads suspended.  */
        (pool_ptr -> tx_block_pool_suspended_count)--;
  400da8:	6a51      	ldr	r1, [r2, #36]	; 0x24
  400daa:	3901      	subs	r1, #1
  400dac:	6251      	str	r1, [r2, #36]	; 0x24

        /* Pickup the suspended count.  */
        suspended_count =  (pool_ptr -> tx_block_pool_suspended_count);

        /* See if this is the only suspended thread on the list.  */
        if (suspended_count == TX_NO_SUSPENSIONS)
  400dae:	b989      	cbnz	r1, 400dd4 <_tx_block_release+0x3c>
        {

            /* Yes, the only suspended thread.  */

            /* Update the head pointer.  */
            pool_ptr -> tx_block_pool_suspension_list =  TX_NULL;
  400db0:	6211      	str	r1, [r2, #32]
        }

        /* Prepare for resumption of the first thread.  */

        /* Clear cleanup routine to avoid timeout.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
  400db2:	2200      	movs	r2, #0
  400db4:	669a      	str	r2, [r3, #104]	; 0x68

        /* Return this block pointer to the suspended thread waiting for
           a block.  */
        return_block_ptr =  TX_VOID_TO_INDIRECT_UCHAR_POINTER_CONVERT(thread_ptr -> tx_thread_additional_suspend_info);
  400db6:	6fd9      	ldr	r1, [r3, #124]	; 0x7c
        work_ptr =          TX_VOID_TO_UCHAR_POINTER_CONVERT(block_ptr);
        *return_block_ptr =  work_ptr;
  400db8:	6008      	str	r0, [r1, #0]

        /* Put return status into the thread control block.  */
        thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
  400dba:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
        /* Restore interrupts.  */
        TX_RESTORE
#else

        /* Temporarily disable preemption.  */
        _tx_thread_preempt_disable++;
  400dbe:	490d      	ldr	r1, [pc, #52]	; (400df4 <_tx_block_release+0x5c>)
  400dc0:	680a      	ldr	r2, [r1, #0]
  400dc2:	3201      	adds	r2, #1
  400dc4:	600a      	str	r2, [r1, #0]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  400dc6:	f384 8810 	msr	PRIMASK, r4

        /* Restore interrupts.  */
        TX_RESTORE

        /* Resume thread.  */
        _tx_thread_system_resume(thread_ptr);
  400dca:	4618      	mov	r0, r3
  400dcc:	4b0a      	ldr	r3, [pc, #40]	; (400df8 <_tx_block_release+0x60>)
  400dce:	4798      	blx	r3
        TX_RESTORE
    }

    /* Return successful completion status.  */
    return(TX_SUCCESS);
}
  400dd0:	2000      	movs	r0, #0
  400dd2:	bd10      	pop	{r4, pc}
            next_thread =                                thread_ptr -> tx_thread_suspended_next;
  400dd4:	6f19      	ldr	r1, [r3, #112]	; 0x70
            pool_ptr -> tx_block_pool_suspension_list =  next_thread;
  400dd6:	6211      	str	r1, [r2, #32]
            previous_thread =                              thread_ptr -> tx_thread_suspended_previous;
  400dd8:	6f5a      	ldr	r2, [r3, #116]	; 0x74
            next_thread -> tx_thread_suspended_previous =  previous_thread;
  400dda:	674a      	str	r2, [r1, #116]	; 0x74
            previous_thread -> tx_thread_suspended_next =  next_thread;
  400ddc:	6711      	str	r1, [r2, #112]	; 0x70
  400dde:	e7e8      	b.n	400db2 <_tx_block_release+0x1a>
        *next_block_ptr =  pool_ptr -> tx_block_pool_available_list;
  400de0:	6913      	ldr	r3, [r2, #16]
  400de2:	f840 3d04 	str.w	r3, [r0, #-4]!
        pool_ptr -> tx_block_pool_available_list =  work_ptr;
  400de6:	6110      	str	r0, [r2, #16]
        pool_ptr -> tx_block_pool_available++;
  400de8:	6893      	ldr	r3, [r2, #8]
  400dea:	3301      	adds	r3, #1
  400dec:	6093      	str	r3, [r2, #8]
  400dee:	f384 8810 	msr	PRIMASK, r4
  400df2:	e7ed      	b.n	400dd0 <_tx_block_release+0x38>
  400df4:	2040058c 	.word	0x2040058c
  400df8:	004024a5 	.word	0x004024a5

00400dfc <_tx_byte_allocate>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_byte_allocate(TX_BYTE_POOL *pool_ptr, VOID **memory_ptr, ULONG memory_size,  ULONG wait_option)
{
  400dfc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  400e00:	4604      	mov	r4, r0
  400e02:	4688      	mov	r8, r1
  400e04:	4699      	mov	r9, r3
#endif


    /* Round the memory size up to the next size that is evenly divisible by
       an ALIGN_TYPE (this is typically a 32-bit ULONG).  This guarantees proper alignment.  */
    memory_size = (((memory_size + (sizeof(ALIGN_TYPE)))-((ALIGN_TYPE) 1))/(sizeof(ALIGN_TYPE))) * (sizeof(ALIGN_TYPE));
  400e06:	3203      	adds	r2, #3
  400e08:	f022 0503 	bic.w	r5, r2, #3
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  400e0c:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  400e10:	b672      	cpsid	i

    /* Disable interrupts.  */
    TX_DISABLE

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
  400e12:	4a2c      	ldr	r2, [pc, #176]	; (400ec4 <_tx_byte_allocate+0xc8>)
  400e14:	6816      	ldr	r6, [r2, #0]
        /* Restore interrupts.  */
        TX_RESTORE

        /* At this point, the executing thread owns the pool and can perform a search
           for free memory.  */
        work_ptr =  _tx_byte_pool_search(pool_ptr, memory_size);
  400e16:	4f2c      	ldr	r7, [pc, #176]	; (400ec8 <_tx_byte_allocate+0xcc>)
  400e18:	e002      	b.n	400e20 <_tx_byte_allocate+0x24>
        }
        else
        {

            /* No block was found, does this thread still own the pool?  */
            if (pool_ptr -> tx_byte_pool_owner == thread_ptr)
  400e1a:	6a22      	ldr	r2, [r4, #32]
  400e1c:	4296      	cmp	r6, r2
  400e1e:	d045      	beq.n	400eac <_tx_byte_allocate+0xb0>
        pool_ptr -> tx_byte_pool_owner =  thread_ptr;
  400e20:	6226      	str	r6, [r4, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  400e22:	f383 8810 	msr	PRIMASK, r3
        work_ptr =  _tx_byte_pool_search(pool_ptr, memory_size);
  400e26:	4629      	mov	r1, r5
  400e28:	4620      	mov	r0, r4
  400e2a:	47b8      	blx	r7
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  400e2c:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  400e30:	b672      	cpsid	i
        if (work_ptr != TX_NULL)
  400e32:	2800      	cmp	r0, #0
  400e34:	d0f1      	beq.n	400e1a <_tx_byte_allocate+0x1e>
        }

    } while (finished == TX_FALSE);

    /* Copy the pointer into the return destination.  */
    *memory_ptr =  (VOID *) work_ptr;
  400e36:	f8c8 0000 	str.w	r0, [r8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  400e3a:	f383 8810 	msr	PRIMASK, r3

        /* Restore interrupts.  */
        TX_RESTORE

        /* Set the status to success.  */
        status =  TX_SUCCESS;
  400e3e:	2000      	movs	r0, #0
  400e40:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        /* Determine if the request specifies suspension.  */
        if (wait_option != TX_NO_WAIT)
        {

            /* Determine if the preempt disable flag is non-zero.  */
            if (_tx_thread_preempt_disable != ((UINT) 0))
  400e44:	4a21      	ldr	r2, [pc, #132]	; (400ecc <_tx_byte_allocate+0xd0>)
  400e46:	6812      	ldr	r2, [r2, #0]
  400e48:	b122      	cbz	r2, 400e54 <_tx_byte_allocate+0x58>
  400e4a:	f383 8810 	msr	PRIMASK, r3
            {

                /* Suspension is not allowed if the preempt disable flag is non-zero at this point - return error completion.  */
                status =  TX_NO_MEMORY;
  400e4e:	2010      	movs	r0, #16
  400e50:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
                /* Increment the number of suspensions on this pool.  */
                pool_ptr -> tx_byte_pool_performance_suspension_count++;
#endif

                /* Setup cleanup routine pointer.  */
                thread_ptr -> tx_thread_suspend_cleanup =  &(_tx_byte_pool_cleanup);
  400e54:	4a1e      	ldr	r2, [pc, #120]	; (400ed0 <_tx_byte_allocate+0xd4>)
  400e56:	66b2      	str	r2, [r6, #104]	; 0x68

                /* Setup cleanup information, i.e. this pool control
                   block.  */
                thread_ptr -> tx_thread_suspend_control_block =  (VOID *) pool_ptr;
  400e58:	66f4      	str	r4, [r6, #108]	; 0x6c

                /* Save the return memory pointer address as well.  */
                thread_ptr -> tx_thread_additional_suspend_info =  (VOID *) memory_ptr;
  400e5a:	f8c6 807c 	str.w	r8, [r6, #124]	; 0x7c

                /* Save the byte size requested.  */
                thread_ptr -> tx_thread_suspend_info =  memory_size;
  400e5e:	67b5      	str	r5, [r6, #120]	; 0x78

#ifndef TX_NOT_INTERRUPTABLE

                /* Increment the suspension sequence number, which is used to identify
                   this suspension event.  */
                thread_ptr -> tx_thread_suspension_sequence++;
  400e60:	f8d6 20b0 	ldr.w	r2, [r6, #176]	; 0xb0
  400e64:	3201      	adds	r2, #1
  400e66:	f8c6 20b0 	str.w	r2, [r6, #176]	; 0xb0
#endif

                /* Pickup the number of suspended threads.  */
                suspended_count =  pool_ptr -> tx_byte_pool_suspended_count;
  400e6a:	6aa2      	ldr	r2, [r4, #40]	; 0x28

                /* Increment the suspension count.  */
                (pool_ptr -> tx_byte_pool_suspended_count)++;
  400e6c:	1c51      	adds	r1, r2, #1
  400e6e:	62a1      	str	r1, [r4, #40]	; 0x28

                /* Setup suspension list.  */
                if (suspended_count == TX_NO_SUSPENSIONS)
  400e70:	b9aa      	cbnz	r2, 400e9e <_tx_byte_allocate+0xa2>
                {

                    /* No other threads are suspended.  Setup the head pointer and
                       just setup this threads pointers to itself.  */
                    pool_ptr -> tx_byte_pool_suspension_list =      thread_ptr;
  400e72:	6266      	str	r6, [r4, #36]	; 0x24
                    thread_ptr -> tx_thread_suspended_next =        thread_ptr;
  400e74:	6736      	str	r6, [r6, #112]	; 0x70
                    thread_ptr -> tx_thread_suspended_previous =    thread_ptr;
  400e76:	6776      	str	r6, [r6, #116]	; 0x74
                    previous_thread -> tx_thread_suspended_next =   thread_ptr;
                    next_thread -> tx_thread_suspended_previous =   thread_ptr;
                }

                /* Set the state to suspended.  */
                thread_ptr -> tx_thread_state =       TX_BYTE_MEMORY;
  400e78:	2209      	movs	r2, #9
  400e7a:	6332      	str	r2, [r6, #48]	; 0x30
                /* Restore interrupts.  */
                TX_RESTORE
#else

                /* Set the suspending flag.  */
                thread_ptr -> tx_thread_suspending =  TX_TRUE;
  400e7c:	2201      	movs	r2, #1
  400e7e:	63b2      	str	r2, [r6, #56]	; 0x38

                /* Setup the timeout period.  */
                thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
  400e80:	f8c6 904c 	str.w	r9, [r6, #76]	; 0x4c

                /* Temporarily disable preemption.  */
                _tx_thread_preempt_disable++;
  400e84:	4911      	ldr	r1, [pc, #68]	; (400ecc <_tx_byte_allocate+0xd0>)
  400e86:	680a      	ldr	r2, [r1, #0]
  400e88:	3201      	adds	r2, #1
  400e8a:	600a      	str	r2, [r1, #0]
  400e8c:	f383 8810 	msr	PRIMASK, r3

                /* Restore interrupts.  */
                TX_RESTORE

                /* Call actual thread suspension routine.  */
                _tx_thread_system_suspend(thread_ptr);
  400e90:	4630      	mov	r0, r6
  400e92:	4b10      	ldr	r3, [pc, #64]	; (400ed4 <_tx_byte_allocate+0xd8>)
  400e94:	4798      	blx	r3
                    *((ULONG *) (log_entry_ptr + TX_EL_EVENT_INFO_4_OFFSET)) =  (ULONG) *memory_ptr;
                }
#endif

                /* Return the completion status.  */
                status =  thread_ptr -> tx_thread_suspend_status;
  400e96:	f8d6 0084 	ldr.w	r0, [r6, #132]	; 0x84
  400e9a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
                    next_thread =                                   pool_ptr -> tx_byte_pool_suspension_list;
  400e9e:	6a62      	ldr	r2, [r4, #36]	; 0x24
                    thread_ptr -> tx_thread_suspended_next =        next_thread;
  400ea0:	6732      	str	r2, [r6, #112]	; 0x70
                    previous_thread =                               next_thread -> tx_thread_suspended_previous;
  400ea2:	6f51      	ldr	r1, [r2, #116]	; 0x74
                    thread_ptr -> tx_thread_suspended_previous =    previous_thread;
  400ea4:	6771      	str	r1, [r6, #116]	; 0x74
                    previous_thread -> tx_thread_suspended_next =   thread_ptr;
  400ea6:	670e      	str	r6, [r1, #112]	; 0x70
                    next_thread -> tx_thread_suspended_previous =   thread_ptr;
  400ea8:	6756      	str	r6, [r2, #116]	; 0x74
  400eaa:	e7e5      	b.n	400e78 <_tx_byte_allocate+0x7c>
    *memory_ptr =  (VOID *) work_ptr;
  400eac:	2200      	movs	r2, #0
  400eae:	f8c8 2000 	str.w	r2, [r8]
        if (wait_option != TX_NO_WAIT)
  400eb2:	f1b9 0f00 	cmp.w	r9, #0
  400eb6:	d1c5      	bne.n	400e44 <_tx_byte_allocate+0x48>
  400eb8:	f383 8810 	msr	PRIMASK, r3

            /* Restore interrupts.  */
            TX_RESTORE

            /* Immediate return, return error completion.  */
            status =  TX_NO_MEMORY;
  400ebc:	2010      	movs	r0, #16
        }
    }

    /* Return completion status.  */
    return(status);
  400ebe:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  400ec2:	bf00      	nop
  400ec4:	20400590 	.word	0x20400590
  400ec8:	00400fed 	.word	0x00400fed
  400ecc:	2040058c 	.word	0x2040058c
  400ed0:	00400ed9 	.word	0x00400ed9
  400ed4:	004025d9 	.word	0x004025d9

00400ed8 <_tx_byte_pool_cleanup>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_byte_pool_cleanup(TX_THREAD *thread_ptr, ULONG suspension_sequence)
{
  400ed8:	b510      	push	{r4, lr}
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  400eda:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  400ede:	b672      	cpsid	i

    /* Disable interrupts to remove the suspended thread from the byte pool.  */
    TX_DISABLE

    /* Determine if the cleanup is still required.  */
    if (thread_ptr -> tx_thread_suspend_cleanup == &(_tx_byte_pool_cleanup))
  400ee0:	6e84      	ldr	r4, [r0, #104]	; 0x68
  400ee2:	4a1b      	ldr	r2, [pc, #108]	; (400f50 <_tx_byte_pool_cleanup+0x78>)
  400ee4:	4294      	cmp	r4, r2
  400ee6:	d002      	beq.n	400eee <_tx_byte_pool_cleanup+0x16>
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  400ee8:	f383 8810 	msr	PRIMASK, r3
  400eec:	bd10      	pop	{r4, pc}
    {

        /* Check for valid suspension sequence.  */
        if (suspension_sequence == thread_ptr -> tx_thread_suspension_sequence)
  400eee:	f8d0 20b0 	ldr.w	r2, [r0, #176]	; 0xb0
  400ef2:	428a      	cmp	r2, r1
  400ef4:	d1f8      	bne.n	400ee8 <_tx_byte_pool_cleanup+0x10>
        {

            /* Setup pointer to byte pool control block.  */
            pool_ptr =  TX_VOID_TO_BYTE_POOL_POINTER_CONVERT(thread_ptr -> tx_thread_suspend_control_block);
  400ef6:	6ec2      	ldr	r2, [r0, #108]	; 0x6c

            /* Check for a NULL byte pool pointer.  */
            if (pool_ptr != TX_NULL)
  400ef8:	2a00      	cmp	r2, #0
  400efa:	d0f5      	beq.n	400ee8 <_tx_byte_pool_cleanup+0x10>
            {

                /* Check for valid pool ID.  */
                if (pool_ptr -> tx_byte_pool_id == TX_BYTE_POOL_ID)
  400efc:	6814      	ldr	r4, [r2, #0]
  400efe:	4915      	ldr	r1, [pc, #84]	; (400f54 <_tx_byte_pool_cleanup+0x7c>)
  400f00:	428c      	cmp	r4, r1
  400f02:	d1f1      	bne.n	400ee8 <_tx_byte_pool_cleanup+0x10>
                {

                    /* Determine if there are any thread suspensions.  */
                    if (pool_ptr -> tx_byte_pool_suspended_count != TX_NO_SUSPENSIONS)
  400f04:	6a91      	ldr	r1, [r2, #40]	; 0x28
  400f06:	2900      	cmp	r1, #0
  400f08:	d0ee      	beq.n	400ee8 <_tx_byte_pool_cleanup+0x10>
                        /* Setup pointer to byte pool control block.  */
                        pool_ptr =  TX_VOID_TO_BYTE_POOL_POINTER_CONVERT(thread_ptr -> tx_thread_suspend_control_block);
#endif

                        /* Thread suspended for memory... Clear the suspension cleanup flag.  */
                        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
  400f0a:	2100      	movs	r1, #0
  400f0c:	6681      	str	r1, [r0, #104]	; 0x68

                        /* Decrement the suspension count.  */
                        pool_ptr -> tx_byte_pool_suspended_count--;
  400f0e:	6a91      	ldr	r1, [r2, #40]	; 0x28
  400f10:	3901      	subs	r1, #1
  400f12:	6291      	str	r1, [r2, #40]	; 0x28
                        suspended_count =  pool_ptr -> tx_byte_pool_suspended_count;

                        /* Remove the suspended thread from the list.  */

                        /* See if this is the only suspended thread on the list.  */
                        if (suspended_count == TX_NO_SUSPENSIONS)
  400f14:	b991      	cbnz	r1, 400f3c <_tx_byte_pool_cleanup+0x64>
                        {

                            /* Yes, the only suspended thread.  */

                            /* Update the head pointer.  */
                            pool_ptr -> tx_byte_pool_suspension_list =  TX_NULL;
  400f16:	6251      	str	r1, [r2, #36]	; 0x24
                            }
                        }

                        /* Now we need to determine if this cleanup is from a terminate, timeout,
                           or from a wait abort.  */
                        if (thread_ptr -> tx_thread_state == TX_BYTE_MEMORY)
  400f18:	6b02      	ldr	r2, [r0, #48]	; 0x30
  400f1a:	2a09      	cmp	r2, #9
  400f1c:	d1e4      	bne.n	400ee8 <_tx_byte_pool_cleanup+0x10>
                            /* Increment the number of timeouts on this byte pool.  */
                            pool_ptr -> tx_byte_pool_performance_timeout_count++;
#endif

                            /* Setup return status.  */
                            thread_ptr -> tx_thread_suspend_status =  TX_NO_MEMORY;
  400f1e:	2210      	movs	r2, #16
  400f20:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84
                            /* Resume the thread!  */
                            _tx_thread_system_ni_resume(thread_ptr);
#else

                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
  400f24:	490c      	ldr	r1, [pc, #48]	; (400f58 <_tx_byte_pool_cleanup+0x80>)
  400f26:	680a      	ldr	r2, [r1, #0]
  400f28:	3201      	adds	r2, #1
  400f2a:	600a      	str	r2, [r1, #0]
  400f2c:	f383 8810 	msr	PRIMASK, r3

                            /* Restore interrupts.  */
                            TX_RESTORE

                            /* Resume the thread!  */
                            _tx_thread_system_resume(thread_ptr);
  400f30:	4b0a      	ldr	r3, [pc, #40]	; (400f5c <_tx_byte_pool_cleanup+0x84>)
  400f32:	4798      	blx	r3
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  400f34:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  400f38:	b672      	cpsid	i
  400f3a:	e7d5      	b.n	400ee8 <_tx_byte_pool_cleanup+0x10>
                            next_thread =                                   thread_ptr -> tx_thread_suspended_next;
  400f3c:	6f01      	ldr	r1, [r0, #112]	; 0x70
                            previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
  400f3e:	6f44      	ldr	r4, [r0, #116]	; 0x74
                            next_thread -> tx_thread_suspended_previous =   previous_thread;
  400f40:	674c      	str	r4, [r1, #116]	; 0x74
                            previous_thread -> tx_thread_suspended_next =   next_thread;
  400f42:	6721      	str	r1, [r4, #112]	; 0x70
                            if (pool_ptr -> tx_byte_pool_suspension_list == thread_ptr)
  400f44:	6a54      	ldr	r4, [r2, #36]	; 0x24
  400f46:	42a0      	cmp	r0, r4
                                pool_ptr -> tx_byte_pool_suspension_list =      next_thread;
  400f48:	bf08      	it	eq
  400f4a:	6251      	streq	r1, [r2, #36]	; 0x24
  400f4c:	e7e4      	b.n	400f18 <_tx_byte_pool_cleanup+0x40>
  400f4e:	bf00      	nop
  400f50:	00400ed9 	.word	0x00400ed9
  400f54:	42595445 	.word	0x42595445
  400f58:	2040058c 	.word	0x2040058c
  400f5c:	004024a5 	.word	0x004024a5

00400f60 <_tx_byte_pool_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_byte_pool_create(TX_BYTE_POOL *pool_ptr, CHAR *name_ptr, VOID *pool_start, ULONG pool_size)
{
  400f60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  400f62:	4604      	mov	r4, r0
  400f64:	460f      	mov	r7, r1
  400f66:	4616      	mov	r6, r2
  400f68:	461d      	mov	r5, r3
TX_BYTE_POOL        *previous_pool;
ALIGN_TYPE          *free_ptr;


    /* Initialize the byte pool control block to all zeros.  */
    TX_MEMSET(pool_ptr, 0, (sizeof(TX_BYTE_POOL)));
  400f6a:	2234      	movs	r2, #52	; 0x34
  400f6c:	2100      	movs	r1, #0
  400f6e:	4b1a      	ldr	r3, [pc, #104]	; (400fd8 <_tx_byte_pool_create+0x78>)
  400f70:	4798      	blx	r3

    /* Round the pool size down to something that is evenly divisible by
       an ULONG.  */
    pool_size =   (pool_size/(sizeof(ALIGN_TYPE))) * (sizeof(ALIGN_TYPE));
  400f72:	f025 0303 	bic.w	r3, r5, #3

    /* Setup the basic byte pool fields.  */
    pool_ptr -> tx_byte_pool_name =              name_ptr;
  400f76:	6067      	str	r7, [r4, #4]

    /* Save the start and size of the pool.  */
    pool_ptr -> tx_byte_pool_start =   TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
  400f78:	61a6      	str	r6, [r4, #24]
    pool_ptr -> tx_byte_pool_size =    pool_size;
  400f7a:	61e3      	str	r3, [r4, #28]

    /* Setup memory list to the beginning as well as the search pointer.  */
    pool_ptr -> tx_byte_pool_list =    TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
  400f7c:	6126      	str	r6, [r4, #16]
    pool_ptr -> tx_byte_pool_search =  TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
  400f7e:	6166      	str	r6, [r4, #20]

    /* Initially, the pool will have two blocks.  One large block at the
       beginning that is available and a small allocated block at the end
       of the pool that is there just for the algorithm.  Be sure to count
       the available block's header in the available bytes count.  */
    pool_ptr -> tx_byte_pool_available =   pool_size - ((sizeof(VOID *)) + (sizeof(ALIGN_TYPE)));
  400f80:	f1a3 0208 	sub.w	r2, r3, #8
  400f84:	60a2      	str	r2, [r4, #8]
    pool_ptr -> tx_byte_pool_fragments =   ((UINT) 2);
  400f86:	2202      	movs	r2, #2
  400f88:	60e2      	str	r2, [r4, #12]
       field that contains either the constant TX_BYTE_BLOCK_FREE (if the block is free) or a pointer to the
       owning pool (if the block is allocated).  */

    /* Calculate the end of the pool's memory area.  */
    block_ptr =  TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
    block_ptr =  TX_UCHAR_POINTER_ADD(block_ptr, pool_size);
  400f8a:	4433      	add	r3, r6
    block_ptr =  TX_UCHAR_POINTER_SUB(block_ptr, (sizeof(ALIGN_TYPE)));

    /* Cast the pool pointer into a ULONG.  */
    temp_ptr =             TX_BYTE_POOL_TO_UCHAR_POINTER_CONVERT(pool_ptr);
    block_indirect_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(block_ptr);
    *block_indirect_ptr =  temp_ptr;
  400f8c:	f843 4c04 	str.w	r4, [r3, #-4]

    block_ptr =            TX_UCHAR_POINTER_SUB(block_ptr, (sizeof(UCHAR *)));
    block_indirect_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(block_ptr);
    *block_indirect_ptr =  TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
  400f90:	f843 6d08 	str.w	r6, [r3, #-8]!

    /* Now setup the large available block in the pool.  */
    temp_ptr =             TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
    block_indirect_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(temp_ptr);
    *block_indirect_ptr =  block_ptr;
  400f94:	6033      	str	r3, [r6, #0]
    block_ptr =            TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
    block_ptr =            TX_UCHAR_POINTER_ADD(block_ptr, (sizeof(UCHAR *)));
    free_ptr =             TX_UCHAR_TO_ALIGN_TYPE_POINTER_CONVERT(block_ptr);
    *free_ptr =            TX_BYTE_BLOCK_FREE;
  400f96:	4b11      	ldr	r3, [pc, #68]	; (400fdc <_tx_byte_pool_create+0x7c>)
  400f98:	6073      	str	r3, [r6, #4]

    /* Clear the owner id.  */
    pool_ptr -> tx_byte_pool_owner =  TX_NULL;
  400f9a:	2300      	movs	r3, #0
  400f9c:	6223      	str	r3, [r4, #32]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  400f9e:	f3ef 8110 	mrs	r1, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  400fa2:	b672      	cpsid	i

    /* Disable interrupts to place the byte pool on the created list.  */
    TX_DISABLE

    /* Setup the byte pool ID to make it valid.  */
    pool_ptr -> tx_byte_pool_id =  TX_BYTE_POOL_ID;
  400fa4:	4b0e      	ldr	r3, [pc, #56]	; (400fe0 <_tx_byte_pool_create+0x80>)
  400fa6:	6023      	str	r3, [r4, #0]

    /* Place the byte pool on the list of created byte pools.  First,
       check for an empty list.  */
    if (_tx_byte_pool_created_count == TX_EMPTY)
  400fa8:	4b0e      	ldr	r3, [pc, #56]	; (400fe4 <_tx_byte_pool_create+0x84>)
  400faa:	681b      	ldr	r3, [r3, #0]
  400fac:	b173      	cbz	r3, 400fcc <_tx_byte_pool_create+0x6c>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_pool =      _tx_byte_pool_created_ptr;
  400fae:	4b0e      	ldr	r3, [pc, #56]	; (400fe8 <_tx_byte_pool_create+0x88>)
  400fb0:	681b      	ldr	r3, [r3, #0]
        previous_pool =  next_pool -> tx_byte_pool_created_previous;
  400fb2:	6b1a      	ldr	r2, [r3, #48]	; 0x30

        /* Place the new byte pool in the list.  */
        next_pool -> tx_byte_pool_created_previous =  pool_ptr;
  400fb4:	631c      	str	r4, [r3, #48]	; 0x30
        previous_pool -> tx_byte_pool_created_next =  pool_ptr;
  400fb6:	62d4      	str	r4, [r2, #44]	; 0x2c

        /* Setup this byte pool's created links.  */
        pool_ptr -> tx_byte_pool_created_previous =  previous_pool;
  400fb8:	6322      	str	r2, [r4, #48]	; 0x30
        pool_ptr -> tx_byte_pool_created_next =      next_pool;
  400fba:	62e3      	str	r3, [r4, #44]	; 0x2c
    }

    /* Increment the number of created byte pools.  */
    _tx_byte_pool_created_count++;
  400fbc:	4a09      	ldr	r2, [pc, #36]	; (400fe4 <_tx_byte_pool_create+0x84>)
  400fbe:	6813      	ldr	r3, [r2, #0]
  400fc0:	3301      	adds	r3, #1
  400fc2:	6013      	str	r3, [r2, #0]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  400fc4:	f381 8810 	msr	PRIMASK, r1
    /* Restore interrupts.  */
    TX_RESTORE

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
}
  400fc8:	2000      	movs	r0, #0
  400fca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        _tx_byte_pool_created_ptr =                  pool_ptr;
  400fcc:	4b06      	ldr	r3, [pc, #24]	; (400fe8 <_tx_byte_pool_create+0x88>)
  400fce:	601c      	str	r4, [r3, #0]
        pool_ptr -> tx_byte_pool_created_next =      pool_ptr;
  400fd0:	62e4      	str	r4, [r4, #44]	; 0x2c
        pool_ptr -> tx_byte_pool_created_previous =  pool_ptr;
  400fd2:	6324      	str	r4, [r4, #48]	; 0x30
  400fd4:	e7f2      	b.n	400fbc <_tx_byte_pool_create+0x5c>
  400fd6:	bf00      	nop
  400fd8:	00403361 	.word	0x00403361
  400fdc:	ffffeeee 	.word	0xffffeeee
  400fe0:	42595445 	.word	0x42595445
  400fe4:	204004f0 	.word	0x204004f0
  400fe8:	204004d4 	.word	0x204004d4

00400fec <_tx_byte_pool_search>:
/*                                            calculation,                */
/*                                            resulting in version 6.1.7  */
/*                                                                        */
/**************************************************************************/
UCHAR  *_tx_byte_pool_search(TX_BYTE_POOL *pool_ptr, ULONG memory_size)
{
  400fec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  400ff0:	f3ef 8410 	mrs	r4, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  400ff4:	b672      	cpsid	i
    /* Disable interrupts.  */
    TX_DISABLE

    /* First, determine if there are enough bytes in the pool.  */
    /* Theoretical bytes available = free bytes + ((fragments-2) * overhead of each block) */
    total_theoretical_available = pool_ptr -> tx_byte_pool_available + ((pool_ptr -> tx_byte_pool_fragments - 2) * ((sizeof(UCHAR *)) + (sizeof(ALIGN_TYPE))));
  400ff6:	68c3      	ldr	r3, [r0, #12]
  400ff8:	4d3a      	ldr	r5, [pc, #232]	; (4010e4 <_tx_byte_pool_search+0xf8>)
  400ffa:	441d      	add	r5, r3
  400ffc:	6882      	ldr	r2, [r0, #8]
  400ffe:	eb02 02c5 	add.w	r2, r2, r5, lsl #3
    if (memory_size >= total_theoretical_available)
  401002:	428a      	cmp	r2, r1
  401004:	d90a      	bls.n	40101c <_tx_byte_pool_search+0x30>
  401006:	4688      	mov	r8, r1
    }
    else
    {

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(thread_ptr)
  401008:	4a37      	ldr	r2, [pc, #220]	; (4010e8 <_tx_byte_pool_search+0xfc>)
  40100a:	6816      	ldr	r6, [r2, #0]

        /* Setup ownership of the byte pool.  */
        pool_ptr -> tx_byte_pool_owner =  thread_ptr;
  40100c:	6206      	str	r6, [r0, #32]

        /* Walk through the memory pool in search for a large enough block.  */
        current_ptr =      pool_ptr -> tx_byte_pool_search;
  40100e:	6942      	ldr	r2, [r0, #20]
        examine_blocks =   pool_ptr -> tx_byte_pool_fragments + ((UINT) 1);
  401010:	3301      	adds	r3, #1
UINT            first_free_block_found =  TX_FALSE;
  401012:	2500      	movs	r5, #0
#endif

            /* Check to see if this block is free.  */
            work_ptr =  TX_UCHAR_POINTER_ADD(current_ptr, (sizeof(UCHAR *)));
            free_ptr =  TX_UCHAR_TO_ALIGN_TYPE_POINTER_CONVERT(work_ptr);
            if ((*free_ptr) == TX_BYTE_BLOCK_FREE)
  401014:	4f35      	ldr	r7, [pc, #212]	; (4010ec <_tx_byte_pool_search+0x100>)
  401016:	f04f 0e01 	mov.w	lr, #1
  40101a:	e033      	b.n	401084 <_tx_byte_pool_search+0x98>
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  40101c:	f384 8810 	msr	PRIMASK, r4
        current_ptr =  TX_NULL;
  401020:	2000      	movs	r0, #0
  401022:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            {

                /* Determine if this is the first free block.  */
                if (first_free_block_found == TX_FALSE)
  401026:	b905      	cbnz	r5, 40102a <_tx_byte_pool_search+0x3e>
                {
                    /* This is the first free block.  */
                    pool_ptr->tx_byte_pool_search =  current_ptr;
  401028:	6142      	str	r2, [r0, #20]

                /* Block is free, see if it is large enough.  */

                /* Pickup the next block's pointer.  */
                this_block_link_ptr =  TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(current_ptr);
                next_ptr =             *this_block_link_ptr;
  40102a:	f8d2 c000 	ldr.w	ip, [r2]

                /* Calculate the number of bytes available in this block.  */
                available_bytes =   TX_UCHAR_POINTER_DIF(next_ptr, current_ptr);
  40102e:	ebac 0502 	sub.w	r5, ip, r2
                available_bytes =   available_bytes - ((sizeof(UCHAR *)) + (sizeof(ALIGN_TYPE)));
  401032:	3d08      	subs	r5, #8

                /* If this is large enough, we are done because our first-fit algorithm
                   has been satisfied!  */
                if (available_bytes >= memory_size)
  401034:	45a8      	cmp	r8, r5
  401036:	d92d      	bls.n	401094 <_tx_byte_pool_search+0xa8>

                    /* Not enough memory, check to see if the neighbor is
                       free and can be merged.  */
                    work_ptr =  TX_UCHAR_POINTER_ADD(next_ptr, (sizeof(UCHAR *)));
                    free_ptr =  TX_UCHAR_TO_ALIGN_TYPE_POINTER_CONVERT(work_ptr);
                    if ((*free_ptr) == TX_BYTE_BLOCK_FREE)
  401038:	f8dc 5004 	ldr.w	r5, [ip, #4]
  40103c:	42bd      	cmp	r5, r7
  40103e:	d005      	beq.n	40104c <_tx_byte_pool_search+0x60>
                    }
                    else
                    {
                        /* Neighbor is not free so we can skip over it!  */
                        next_block_link_ptr =  TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(next_ptr);
                        current_ptr =  *next_block_link_ptr;
  401040:	f8dc 2000 	ldr.w	r2, [ip]

                        /* Decrement the examined block count to account for this one.  */
                        if (examine_blocks != ((UINT) 0))
  401044:	b183      	cbz	r3, 401068 <_tx_byte_pool_search+0x7c>
                        {
                            examine_blocks--;
  401046:	3b01      	subs	r3, #1
  401048:	4675      	mov	r5, lr
  40104a:	e01f      	b.n	40108c <_tx_byte_pool_search+0xa0>
                        *this_block_link_ptr =  *next_block_link_ptr;
  40104c:	f8dc 5000 	ldr.w	r5, [ip]
  401050:	6015      	str	r5, [r2, #0]
                        pool_ptr -> tx_byte_pool_fragments--;
  401052:	68c5      	ldr	r5, [r0, #12]
  401054:	3d01      	subs	r5, #1
  401056:	60c5      	str	r5, [r0, #12]
                        if (pool_ptr -> tx_byte_pool_search ==  next_ptr)
  401058:	6945      	ldr	r5, [r0, #20]
  40105a:	45ac      	cmp	ip, r5
  40105c:	d001      	beq.n	401062 <_tx_byte_pool_search+0x76>
  40105e:	4675      	mov	r5, lr
  401060:	e014      	b.n	40108c <_tx_byte_pool_search+0xa0>
                            pool_ptr -> tx_byte_pool_search =  current_ptr;
  401062:	6142      	str	r2, [r0, #20]
  401064:	4675      	mov	r5, lr
  401066:	e011      	b.n	40108c <_tx_byte_pool_search+0xa0>
  401068:	4675      	mov	r5, lr
  40106a:	f384 8810 	msr	PRIMASK, r4
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  40106e:	f3ef 8410 	mrs	r4, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  401072:	b672      	cpsid	i

            /* Disable interrupts.  */
            TX_DISABLE

            /* Determine if anything has changed in terms of pool ownership.  */
            if (pool_ptr -> tx_byte_pool_owner != thread_ptr)
  401074:	6a01      	ldr	r1, [r0, #32]
  401076:	428e      	cmp	r6, r1
  401078:	d003      	beq.n	401082 <_tx_byte_pool_search+0x96>
            {

                /* Pool changed ownership in the brief period interrupts were
                   enabled.  Reset the search.  */
                current_ptr =      pool_ptr -> tx_byte_pool_search;
  40107a:	6942      	ldr	r2, [r0, #20]
                examine_blocks =   pool_ptr -> tx_byte_pool_fragments + ((UINT) 1);
  40107c:	68c3      	ldr	r3, [r0, #12]
  40107e:	3301      	adds	r3, #1

                /* Setup our ownership again.  */
                pool_ptr -> tx_byte_pool_owner =  thread_ptr;
  401080:	6206      	str	r6, [r0, #32]
            }
        } while(examine_blocks != ((UINT) 0));
  401082:	b34b      	cbz	r3, 4010d8 <_tx_byte_pool_search+0xec>
            if ((*free_ptr) == TX_BYTE_BLOCK_FREE)
  401084:	6851      	ldr	r1, [r2, #4]
  401086:	42b9      	cmp	r1, r7
  401088:	d0cd      	beq.n	401026 <_tx_byte_pool_search+0x3a>
                current_ptr =  *this_block_link_ptr;
  40108a:	6812      	ldr	r2, [r2, #0]
            if (examine_blocks != ((UINT) 0))
  40108c:	2b00      	cmp	r3, #0
  40108e:	d0ec      	beq.n	40106a <_tx_byte_pool_search+0x7e>
                examine_blocks--;
  401090:	3b01      	subs	r3, #1
  401092:	e7ea      	b.n	40106a <_tx_byte_pool_search+0x7e>

        /* Determine if a block was found.  If so, determine if it needs to be
           split.  */
        if (available_bytes != ((ULONG) 0))
  401094:	b305      	cbz	r5, 4010d8 <_tx_byte_pool_search+0xec>
        {

            /* Determine if we need to split this block.  */
            if ((available_bytes - memory_size) >= ((ULONG) TX_BYTE_BLOCK_MIN))
  401096:	eba5 0308 	sub.w	r3, r5, r8
  40109a:	2b13      	cmp	r3, #19
  40109c:	d90b      	bls.n	4010b6 <_tx_byte_pool_search+0xca>
            {

                /* Split the block.  */
                next_ptr =  TX_UCHAR_POINTER_ADD(current_ptr, (memory_size + ((sizeof(UCHAR *)) + (sizeof(ALIGN_TYPE)))));
  40109e:	f108 0308 	add.w	r3, r8, #8
  4010a2:	18d5      	adds	r5, r2, r3

                /* Setup the new free block.  */
                next_block_link_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(next_ptr);
                this_block_link_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(current_ptr);
                *next_block_link_ptr =  *this_block_link_ptr;
  4010a4:	f842 c003 	str.w	ip, [r2, r3]
                work_ptr =              TX_UCHAR_POINTER_ADD(next_ptr, (sizeof(UCHAR *)));
                free_ptr =              TX_UCHAR_TO_ALIGN_TYPE_POINTER_CONVERT(work_ptr);
                *free_ptr =             TX_BYTE_BLOCK_FREE;
  4010a8:	4b10      	ldr	r3, [pc, #64]	; (4010ec <_tx_byte_pool_search+0x100>)
  4010aa:	606b      	str	r3, [r5, #4]

                /* Increase the total fragment counter.  */
                pool_ptr -> tx_byte_pool_fragments++;
  4010ac:	68c3      	ldr	r3, [r0, #12]
  4010ae:	3301      	adds	r3, #1
  4010b0:	60c3      	str	r3, [r0, #12]

                /* Update the current pointer to point at the newly created block.  */
                *this_block_link_ptr =  next_ptr;
  4010b2:	6015      	str	r5, [r2, #0]

                /* Set available equal to memory size for subsequent calculation.  */
                available_bytes =  memory_size;
  4010b4:	4645      	mov	r5, r8
            }

            /* In any case, mark the current block as allocated.  */
            work_ptr =              TX_UCHAR_POINTER_ADD(current_ptr, (sizeof(UCHAR *)));
            this_block_link_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(work_ptr);
            *this_block_link_ptr =  TX_BYTE_POOL_TO_UCHAR_POINTER_CONVERT(pool_ptr);
  4010b6:	6050      	str	r0, [r2, #4]

            /* Reduce the number of available bytes in the pool.  */
            pool_ptr -> tx_byte_pool_available =  (pool_ptr -> tx_byte_pool_available - available_bytes) - ((sizeof(UCHAR *)) + (sizeof(ALIGN_TYPE)));
  4010b8:	6883      	ldr	r3, [r0, #8]
  4010ba:	3b08      	subs	r3, #8
  4010bc:	1b5d      	subs	r5, r3, r5
  4010be:	6085      	str	r5, [r0, #8]

            /* Determine if the search pointer needs to be updated. This is only done
               if the search pointer matches the block to be returned.  */
            if (current_ptr == pool_ptr -> tx_byte_pool_search)
  4010c0:	6943      	ldr	r3, [r0, #20]
  4010c2:	429a      	cmp	r2, r3
  4010c4:	d005      	beq.n	4010d2 <_tx_byte_pool_search+0xe6>
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  4010c6:	f384 8810 	msr	PRIMASK, r4

            /* Restore interrupts.  */
            TX_RESTORE

            /* Adjust the pointer for the application.  */
            current_ptr =  TX_UCHAR_POINTER_ADD(current_ptr, (((sizeof(UCHAR *)) + (sizeof(ALIGN_TYPE)))));
  4010ca:	f102 0008 	add.w	r0, r2, #8
  4010ce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                pool_ptr -> tx_byte_pool_search =  *this_block_link_ptr;
  4010d2:	6813      	ldr	r3, [r2, #0]
  4010d4:	6143      	str	r3, [r0, #20]
  4010d6:	e7f6      	b.n	4010c6 <_tx_byte_pool_search+0xda>
  4010d8:	f384 8810 	msr	PRIMASK, r4

            /* Restore interrupts.  */
            TX_RESTORE

            /* Set current pointer to NULL to indicate nothing was found.  */
            current_ptr =  TX_NULL;
  4010dc:	2000      	movs	r0, #0
        }
    }

    /* Return the search pointer.  */
    return(current_ptr);
}
  4010de:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4010e2:	bf00      	nop
  4010e4:	1ffffffe 	.word	0x1ffffffe
  4010e8:	20400590 	.word	0x20400590
  4010ec:	ffffeeee 	.word	0xffffeeee

004010f0 <_tx_event_flags_cleanup>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_event_flags_cleanup(TX_THREAD  *thread_ptr, ULONG suspension_sequence)
{
  4010f0:	b538      	push	{r3, r4, r5, lr}
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  4010f2:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  4010f6:	b672      	cpsid	i

    /* Disable interrupts to remove the suspended thread from the event flags group.  */
    TX_DISABLE

    /* Determine if the cleanup is still required.  */
    if (thread_ptr -> tx_thread_suspend_cleanup == &(_tx_event_flags_cleanup))
  4010f8:	6e84      	ldr	r4, [r0, #104]	; 0x68
  4010fa:	4a1c      	ldr	r2, [pc, #112]	; (40116c <_tx_event_flags_cleanup+0x7c>)
  4010fc:	4294      	cmp	r4, r2
  4010fe:	d002      	beq.n	401106 <_tx_event_flags_cleanup+0x16>
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  401100:	f383 8810 	msr	PRIMASK, r3
  401104:	bd38      	pop	{r3, r4, r5, pc}
    {

        /* Check for valid suspension sequence.  */
        if (suspension_sequence == thread_ptr -> tx_thread_suspension_sequence)
  401106:	f8d0 20b0 	ldr.w	r2, [r0, #176]	; 0xb0
  40110a:	428a      	cmp	r2, r1
  40110c:	d1f8      	bne.n	401100 <_tx_event_flags_cleanup+0x10>
        {

            /* Setup pointer to event flags control block.  */
            group_ptr =  TX_VOID_TO_EVENT_FLAGS_POINTER_CONVERT(thread_ptr -> tx_thread_suspend_control_block);
  40110e:	6ec2      	ldr	r2, [r0, #108]	; 0x6c

            /* Check for a NULL event flags control block pointer.  */
            if (group_ptr != TX_NULL)
  401110:	2a00      	cmp	r2, #0
  401112:	d0f5      	beq.n	401100 <_tx_event_flags_cleanup+0x10>
            {

                /* Is the group pointer ID valid?  */
                if (group_ptr -> tx_event_flags_group_id == TX_EVENT_FLAGS_ID)
  401114:	6814      	ldr	r4, [r2, #0]
  401116:	4916      	ldr	r1, [pc, #88]	; (401170 <_tx_event_flags_cleanup+0x80>)
  401118:	428c      	cmp	r4, r1
  40111a:	d1f1      	bne.n	401100 <_tx_event_flags_cleanup+0x10>
                {

                    /* Determine if there are any thread suspensions.  */
                    if (group_ptr -> tx_event_flags_group_suspended_count != TX_NO_SUSPENSIONS)
  40111c:	6951      	ldr	r1, [r2, #20]
  40111e:	2900      	cmp	r1, #0
  401120:	d0ee      	beq.n	401100 <_tx_event_flags_cleanup+0x10>
#endif

                        /* Yes, we still have thread suspension!  */

                        /* Clear the suspension cleanup flag.  */
                        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
  401122:	2100      	movs	r1, #0
  401124:	6681      	str	r1, [r0, #104]	; 0x68

                        /* Pickup the suspended count.  */
                        suspended_count =  group_ptr -> tx_event_flags_group_suspended_count;
  401126:	6951      	ldr	r1, [r2, #20]

                        /* Pickup the suspension head.  */
                        suspension_head =  group_ptr -> tx_event_flags_group_suspension_list;
  401128:	6914      	ldr	r4, [r2, #16]

                        /* Determine if the cleanup is being done while a set operation was interrupted.  If the
                           suspended count is non-zero and the suspension head is NULL, the list is being processed
                           and cannot be touched from here. The suspension list removal will instead take place
                           inside the event flag set code.  */
                        if (suspension_head != TX_NULL)
  40112a:	b1e4      	cbz	r4, 401166 <_tx_event_flags_cleanup+0x76>
                        {

                            /* Remove the suspended thread from the list.  */

                            /* Decrement the local suspension count.  */
                            suspended_count--;
  40112c:	3901      	subs	r1, #1

                            /* Store the updated suspended count.  */
                            group_ptr -> tx_event_flags_group_suspended_count =  suspended_count;
  40112e:	6151      	str	r1, [r2, #20]

                            /* See if this is the only suspended thread on the list.  */
                            if (suspended_count == TX_NO_SUSPENSIONS)
  401130:	b989      	cbnz	r1, 401156 <_tx_event_flags_cleanup+0x66>
                            {

                                /* Yes, the only suspended thread.  */

                                /* Update the head pointer.  */
                                group_ptr -> tx_event_flags_group_suspension_list =  TX_NULL;
  401132:	6111      	str	r1, [r2, #16]
                            group_ptr -> tx_event_flags_group_reset_search =  TX_TRUE;
                        }

                        /* Now we need to determine if this cleanup is from a terminate, timeout,
                           or from a wait abort.  */
                        if (thread_ptr -> tx_thread_state == TX_EVENT_FLAG)
  401134:	6b02      	ldr	r2, [r0, #48]	; 0x30
  401136:	2a07      	cmp	r2, #7
  401138:	d1e2      	bne.n	401100 <_tx_event_flags_cleanup+0x10>
                            /* Increment the number of timeouts on this event flags group.  */
                            group_ptr -> tx_event_flags_group____performance_timeout_count++;
#endif

                            /* Setup return status.  */
                            thread_ptr -> tx_thread_suspend_status =  TX_NO_EVENTS;
  40113a:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84
                            /* Resume the thread!  */
                            _tx_thread_system_ni_resume(thread_ptr);
#else

                           /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
  40113e:	490d      	ldr	r1, [pc, #52]	; (401174 <_tx_event_flags_cleanup+0x84>)
  401140:	680a      	ldr	r2, [r1, #0]
  401142:	3201      	adds	r2, #1
  401144:	600a      	str	r2, [r1, #0]
  401146:	f383 8810 	msr	PRIMASK, r3
                            TX_RESTORE

                            /* Resume the thread!  Check for preemption even though we are executing
                               from the system timer thread right now which normally executes at the
                               highest priority.  */
                            _tx_thread_system_resume(thread_ptr);
  40114a:	4b0b      	ldr	r3, [pc, #44]	; (401178 <_tx_event_flags_cleanup+0x88>)
  40114c:	4798      	blx	r3
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  40114e:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  401152:	b672      	cpsid	i
  401154:	e7d4      	b.n	401100 <_tx_event_flags_cleanup+0x10>
                                next_thread =                                  thread_ptr -> tx_thread_suspended_next;
  401156:	6f01      	ldr	r1, [r0, #112]	; 0x70
                                previous_thread =                              thread_ptr -> tx_thread_suspended_previous;
  401158:	6f45      	ldr	r5, [r0, #116]	; 0x74
                                next_thread -> tx_thread_suspended_previous =  previous_thread;
  40115a:	674d      	str	r5, [r1, #116]	; 0x74
                                previous_thread -> tx_thread_suspended_next =  next_thread;
  40115c:	6729      	str	r1, [r5, #112]	; 0x70
                                if (suspension_head == thread_ptr)
  40115e:	42a0      	cmp	r0, r4
  401160:	d1e8      	bne.n	401134 <_tx_event_flags_cleanup+0x44>
                                    group_ptr -> tx_event_flags_group_suspension_list =  next_thread;
  401162:	6111      	str	r1, [r2, #16]
  401164:	e7e6      	b.n	401134 <_tx_event_flags_cleanup+0x44>
                            group_ptr -> tx_event_flags_group_reset_search =  TX_TRUE;
  401166:	2101      	movs	r1, #1
  401168:	60d1      	str	r1, [r2, #12]
  40116a:	e7e3      	b.n	401134 <_tx_event_flags_cleanup+0x44>
  40116c:	004010f1 	.word	0x004010f1
  401170:	4456444e 	.word	0x4456444e
  401174:	2040058c 	.word	0x2040058c
  401178:	004024a5 	.word	0x004024a5

0040117c <_tx_event_flags_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_event_flags_create(TX_EVENT_FLAGS_GROUP *group_ptr, CHAR *name_ptr)
{
  40117c:	b538      	push	{r3, r4, r5, lr}
  40117e:	4604      	mov	r4, r0
  401180:	460d      	mov	r5, r1
TX_EVENT_FLAGS_GROUP    *next_group;
TX_EVENT_FLAGS_GROUP    *previous_group;


    /* Initialize event flags control block to all zeros.  */
    TX_MEMSET(group_ptr, 0, (sizeof(TX_EVENT_FLAGS_GROUP)));
  401182:	2228      	movs	r2, #40	; 0x28
  401184:	2100      	movs	r1, #0
  401186:	4b0f      	ldr	r3, [pc, #60]	; (4011c4 <_tx_event_flags_create+0x48>)
  401188:	4798      	blx	r3

    /* Setup the basic event flags group fields.  */
    group_ptr -> tx_event_flags_group_name =             name_ptr;
  40118a:	6065      	str	r5, [r4, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  40118c:	f3ef 8110 	mrs	r1, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  401190:	b672      	cpsid	i

    /* Disable interrupts to put the event flags group on the created list.  */
    TX_DISABLE

    /* Setup the event flags ID to make it valid.  */
    group_ptr -> tx_event_flags_group_id =  TX_EVENT_FLAGS_ID;
  401192:	4b0d      	ldr	r3, [pc, #52]	; (4011c8 <_tx_event_flags_create+0x4c>)
  401194:	6023      	str	r3, [r4, #0]

    /* Place the group on the list of created event flag groups.  First,
       check for an empty list.  */
    if (_tx_event_flags_created_count == TX_EMPTY)
  401196:	4b0d      	ldr	r3, [pc, #52]	; (4011cc <_tx_event_flags_create+0x50>)
  401198:	681b      	ldr	r3, [r3, #0]
  40119a:	b173      	cbz	r3, 4011ba <_tx_event_flags_create+0x3e>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_group =      _tx_event_flags_created_ptr;
  40119c:	4b0c      	ldr	r3, [pc, #48]	; (4011d0 <_tx_event_flags_create+0x54>)
  40119e:	681b      	ldr	r3, [r3, #0]
        previous_group =  next_group -> tx_event_flags_group_created_previous;
  4011a0:	69da      	ldr	r2, [r3, #28]

        /* Place the new event flag group in the list.  */
        next_group -> tx_event_flags_group_created_previous =  group_ptr;
  4011a2:	61dc      	str	r4, [r3, #28]
        previous_group -> tx_event_flags_group_created_next =  group_ptr;
  4011a4:	6194      	str	r4, [r2, #24]

        /* Setup this group's created links.  */
        group_ptr -> tx_event_flags_group_created_previous =  previous_group;
  4011a6:	61e2      	str	r2, [r4, #28]
        group_ptr -> tx_event_flags_group_created_next =      next_group;
  4011a8:	61a3      	str	r3, [r4, #24]
    }

    /* Increment the number of created event flag groups.  */
    _tx_event_flags_created_count++;
  4011aa:	4a08      	ldr	r2, [pc, #32]	; (4011cc <_tx_event_flags_create+0x50>)
  4011ac:	6813      	ldr	r3, [r2, #0]
  4011ae:	3301      	adds	r3, #1
  4011b0:	6013      	str	r3, [r2, #0]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  4011b2:	f381 8810 	msr	PRIMASK, r1
    /* Restore interrupts.  */
    TX_RESTORE

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
}
  4011b6:	2000      	movs	r0, #0
  4011b8:	bd38      	pop	{r3, r4, r5, pc}
        _tx_event_flags_created_ptr =                         group_ptr;
  4011ba:	4b05      	ldr	r3, [pc, #20]	; (4011d0 <_tx_event_flags_create+0x54>)
  4011bc:	601c      	str	r4, [r3, #0]
        group_ptr -> tx_event_flags_group_created_next =      group_ptr;
  4011be:	61a4      	str	r4, [r4, #24]
        group_ptr -> tx_event_flags_group_created_previous =  group_ptr;
  4011c0:	61e4      	str	r4, [r4, #28]
  4011c2:	e7f2      	b.n	4011aa <_tx_event_flags_create+0x2e>
  4011c4:	00403361 	.word	0x00403361
  4011c8:	4456444e 	.word	0x4456444e
  4011cc:	204004e4 	.word	0x204004e4
  4011d0:	204004c0 	.word	0x204004c0

004011d4 <_tx_event_flags_get>:
/*                                            resulting in version 6.2.0  */
/*                                                                        */
/**************************************************************************/
UINT  _tx_event_flags_get(TX_EVENT_FLAGS_GROUP *group_ptr, ULONG requested_flags,
                    UINT get_option, ULONG *actual_flags_ptr, ULONG wait_option)
{
  4011d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  4011d6:	f3ef 8610 	mrs	r6, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  4011da:	b672      	cpsid	i

    /* Log this kernel call.  */
    TX_EL_EVENT_FLAGS_GET_INSERT

    /* Pickup current flags.  */
    current_flags =  group_ptr -> tx_event_flags_group_current;
  4011dc:	6884      	ldr	r4, [r0, #8]

    /* Return the actual event flags and apply delayed clearing.  */
    *actual_flags_ptr =  current_flags & ~group_ptr -> tx_event_flags_group_delayed_clear;
  4011de:	6a05      	ldr	r5, [r0, #32]
  4011e0:	ea24 0505 	bic.w	r5, r4, r5
  4011e4:	601d      	str	r5, [r3, #0]

    /* Apply the event flag option mask.  */
    and_request =  (get_option & TX_AND);
  4011e6:	f002 0702 	and.w	r7, r2, #2
    }

#else

    /* Pickup delayed clear flags.  */
    delayed_clear_flags =  group_ptr -> tx_event_flags_group_delayed_clear;
  4011ea:	6a05      	ldr	r5, [r0, #32]

    /* Determine if there are any delayed clear operations pending.  */
    if (delayed_clear_flags != ((ULONG) 0))
  4011ec:	b10d      	cbz	r5, 4011f2 <_tx_event_flags_get+0x1e>
    {

        /* Yes, apply them to the current flags.  */
        current_flags =  current_flags & (~delayed_clear_flags);
  4011ee:	ea24 0405 	bic.w	r4, r4, r5
    }

    /* Check for AND condition. All flags must be present to satisfy request.  */
    if (and_request == TX_AND)
  4011f2:	b147      	cbz	r7, 401206 <_tx_event_flags_get+0x32>
    {

        /* AND request is present.  */

        /* Calculate the flags present.  */
        flags_satisfied =  (current_flags & requested_flags);
  4011f4:	400c      	ands	r4, r1

        /* Determine if they satisfy the AND request.  */
        if (flags_satisfied != requested_flags)
  4011f6:	42a1      	cmp	r1, r4
  4011f8:	d006      	beq.n	401208 <_tx_event_flags_get+0x34>
#endif
    else
    {
        /* flags_satisfied is 0.  */
        /* Determine if the request specifies suspension.  */
        if (wait_option != TX_NO_WAIT)
  4011fa:	9c06      	ldr	r4, [sp, #24]
  4011fc:	b9bc      	cbnz	r4, 40122e <_tx_event_flags_get+0x5a>
        }
        else
        {

            /* Immediate return, return error completion.  */
            status =  TX_NO_EVENTS;
  4011fe:	2007      	movs	r0, #7
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  401200:	f386 8810 	msr	PRIMASK, r6
    /* Restore interrupts.  */
    TX_RESTORE

    /* Return completion status.  */
    return(status);
}
  401204:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        flags_satisfied =  (current_flags & requested_flags);
  401206:	400c      	ands	r4, r1
    if (flags_satisfied != ((ULONG) 0))
  401208:	2c00      	cmp	r4, #0
  40120a:	d0f6      	beq.n	4011fa <_tx_event_flags_get+0x26>
        if (clear_request == TX_TRUE)
  40120c:	f012 0f01 	tst.w	r2, #1
  401210:	d045      	beq.n	40129e <_tx_event_flags_get+0xca>
            if (group_ptr -> tx_event_flags_group_suspended_count != TX_NO_SUSPENSIONS)
  401212:	6943      	ldr	r3, [r0, #20]
  401214:	b12b      	cbz	r3, 401222 <_tx_event_flags_get+0x4e>
            if (interrupted_set_request == TX_TRUE)
  401216:	6903      	ldr	r3, [r0, #16]
  401218:	b91b      	cbnz	r3, 401222 <_tx_event_flags_get+0x4e>
                                        group_ptr -> tx_event_flags_group_delayed_clear | requested_flags;
  40121a:	4329      	orrs	r1, r5
                group_ptr -> tx_event_flags_group_delayed_clear =
  40121c:	6201      	str	r1, [r0, #32]
        status =  TX_SUCCESS;
  40121e:	2000      	movs	r0, #0
  401220:	e7ee      	b.n	401200 <_tx_event_flags_get+0x2c>
                                        group_ptr -> tx_event_flags_group_current & ~requested_flags;
  401222:	6883      	ldr	r3, [r0, #8]
  401224:	ea23 0101 	bic.w	r1, r3, r1
                group_ptr -> tx_event_flags_group_current =
  401228:	6081      	str	r1, [r0, #8]
        status =  TX_SUCCESS;
  40122a:	2000      	movs	r0, #0
  40122c:	e7e8      	b.n	401200 <_tx_event_flags_get+0x2c>
            if ((_tx_thread_preempt_disable != ((UINT) 0)) || (requested_flags == (UINT) 0))
  40122e:	4c1d      	ldr	r4, [pc, #116]	; (4012a4 <_tx_event_flags_get+0xd0>)
  401230:	6824      	ldr	r4, [r4, #0]
  401232:	b101      	cbz	r1, 401236 <_tx_event_flags_get+0x62>
  401234:	b10c      	cbz	r4, 40123a <_tx_event_flags_get+0x66>
                status =  TX_NO_EVENTS;
  401236:	2007      	movs	r0, #7
  401238:	e7e2      	b.n	401200 <_tx_event_flags_get+0x2c>
                TX_THREAD_GET_CURRENT(thread_ptr)
  40123a:	4c1b      	ldr	r4, [pc, #108]	; (4012a8 <_tx_event_flags_get+0xd4>)
  40123c:	6824      	ldr	r4, [r4, #0]
                thread_ptr -> tx_thread_suspend_cleanup =  &(_tx_event_flags_cleanup);
  40123e:	4d1b      	ldr	r5, [pc, #108]	; (4012ac <_tx_event_flags_get+0xd8>)
  401240:	66a5      	str	r5, [r4, #104]	; 0x68
                thread_ptr -> tx_thread_suspend_info =  requested_flags;
  401242:	67a1      	str	r1, [r4, #120]	; 0x78
                thread_ptr -> tx_thread_suspend_option =  get_option;
  401244:	f8c4 2080 	str.w	r2, [r4, #128]	; 0x80
                thread_ptr -> tx_thread_additional_suspend_info =  (VOID *) actual_flags_ptr;
  401248:	67e3      	str	r3, [r4, #124]	; 0x7c
                thread_ptr -> tx_thread_suspend_control_block =  (VOID *) group_ptr;
  40124a:	66e0      	str	r0, [r4, #108]	; 0x6c
                thread_ptr -> tx_thread_suspension_sequence++;
  40124c:	f8d4 30b0 	ldr.w	r3, [r4, #176]	; 0xb0
  401250:	3301      	adds	r3, #1
  401252:	f8c4 30b0 	str.w	r3, [r4, #176]	; 0xb0
                if (suspended_count == TX_NO_SUSPENSIONS)
  401256:	6943      	ldr	r3, [r0, #20]
  401258:	b9d3      	cbnz	r3, 401290 <_tx_event_flags_get+0xbc>
                    group_ptr -> tx_event_flags_group_suspension_list =   thread_ptr;
  40125a:	6104      	str	r4, [r0, #16]
                    thread_ptr -> tx_thread_suspended_next =              thread_ptr;
  40125c:	6724      	str	r4, [r4, #112]	; 0x70
                    thread_ptr -> tx_thread_suspended_previous =          thread_ptr;
  40125e:	6764      	str	r4, [r4, #116]	; 0x74
                group_ptr -> tx_event_flags_group_suspended_count++;
  401260:	6943      	ldr	r3, [r0, #20]
  401262:	3301      	adds	r3, #1
  401264:	6143      	str	r3, [r0, #20]
                thread_ptr -> tx_thread_state =    TX_EVENT_FLAG;
  401266:	2307      	movs	r3, #7
  401268:	6323      	str	r3, [r4, #48]	; 0x30
                thread_ptr -> tx_thread_suspending =  TX_TRUE;
  40126a:	2301      	movs	r3, #1
  40126c:	63a3      	str	r3, [r4, #56]	; 0x38
                thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
  40126e:	9b06      	ldr	r3, [sp, #24]
  401270:	64e3      	str	r3, [r4, #76]	; 0x4c
                _tx_thread_preempt_disable++;
  401272:	4a0c      	ldr	r2, [pc, #48]	; (4012a4 <_tx_event_flags_get+0xd0>)
  401274:	6813      	ldr	r3, [r2, #0]
  401276:	3301      	adds	r3, #1
  401278:	6013      	str	r3, [r2, #0]
  40127a:	f386 8810 	msr	PRIMASK, r6
                _tx_thread_system_suspend(thread_ptr);
  40127e:	4620      	mov	r0, r4
  401280:	4b0b      	ldr	r3, [pc, #44]	; (4012b0 <_tx_event_flags_get+0xdc>)
  401282:	4798      	blx	r3
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  401284:	f3ef 8610 	mrs	r6, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  401288:	b672      	cpsid	i
                status =  thread_ptr -> tx_thread_suspend_status;
  40128a:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
  40128e:	e7b7      	b.n	401200 <_tx_event_flags_get+0x2c>
                    next_thread =                                   group_ptr -> tx_event_flags_group_suspension_list;
  401290:	6903      	ldr	r3, [r0, #16]
                    thread_ptr -> tx_thread_suspended_next =        next_thread;
  401292:	6723      	str	r3, [r4, #112]	; 0x70
                    previous_thread =                               next_thread -> tx_thread_suspended_previous;
  401294:	6f5a      	ldr	r2, [r3, #116]	; 0x74
                    thread_ptr -> tx_thread_suspended_previous =    previous_thread;
  401296:	6762      	str	r2, [r4, #116]	; 0x74
                    previous_thread -> tx_thread_suspended_next =   thread_ptr;
  401298:	6714      	str	r4, [r2, #112]	; 0x70
                    next_thread -> tx_thread_suspended_previous =   thread_ptr;
  40129a:	675c      	str	r4, [r3, #116]	; 0x74
  40129c:	e7e0      	b.n	401260 <_tx_event_flags_get+0x8c>
        status =  TX_SUCCESS;
  40129e:	2000      	movs	r0, #0
  4012a0:	e7ae      	b.n	401200 <_tx_event_flags_get+0x2c>
  4012a2:	bf00      	nop
  4012a4:	2040058c 	.word	0x2040058c
  4012a8:	20400590 	.word	0x20400590
  4012ac:	004010f1 	.word	0x004010f1
  4012b0:	004025d9 	.word	0x004025d9

004012b4 <_tx_event_flags_set>:
/*                                            check logic, resulting in   */
/*                                            version 6.1.11              */
/*                                                                        */
/**************************************************************************/
UINT  _tx_event_flags_set(TX_EVENT_FLAGS_GROUP *group_ptr, ULONG flags_to_set, UINT set_option)
{
  4012b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4012b8:	b083      	sub	sp, #12
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  4012ba:	f3ef 8510 	mrs	r5, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  4012be:	b672      	cpsid	i

    /* Log this kernel call.  */
    TX_EL_EVENT_FLAGS_SET_INSERT

    /* Determine how to set this group's event flags.  */
    if ((set_option & TX_EVENT_FLAGS_AND_MASK) == TX_AND)
  4012c0:	f012 0f02 	tst.w	r2, #2
  4012c4:	d011      	beq.n	4012ea <_tx_event_flags_set+0x36>
        /* Set interrupted set request flag to false.  */
        interrupted_set_request =  TX_FALSE;

        /* Determine if the suspension list is being processed by an interrupted
           set request.  */
        if (group_ptr -> tx_event_flags_group_suspended_count != TX_NO_SUSPENSIONS)
  4012c6:	6943      	ldr	r3, [r0, #20]
  4012c8:	b133      	cbz	r3, 4012d8 <_tx_event_flags_set+0x24>
                interrupted_set_request =  TX_TRUE;
            }
        }

        /* Was a set request interrupted?  */
        if (interrupted_set_request == TX_TRUE)
  4012ca:	6903      	ldr	r3, [r0, #16]
  4012cc:	b923      	cbnz	r3, 4012d8 <_tx_event_flags_set+0x24>
            /* A previous set operation was interrupted, we need to defer the
               event clearing until the set operation is complete.  */

            /* Remember the events to clear.  */
            group_ptr -> tx_event_flags_group_delayed_clear =
                                        group_ptr -> tx_event_flags_group_delayed_clear | ~flags_to_set;
  4012ce:	6a03      	ldr	r3, [r0, #32]
  4012d0:	ea63 0101 	orn	r1, r3, r1
            group_ptr -> tx_event_flags_group_delayed_clear =
  4012d4:	6201      	str	r1, [r0, #32]
  4012d6:	e002      	b.n	4012de <_tx_event_flags_set+0x2a>

            /* Previous set operation was not interrupted, simply clear the
               specified flags by "ANDing" the flags into the current events
               of the group.  */
            group_ptr -> tx_event_flags_group_current =
                group_ptr -> tx_event_flags_group_current & flags_to_set;
  4012d8:	6883      	ldr	r3, [r0, #8]
  4012da:	4019      	ands	r1, r3
            group_ptr -> tx_event_flags_group_current =
  4012dc:	6081      	str	r1, [r0, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  4012de:	f385 8810 	msr	PRIMASK, r5
        }
    }

    /* Return completion status.  */
    return(TX_SUCCESS);
}
  4012e2:	2000      	movs	r0, #0
  4012e4:	b003      	add	sp, #12
  4012e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        events_set_notify =  group_ptr -> tx_event_flags_group_set_notify;
  4012ea:	f8d0 b024 	ldr.w	fp, [r0, #36]	; 0x24
            group_ptr -> tx_event_flags_group_current | flags_to_set;
  4012ee:	6886      	ldr	r6, [r0, #8]
  4012f0:	430e      	orrs	r6, r1
        group_ptr -> tx_event_flags_group_current =
  4012f2:	6086      	str	r6, [r0, #8]
        if (group_ptr -> tx_event_flags_group_delayed_clear != ((ULONG) 0))
  4012f4:	6a03      	ldr	r3, [r0, #32]
  4012f6:	b113      	cbz	r3, 4012fe <_tx_event_flags_set+0x4a>
                                        group_ptr -> tx_event_flags_group_delayed_clear & ~flags_to_set;
  4012f8:	ea23 0101 	bic.w	r1, r3, r1
            group_ptr -> tx_event_flags_group_delayed_clear =
  4012fc:	6201      	str	r1, [r0, #32]
  4012fe:	4604      	mov	r4, r0
        suspended_count =  group_ptr -> tx_event_flags_group_suspended_count;
  401300:	6942      	ldr	r2, [r0, #20]
        if (group_ptr -> tx_event_flags_group_suspension_list != TX_NULL)
  401302:	6903      	ldr	r3, [r0, #16]
  401304:	2b00      	cmp	r3, #0
  401306:	f000 80b3 	beq.w	401470 <_tx_event_flags_set+0x1bc>
            if (suspended_count == ((UINT) 1))
  40130a:	2a01      	cmp	r2, #1
  40130c:	d00c      	beq.n	401328 <_tx_event_flags_set+0x74>
                group_ptr -> tx_event_flags_group_suspension_list =  TX_NULL;
  40130e:	2000      	movs	r0, #0
  401310:	6120      	str	r0, [r4, #16]
                _tx_thread_preempt_disable++;
  401312:	4f64      	ldr	r7, [pc, #400]	; (4014a4 <_tx_event_flags_set+0x1f0>)
  401314:	6839      	ldr	r1, [r7, #0]
  401316:	3101      	adds	r1, #1
  401318:	6039      	str	r1, [r7, #0]
                suspended_list =  group_ptr -> tx_event_flags_group_suspension_list;
  40131a:	469e      	mov	lr, r3
                last_satisfied =  TX_NULL;
  40131c:	4680      	mov	r8, r0
                        group_ptr -> tx_event_flags_group_reset_search =  TX_FALSE;
  40131e:	4607      	mov	r7, r0
  401320:	9000      	str	r0, [sp, #0]
  401322:	f8cd b004 	str.w	fp, [sp, #4]
  401326:	e04a      	b.n	4013be <_tx_event_flags_set+0x10a>
                requested_flags =  thread_ptr -> tx_thread_suspend_info;
  401328:	6f9a      	ldr	r2, [r3, #120]	; 0x78
                get_option =  thread_ptr -> tx_thread_suspend_option;
  40132a:	f8d3 1080 	ldr.w	r1, [r3, #128]	; 0x80
                if (and_request == TX_AND)
  40132e:	f011 0f02 	tst.w	r1, #2
  401332:	d005      	beq.n	401340 <_tx_event_flags_set+0x8c>
                    flags_satisfied =  (current_event_flags & requested_flags);
  401334:	ea06 0002 	and.w	r0, r6, r2
                    if (flags_satisfied != requested_flags)
  401338:	4282      	cmp	r2, r0
  40133a:	d003      	beq.n	401344 <_tx_event_flags_set+0x90>
        preempt_check =  TX_FALSE;
  40133c:	2600      	movs	r6, #0
  40133e:	e08a      	b.n	401456 <_tx_event_flags_set+0x1a2>
                    flags_satisfied =  (current_event_flags & requested_flags);
  401340:	ea06 0002 	and.w	r0, r6, r2
                if (flags_satisfied != ((ULONG) 0))
  401344:	2800      	cmp	r0, #0
  401346:	f000 8098 	beq.w	40147a <_tx_event_flags_set+0x1c6>
                    suspend_info_ptr =   TX_VOID_TO_ULONG_POINTER_CONVERT(thread_ptr -> tx_thread_additional_suspend_info);
  40134a:	6fd8      	ldr	r0, [r3, #124]	; 0x7c
                    *suspend_info_ptr =  current_event_flags;
  40134c:	6006      	str	r6, [r0, #0]
                    if (clear_request == TX_TRUE)
  40134e:	f011 0f01 	tst.w	r1, #1
  401352:	d003      	beq.n	40135c <_tx_event_flags_set+0xa8>
                        group_ptr -> tx_event_flags_group_current =  group_ptr -> tx_event_flags_group_current & (~requested_flags);
  401354:	68a1      	ldr	r1, [r4, #8]
  401356:	ea21 0202 	bic.w	r2, r1, r2
  40135a:	60a2      	str	r2, [r4, #8]
                    group_ptr -> tx_event_flags_group_suspension_list =  TX_NULL;
  40135c:	2600      	movs	r6, #0
  40135e:	6126      	str	r6, [r4, #16]
                    group_ptr -> tx_event_flags_group_suspended_count =  TX_NO_SUSPENSIONS;
  401360:	6166      	str	r6, [r4, #20]
                    thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
  401362:	669e      	str	r6, [r3, #104]	; 0x68
                    thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
  401364:	f8c3 6084 	str.w	r6, [r3, #132]	; 0x84
                    _tx_thread_preempt_disable++;
  401368:	494e      	ldr	r1, [pc, #312]	; (4014a4 <_tx_event_flags_set+0x1f0>)
  40136a:	680a      	ldr	r2, [r1, #0]
  40136c:	3201      	adds	r2, #1
  40136e:	600a      	str	r2, [r1, #0]
  401370:	f385 8810 	msr	PRIMASK, r5
                    _tx_thread_system_resume(thread_ptr);
  401374:	4618      	mov	r0, r3
  401376:	4b4c      	ldr	r3, [pc, #304]	; (4014a8 <_tx_event_flags_set+0x1f4>)
  401378:	4798      	blx	r3
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  40137a:	f3ef 8510 	mrs	r5, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  40137e:	b672      	cpsid	i
  401380:	e069      	b.n	401456 <_tx_event_flags_set+0x1a2>
                        flags_satisfied =  (current_event_flags & requested_flags);
  401382:	468b      	mov	fp, r1
  401384:	e001      	b.n	40138a <_tx_event_flags_set+0xd6>
                        flags_satisfied =  (current_event_flags & requested_flags);
  401386:	ea06 0b01 	and.w	fp, r6, r1
                    if (thread_ptr -> tx_thread_state != TX_EVENT_FLAG)
  40138a:	6b18      	ldr	r0, [r3, #48]	; 0x30
  40138c:	2807      	cmp	r0, #7
  40138e:	d078      	beq.n	401482 <_tx_event_flags_set+0x1ce>
                        if (thread_ptr == thread_ptr -> tx_thread_suspended_next)
  401390:	6f19      	ldr	r1, [r3, #112]	; 0x70
  401392:	428b      	cmp	r3, r1
  401394:	d031      	beq.n	4013fa <_tx_event_flags_set+0x146>
                            previous_thread =                              thread_ptr -> tx_thread_suspended_previous;
  401396:	f8d3 9074 	ldr.w	r9, [r3, #116]	; 0x74
                            next_thread -> tx_thread_suspended_previous =  previous_thread;
  40139a:	f8c1 9074 	str.w	r9, [r1, #116]	; 0x74
                            previous_thread -> tx_thread_suspended_next =  next_thread;
  40139e:	f8c9 1070 	str.w	r1, [r9, #112]	; 0x70
                            if (suspended_list == thread_ptr)
  4013a2:	4573      	cmp	r3, lr
  4013a4:	d026      	beq.n	4013f4 <_tx_event_flags_set+0x140>
                        group_ptr -> tx_event_flags_group_suspended_count--;
  4013a6:	6961      	ldr	r1, [r4, #20]
  4013a8:	3901      	subs	r1, #1
  4013aa:	6161      	str	r1, [r4, #20]
                        if (satisfied_list == TX_NULL)
  4013ac:	9900      	ldr	r1, [sp, #0]
  4013ae:	b339      	cbz	r1, 401400 <_tx_event_flags_set+0x14c>
                            last_satisfied -> tx_thread_suspended_next =  thread_ptr;
  4013b0:	f8c8 3070 	str.w	r3, [r8, #112]	; 0x70
                            thread_ptr -> tx_thread_suspended_next =      TX_NULL;
  4013b4:	671f      	str	r7, [r3, #112]	; 0x70
                            last_satisfied =                              thread_ptr;
  4013b6:	4698      	mov	r8, r3
                    thread_ptr =  next_thread_ptr;
  4013b8:	4663      	mov	r3, ip
                } while (suspended_count != TX_NO_SUSPENSIONS);
  4013ba:	3a01      	subs	r2, #1
  4013bc:	d024      	beq.n	401408 <_tx_event_flags_set+0x154>
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  4013be:	f385 8810 	msr	PRIMASK, r5
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  4013c2:	f3ef 8510 	mrs	r5, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  4013c6:	b672      	cpsid	i
                    if (group_ptr -> tx_event_flags_group_reset_search != TX_FALSE)
  4013c8:	68e1      	ldr	r1, [r4, #12]
  4013ca:	b121      	cbz	r1, 4013d6 <_tx_event_flags_set+0x122>
                        group_ptr -> tx_event_flags_group_reset_search =  TX_FALSE;
  4013cc:	60e7      	str	r7, [r4, #12]
                        suspended_count =  group_ptr -> tx_event_flags_group_suspended_count;
  4013ce:	6962      	ldr	r2, [r4, #20]
                        current_event_flags =  current_event_flags | group_ptr -> tx_event_flags_group_current;
  4013d0:	68a3      	ldr	r3, [r4, #8]
  4013d2:	431e      	orrs	r6, r3
                        thread_ptr =  suspended_list;
  4013d4:	4673      	mov	r3, lr
                    next_thread_ptr =  thread_ptr -> tx_thread_suspended_next;
  4013d6:	f8d3 c070 	ldr.w	ip, [r3, #112]	; 0x70
                    requested_flags =  thread_ptr -> tx_thread_suspend_info;
  4013da:	6f99      	ldr	r1, [r3, #120]	; 0x78
                    get_option =  thread_ptr -> tx_thread_suspend_option;
  4013dc:	f8d3 a080 	ldr.w	sl, [r3, #128]	; 0x80
                    if (and_request == TX_AND)
  4013e0:	f01a 0f02 	tst.w	sl, #2
  4013e4:	d0cf      	beq.n	401386 <_tx_event_flags_set+0xd2>
                        if (flags_satisfied != requested_flags)
  4013e6:	ea31 0006 	bics.w	r0, r1, r6
  4013ea:	d0ca      	beq.n	401382 <_tx_event_flags_set+0xce>
                    if (thread_ptr -> tx_thread_state != TX_EVENT_FLAG)
  4013ec:	6b19      	ldr	r1, [r3, #48]	; 0x30
  4013ee:	2907      	cmp	r1, #7
  4013f0:	d1ce      	bne.n	401390 <_tx_event_flags_set+0xdc>
  4013f2:	e7e1      	b.n	4013b8 <_tx_event_flags_set+0x104>
                                suspended_list =  thread_ptr -> tx_thread_suspended_next;
  4013f4:	f8de e070 	ldr.w	lr, [lr, #112]	; 0x70
  4013f8:	e7d5      	b.n	4013a6 <_tx_event_flags_set+0xf2>
                            suspended_list =  TX_NULL;
  4013fa:	f04f 0e00 	mov.w	lr, #0
  4013fe:	e7d2      	b.n	4013a6 <_tx_event_flags_set+0xf2>
                            thread_ptr -> tx_thread_suspended_next =  TX_NULL;
  401400:	671f      	str	r7, [r3, #112]	; 0x70
                            last_satisfied =  thread_ptr;
  401402:	4698      	mov	r8, r3
                            satisfied_list =  thread_ptr;
  401404:	9300      	str	r3, [sp, #0]
  401406:	e7d7      	b.n	4013b8 <_tx_event_flags_set+0x104>
  401408:	9800      	ldr	r0, [sp, #0]
  40140a:	f8dd b004 	ldr.w	fp, [sp, #4]
                group_ptr -> tx_event_flags_group_suspension_list =  suspended_list;
  40140e:	f8c4 e010 	str.w	lr, [r4, #16]
                if (group_ptr -> tx_event_flags_group_delayed_clear != ((ULONG) 0))
  401412:	6a23      	ldr	r3, [r4, #32]
  401414:	b12b      	cbz	r3, 401422 <_tx_event_flags_set+0x16e>
                        group_ptr -> tx_event_flags_group_current & ~(group_ptr -> tx_event_flags_group_delayed_clear);
  401416:	68a2      	ldr	r2, [r4, #8]
  401418:	ea22 0303 	bic.w	r3, r2, r3
                    group_ptr -> tx_event_flags_group_current =
  40141c:	60a3      	str	r3, [r4, #8]
                    group_ptr -> tx_event_flags_group_delayed_clear =  ((ULONG) 0);
  40141e:	2300      	movs	r3, #0
  401420:	6223      	str	r3, [r4, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  401422:	f385 8810 	msr	PRIMASK, r5
                while(thread_ptr != TX_NULL)
  401426:	b170      	cbz	r0, 401446 <_tx_event_flags_set+0x192>
                    _tx_thread_preempt_disable++;
  401428:	4e1e      	ldr	r6, [pc, #120]	; (4014a4 <_tx_event_flags_set+0x1f0>)
                    _tx_thread_system_resume(thread_ptr);
  40142a:	4f1f      	ldr	r7, [pc, #124]	; (4014a8 <_tx_event_flags_set+0x1f4>)
                    next_thread_ptr =  thread_ptr -> tx_thread_suspended_next;
  40142c:	6f05      	ldr	r5, [r0, #112]	; 0x70
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  40142e:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  401432:	b672      	cpsid	i
                    _tx_thread_preempt_disable++;
  401434:	6832      	ldr	r2, [r6, #0]
  401436:	3201      	adds	r2, #1
  401438:	6032      	str	r2, [r6, #0]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  40143a:	f383 8810 	msr	PRIMASK, r3
                    _tx_thread_system_resume(thread_ptr);
  40143e:	47b8      	blx	r7
                    thread_ptr =  next_thread_ptr;
  401440:	4628      	mov	r0, r5
                while(thread_ptr != TX_NULL)
  401442:	2d00      	cmp	r5, #0
  401444:	d1f2      	bne.n	40142c <_tx_event_flags_set+0x178>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  401446:	f3ef 8510 	mrs	r5, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  40144a:	b672      	cpsid	i
                _tx_thread_preempt_disable--;
  40144c:	4a15      	ldr	r2, [pc, #84]	; (4014a4 <_tx_event_flags_set+0x1f0>)
  40144e:	6813      	ldr	r3, [r2, #0]
  401450:	3b01      	subs	r3, #1
  401452:	6013      	str	r3, [r2, #0]
                preempt_check =  TX_TRUE;
  401454:	2601      	movs	r6, #1
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  401456:	f385 8810 	msr	PRIMASK, r5
        if (events_set_notify != TX_NULL)
  40145a:	f1bb 0f00 	cmp.w	fp, #0
  40145e:	d001      	beq.n	401464 <_tx_event_flags_set+0x1b0>
            (events_set_notify)(group_ptr);
  401460:	4620      	mov	r0, r4
  401462:	47d8      	blx	fp
        if (preempt_check == TX_TRUE)
  401464:	2e00      	cmp	r6, #0
  401466:	f43f af3c 	beq.w	4012e2 <_tx_event_flags_set+0x2e>
            _tx_thread_system_preempt_check();
  40146a:	4b10      	ldr	r3, [pc, #64]	; (4014ac <_tx_event_flags_set+0x1f8>)
  40146c:	4798      	blx	r3
    return(TX_SUCCESS);
  40146e:	e738      	b.n	4012e2 <_tx_event_flags_set+0x2e>
            if (group_ptr -> tx_event_flags_group_suspended_count != TX_NO_SUSPENSIONS)
  401470:	b12a      	cbz	r2, 40147e <_tx_event_flags_set+0x1ca>
                group_ptr -> tx_event_flags_group_reset_search =  TX_TRUE;
  401472:	2301      	movs	r3, #1
  401474:	60c3      	str	r3, [r0, #12]
        preempt_check =  TX_FALSE;
  401476:	2600      	movs	r6, #0
  401478:	e7ed      	b.n	401456 <_tx_event_flags_set+0x1a2>
  40147a:	2600      	movs	r6, #0
  40147c:	e7eb      	b.n	401456 <_tx_event_flags_set+0x1a2>
  40147e:	2600      	movs	r6, #0
  401480:	e7e9      	b.n	401456 <_tx_event_flags_set+0x1a2>
                    if (flags_satisfied != ((ULONG) 0))
  401482:	f1bb 0f00 	cmp.w	fp, #0
  401486:	d097      	beq.n	4013b8 <_tx_event_flags_set+0x104>
                            *suspend_info_ptr =  current_event_flags;
  401488:	6fd8      	ldr	r0, [r3, #124]	; 0x7c
  40148a:	6006      	str	r6, [r0, #0]
                            if (clear_request == TX_TRUE)
  40148c:	f01a 0f01 	tst.w	sl, #1
  401490:	d003      	beq.n	40149a <_tx_event_flags_set+0x1e6>
                                group_ptr -> tx_event_flags_group_current =  group_ptr -> tx_event_flags_group_current & ~requested_flags;
  401492:	68a0      	ldr	r0, [r4, #8]
  401494:	ea20 0101 	bic.w	r1, r0, r1
  401498:	60a1      	str	r1, [r4, #8]
                            thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
  40149a:	669f      	str	r7, [r3, #104]	; 0x68
                            thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
  40149c:	f8c3 7084 	str.w	r7, [r3, #132]	; 0x84
  4014a0:	e776      	b.n	401390 <_tx_event_flags_set+0xdc>
  4014a2:	bf00      	nop
  4014a4:	2040058c 	.word	0x2040058c
  4014a8:	004024a5 	.word	0x004024a5
  4014ac:	00402469 	.word	0x00402469

004014b0 <_tx_initialize_high_level>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID    _tx_initialize_high_level(VOID)
{
  4014b0:	b508      	push	{r3, lr}

    /* Initialize the event log, if enabled.  */
    TX_EL_INITIALIZE

    /* Call the thread control initialization function.  */
    _tx_thread_initialize();
  4014b2:	4b0f      	ldr	r3, [pc, #60]	; (4014f0 <_tx_initialize_high_level+0x40>)
  4014b4:	4798      	blx	r3

#ifndef TX_NO_TIMER

    /* Call the timer control initialization function.  */
    _tx_timer_initialize();
  4014b6:	4b0f      	ldr	r3, [pc, #60]	; (4014f4 <_tx_initialize_high_level+0x44>)
  4014b8:	4798      	blx	r3
#endif

#ifndef TX_DISABLE_REDUNDANT_CLEARING

    /* Call the semaphore initialization function.  */
    _tx_semaphore_initialize();
  4014ba:	2300      	movs	r3, #0
  4014bc:	4a0e      	ldr	r2, [pc, #56]	; (4014f8 <_tx_initialize_high_level+0x48>)
  4014be:	6013      	str	r3, [r2, #0]
  4014c0:	4a0e      	ldr	r2, [pc, #56]	; (4014fc <_tx_initialize_high_level+0x4c>)
  4014c2:	6013      	str	r3, [r2, #0]

    /* Call the queue initialization function.  */
    _tx_queue_initialize();
  4014c4:	4a0e      	ldr	r2, [pc, #56]	; (401500 <_tx_initialize_high_level+0x50>)
  4014c6:	6013      	str	r3, [r2, #0]
  4014c8:	4a0e      	ldr	r2, [pc, #56]	; (401504 <_tx_initialize_high_level+0x54>)
  4014ca:	6013      	str	r3, [r2, #0]

    /* Call the event flag initialization function.  */
    _tx_event_flags_initialize();
  4014cc:	4a0e      	ldr	r2, [pc, #56]	; (401508 <_tx_initialize_high_level+0x58>)
  4014ce:	6013      	str	r3, [r2, #0]
  4014d0:	4a0e      	ldr	r2, [pc, #56]	; (40150c <_tx_initialize_high_level+0x5c>)
  4014d2:	6013      	str	r3, [r2, #0]

    /* Call the block pool initialization function.  */
    _tx_block_pool_initialize();
  4014d4:	4a0e      	ldr	r2, [pc, #56]	; (401510 <_tx_initialize_high_level+0x60>)
  4014d6:	6013      	str	r3, [r2, #0]
  4014d8:	4a0e      	ldr	r2, [pc, #56]	; (401514 <_tx_initialize_high_level+0x64>)
  4014da:	6013      	str	r3, [r2, #0]

    /* Call the byte pool initialization function.  */
    _tx_byte_pool_initialize();
  4014dc:	4a0e      	ldr	r2, [pc, #56]	; (401518 <_tx_initialize_high_level+0x68>)
  4014de:	6013      	str	r3, [r2, #0]
  4014e0:	4a0e      	ldr	r2, [pc, #56]	; (40151c <_tx_initialize_high_level+0x6c>)
  4014e2:	6013      	str	r3, [r2, #0]

    /* Call the mutex initialization function.  */
    _tx_mutex_initialize();
  4014e4:	4a0e      	ldr	r2, [pc, #56]	; (401520 <_tx_initialize_high_level+0x70>)
  4014e6:	6013      	str	r3, [r2, #0]
  4014e8:	4a0e      	ldr	r2, [pc, #56]	; (401524 <_tx_initialize_high_level+0x74>)
  4014ea:	6013      	str	r3, [r2, #0]
  4014ec:	bd08      	pop	{r3, pc}
  4014ee:	bf00      	nop
  4014f0:	004022f5 	.word	0x004022f5
  4014f4:	00402855 	.word	0x00402855
  4014f8:	204004d0 	.word	0x204004d0
  4014fc:	204004e0 	.word	0x204004e0
  401500:	204004ec 	.word	0x204004ec
  401504:	204004cc 	.word	0x204004cc
  401508:	204004c0 	.word	0x204004c0
  40150c:	204004e4 	.word	0x204004e4
  401510:	204004e8 	.word	0x204004e8
  401514:	204004dc 	.word	0x204004dc
  401518:	204004d4 	.word	0x204004d4
  40151c:	204004f0 	.word	0x204004f0
  401520:	204004c8 	.word	0x204004c8
  401524:	204004c4 	.word	0x204004c4

00401528 <_tx_initialize_kernel_enter>:
/*                                            added EPK initialization,   */
/*                                            resulting in version 6.1.11 */
/*                                                                        */
/**************************************************************************/
VOID  _tx_initialize_kernel_enter(VOID)
{
  401528:	b510      	push	{r4, lr}

    /* Determine if the compiler has pre-initialized ThreadX.  */
    if (_tx_thread_system_state != TX_INITIALIZE_ALMOST_DONE)
  40152a:	4b0f      	ldr	r3, [pc, #60]	; (401568 <_tx_initialize_kernel_enter+0x40>)
  40152c:	681b      	ldr	r3, [r3, #0]
  40152e:	f113 3f0f 	cmn.w	r3, #252645135	; 0xf0f0f0f
  401532:	d00b      	beq.n	40154c <_tx_initialize_kernel_enter+0x24>
        /* No, the initialization still needs to take place.  */

        /* Ensure that the system state variable is set to indicate
           initialization is in progress.  Note that this variable is
           later used to represent interrupt nesting.  */
        _tx_thread_system_state =  TX_INITIALIZE_IN_PROGRESS;
  401534:	f04f 32f0 	mov.w	r2, #4042322160	; 0xf0f0f0f0
  401538:	4b0b      	ldr	r3, [pc, #44]	; (401568 <_tx_initialize_kernel_enter+0x40>)
  40153a:	601a      	str	r2, [r3, #0]
        /* Call any port specific preprocessing.  */
        TX_PORT_SPECIFIC_PRE_INITIALIZATION

        /* Invoke the low-level initialization to handle all processor specific
           initialization issues.  */
        _tx_initialize_low_level();
  40153c:	4b0b      	ldr	r3, [pc, #44]	; (40156c <_tx_initialize_kernel_enter+0x44>)
  40153e:	4798      	blx	r3

        /* Invoke the high-level initialization to exercise all of the
           ThreadX components and the application's initialization
           function.  */
        _tx_initialize_high_level();
  401540:	4b0b      	ldr	r3, [pc, #44]	; (401570 <_tx_initialize_kernel_enter+0x48>)
  401542:	4798      	blx	r3

        /* Call any port specific post-processing.  */
        TX_PORT_SPECIFIC_POST_INITIALIZATION
  401544:	4a0b      	ldr	r2, [pc, #44]	; (401574 <_tx_initialize_kernel_enter+0x4c>)
  401546:	6813      	ldr	r3, [r2, #0]
  401548:	3301      	adds	r3, #1
  40154a:	6013      	str	r3, [r2, #0]
    TX_INITIALIZE_KERNEL_ENTER_EXTENSION

    /* Ensure that the system state variable is set to indicate
       initialization is in progress.  Note that this variable is
       later used to represent interrupt nesting.  */
    _tx_thread_system_state =  TX_INITIALIZE_IN_PROGRESS;
  40154c:	4c06      	ldr	r4, [pc, #24]	; (401568 <_tx_initialize_kernel_enter+0x40>)
  40154e:	f04f 33f0 	mov.w	r3, #4042322160	; 0xf0f0f0f0
  401552:	6023      	str	r3, [r4, #0]

    /* Call the application provided initialization function.  Pass the
       first available memory address to it.  */
    tx_application_define(_tx_initialize_unused_memory);
  401554:	4b08      	ldr	r3, [pc, #32]	; (401578 <_tx_initialize_kernel_enter+0x50>)
  401556:	6818      	ldr	r0, [r3, #0]
  401558:	4b08      	ldr	r3, [pc, #32]	; (40157c <_tx_initialize_kernel_enter+0x54>)
  40155a:	4798      	blx	r3

    /* Set the system state in preparation for entering the thread
       scheduler.  */
    _tx_thread_system_state =  TX_INITIALIZE_IS_FINISHED;
  40155c:	2300      	movs	r3, #0
  40155e:	6023      	str	r3, [r4, #0]
    /* Initialize Execution Profile Kit.  */
    _tx_execution_initialize();
#endif

    /* Enter the scheduling loop to start executing threads!  */
    _tx_thread_schedule();
  401560:	4b07      	ldr	r3, [pc, #28]	; (401580 <_tx_initialize_kernel_enter+0x58>)
  401562:	4798      	blx	r3
  401564:	bd10      	pop	{r4, pc}
  401566:	bf00      	nop
  401568:	20400000 	.word	0x20400000
  40156c:	00402af1 	.word	0x00402af1
  401570:	004014b1 	.word	0x004014b1
  401574:	2040058c 	.word	0x2040058c
  401578:	204004d8 	.word	0x204004d8
  40157c:	00403055 	.word	0x00403055
  401580:	00402b81 	.word	0x00402b81

00401584 <_tx_mutex_cleanup>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_mutex_cleanup(TX_THREAD  *thread_ptr, ULONG suspension_sequence)
{
  401584:	b510      	push	{r4, lr}
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  401586:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  40158a:	b672      	cpsid	i

    /* Disable interrupts to remove the suspended thread from the mutex.  */
    TX_DISABLE

    /* Determine if the cleanup is still required.  */
    if (thread_ptr -> tx_thread_suspend_cleanup == &(_tx_mutex_cleanup))
  40158c:	6e84      	ldr	r4, [r0, #104]	; 0x68
  40158e:	4a1b      	ldr	r2, [pc, #108]	; (4015fc <_tx_mutex_cleanup+0x78>)
  401590:	4294      	cmp	r4, r2
  401592:	d002      	beq.n	40159a <_tx_mutex_cleanup+0x16>
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  401594:	f383 8810 	msr	PRIMASK, r3
  401598:	bd10      	pop	{r4, pc}
    {

        /* Check for valid suspension sequence.  */
        if (suspension_sequence == thread_ptr -> tx_thread_suspension_sequence)
  40159a:	f8d0 20b0 	ldr.w	r2, [r0, #176]	; 0xb0
  40159e:	428a      	cmp	r2, r1
  4015a0:	d1f8      	bne.n	401594 <_tx_mutex_cleanup+0x10>
        {

            /* Setup pointer to mutex control block.  */
            mutex_ptr =  TX_VOID_TO_MUTEX_POINTER_CONVERT(thread_ptr -> tx_thread_suspend_control_block);
  4015a2:	6ec2      	ldr	r2, [r0, #108]	; 0x6c

            /* Check for NULL mutex pointer.  */
            if (mutex_ptr != TX_NULL)
  4015a4:	2a00      	cmp	r2, #0
  4015a6:	d0f5      	beq.n	401594 <_tx_mutex_cleanup+0x10>
            {

                /* Determine if the mutex ID is valid.  */
                if (mutex_ptr -> tx_mutex_id == TX_MUTEX_ID)
  4015a8:	6814      	ldr	r4, [r2, #0]
  4015aa:	4915      	ldr	r1, [pc, #84]	; (401600 <_tx_mutex_cleanup+0x7c>)
  4015ac:	428c      	cmp	r4, r1
  4015ae:	d1f1      	bne.n	401594 <_tx_mutex_cleanup+0x10>
                {

                    /* Determine if there are any thread suspensions.  */
                    if (mutex_ptr -> tx_mutex_suspended_count != TX_NO_SUSPENSIONS)
  4015b0:	69d1      	ldr	r1, [r2, #28]
  4015b2:	2900      	cmp	r1, #0
  4015b4:	d0ee      	beq.n	401594 <_tx_mutex_cleanup+0x10>
#endif

                        /* Yes, we still have thread suspension!  */

                        /* Clear the suspension cleanup flag.  */
                        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
  4015b6:	2100      	movs	r1, #0
  4015b8:	6681      	str	r1, [r0, #104]	; 0x68

                        /* Decrement the suspension count.  */
                        mutex_ptr -> tx_mutex_suspended_count--;
  4015ba:	69d1      	ldr	r1, [r2, #28]
  4015bc:	3901      	subs	r1, #1
  4015be:	61d1      	str	r1, [r2, #28]
                        suspended_count =  mutex_ptr -> tx_mutex_suspended_count;

                        /* Remove the suspended thread from the list.  */

                        /* See if this is the only suspended thread on the list.  */
                        if (suspended_count == TX_NO_SUSPENSIONS)
  4015c0:	b991      	cbnz	r1, 4015e8 <_tx_mutex_cleanup+0x64>
                        {

                            /* Yes, the only suspended thread.  */

                            /* Update the head pointer.  */
                            mutex_ptr -> tx_mutex_suspension_list =  TX_NULL;
  4015c2:	6191      	str	r1, [r2, #24]
                            }
                        }

                        /* Now we need to determine if this cleanup is from a terminate, timeout,
                           or from a wait abort.  */
                        if (thread_ptr -> tx_thread_state == TX_MUTEX_SUSP)
  4015c4:	6b02      	ldr	r2, [r0, #48]	; 0x30
  4015c6:	2a0d      	cmp	r2, #13
  4015c8:	d1e4      	bne.n	401594 <_tx_mutex_cleanup+0x10>
                            /* Increment the number of timeouts on this semaphore.  */
                            mutex_ptr -> tx_mutex_performance_timeout_count++;
#endif

                            /* Setup return status.  */
                            thread_ptr -> tx_thread_suspend_status =  TX_NOT_AVAILABLE;
  4015ca:	221d      	movs	r2, #29
  4015cc:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84
                            /* Resume the thread!  */
                            _tx_thread_system_ni_resume(thread_ptr);
#else

                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
  4015d0:	490c      	ldr	r1, [pc, #48]	; (401604 <_tx_mutex_cleanup+0x80>)
  4015d2:	680a      	ldr	r2, [r1, #0]
  4015d4:	3201      	adds	r2, #1
  4015d6:	600a      	str	r2, [r1, #0]
  4015d8:	f383 8810 	msr	PRIMASK, r3

                            /* Restore interrupts.  */
                            TX_RESTORE

                            /* Resume the thread!  */
                            _tx_thread_system_resume(thread_ptr);
  4015dc:	4b0a      	ldr	r3, [pc, #40]	; (401608 <_tx_mutex_cleanup+0x84>)
  4015de:	4798      	blx	r3
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  4015e0:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  4015e4:	b672      	cpsid	i
  4015e6:	e7d5      	b.n	401594 <_tx_mutex_cleanup+0x10>
                            next_thread =                                   thread_ptr -> tx_thread_suspended_next;
  4015e8:	6f01      	ldr	r1, [r0, #112]	; 0x70
                            previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
  4015ea:	6f44      	ldr	r4, [r0, #116]	; 0x74
                            next_thread -> tx_thread_suspended_previous =   previous_thread;
  4015ec:	674c      	str	r4, [r1, #116]	; 0x74
                            previous_thread -> tx_thread_suspended_next =   next_thread;
  4015ee:	6721      	str	r1, [r4, #112]	; 0x70
                            if (mutex_ptr -> tx_mutex_suspension_list == thread_ptr)
  4015f0:	6994      	ldr	r4, [r2, #24]
  4015f2:	42a0      	cmp	r0, r4
                                mutex_ptr -> tx_mutex_suspension_list =         next_thread;
  4015f4:	bf08      	it	eq
  4015f6:	6191      	streq	r1, [r2, #24]
  4015f8:	e7e4      	b.n	4015c4 <_tx_mutex_cleanup+0x40>
  4015fa:	bf00      	nop
  4015fc:	00401585 	.word	0x00401585
  401600:	4d555445 	.word	0x4d555445
  401604:	2040058c 	.word	0x2040058c
  401608:	004024a5 	.word	0x004024a5

0040160c <_tx_mutex_thread_release>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_mutex_thread_release(TX_THREAD  *thread_ptr)
{
  40160c:	b570      	push	{r4, r5, r6, lr}
  40160e:	4604      	mov	r4, r0
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  401610:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  401614:	b672      	cpsid	i

    /* Disable interrupts.  */
    TX_DISABLE

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
  401616:	490d      	ldr	r1, [pc, #52]	; (40164c <_tx_mutex_thread_release+0x40>)
  401618:	680a      	ldr	r2, [r1, #0]
  40161a:	3201      	adds	r2, #1
  40161c:	600a      	str	r2, [r1, #0]
        /* Determine if there is a mutex.  */
        if (mutex_ptr != TX_NULL)
        {

            /* Yes, set the ownership count to 1.  */
            mutex_ptr -> tx_mutex_ownership_count =  ((UINT) 1);
  40161e:	2601      	movs	r6, #1
            do
            {
                status =  _tx_mutex_put(mutex_ptr);
            } while (status != TX_SUCCESS);
#else
            _tx_mutex_put(mutex_ptr);
  401620:	4d0b      	ldr	r5, [pc, #44]	; (401650 <_tx_mutex_thread_release+0x44>)
        mutex_ptr =  thread_ptr -> tx_thread_owned_mutex_list;
  401622:	f8d4 00a4 	ldr.w	r0, [r4, #164]	; 0xa4
        if (mutex_ptr != TX_NULL)
  401626:	b150      	cbz	r0, 40163e <_tx_mutex_thread_release+0x32>
            mutex_ptr -> tx_mutex_ownership_count =  ((UINT) 1);
  401628:	6086      	str	r6, [r0, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  40162a:	f383 8810 	msr	PRIMASK, r3
            _tx_mutex_put(mutex_ptr);
  40162e:	47a8      	blx	r5
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  401630:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  401634:	b672      	cpsid	i
            TX_DISABLE

            /* Move to the next mutex.  */
            mutex_ptr =  thread_ptr -> tx_thread_owned_mutex_list;
        }
    } while (mutex_ptr != TX_NULL);
  401636:	f8d4 20a4 	ldr.w	r2, [r4, #164]	; 0xa4
  40163a:	2a00      	cmp	r2, #0
  40163c:	d1f1      	bne.n	401622 <_tx_mutex_thread_release+0x16>

    /* Restore preemption.  */
    _tx_thread_preempt_disable--;
  40163e:	4903      	ldr	r1, [pc, #12]	; (40164c <_tx_mutex_thread_release+0x40>)
  401640:	680a      	ldr	r2, [r1, #0]
  401642:	3a01      	subs	r2, #1
  401644:	600a      	str	r2, [r1, #0]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  401646:	f383 8810 	msr	PRIMASK, r3
  40164a:	bd70      	pop	{r4, r5, r6, pc}
  40164c:	2040058c 	.word	0x2040058c
  401650:	00401949 	.word	0x00401949

00401654 <_tx_mutex_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_mutex_create(TX_MUTEX *mutex_ptr, CHAR *name_ptr, UINT inherit)
{
  401654:	b570      	push	{r4, r5, r6, lr}
  401656:	4604      	mov	r4, r0
  401658:	460e      	mov	r6, r1
  40165a:	4615      	mov	r5, r2
TX_MUTEX        *next_mutex;
TX_MUTEX        *previous_mutex;


    /* Initialize mutex control block to all zeros.  */
    TX_MEMSET(mutex_ptr, 0, (sizeof(TX_MUTEX)));
  40165c:	2234      	movs	r2, #52	; 0x34
  40165e:	2100      	movs	r1, #0
  401660:	4b11      	ldr	r3, [pc, #68]	; (4016a8 <_tx_mutex_create+0x54>)
  401662:	4798      	blx	r3

    /* Setup the basic mutex fields.  */
    mutex_ptr -> tx_mutex_name =             name_ptr;
  401664:	6066      	str	r6, [r4, #4]
    mutex_ptr -> tx_mutex_inherit =          inherit;
  401666:	6125      	str	r5, [r4, #16]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  401668:	f3ef 8110 	mrs	r1, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  40166c:	b672      	cpsid	i

    /* Disable interrupts to place the mutex on the created list.  */
    TX_DISABLE

    /* Setup the mutex ID to make it valid.  */
    mutex_ptr -> tx_mutex_id =  TX_MUTEX_ID;
  40166e:	4b0f      	ldr	r3, [pc, #60]	; (4016ac <_tx_mutex_create+0x58>)
  401670:	6023      	str	r3, [r4, #0]

    /* Setup the thread mutex release function pointer.  */
    _tx_thread_mutex_release =  &(_tx_mutex_thread_release);
  401672:	4a0f      	ldr	r2, [pc, #60]	; (4016b0 <_tx_mutex_create+0x5c>)
  401674:	4b0f      	ldr	r3, [pc, #60]	; (4016b4 <_tx_mutex_create+0x60>)
  401676:	601a      	str	r2, [r3, #0]

    /* Place the mutex on the list of created mutexes.  First,
       check for an empty list.  */
    if (_tx_mutex_created_count == TX_EMPTY)
  401678:	4b0f      	ldr	r3, [pc, #60]	; (4016b8 <_tx_mutex_create+0x64>)
  40167a:	681b      	ldr	r3, [r3, #0]
  40167c:	b173      	cbz	r3, 40169c <_tx_mutex_create+0x48>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_mutex =      _tx_mutex_created_ptr;
  40167e:	4b0f      	ldr	r3, [pc, #60]	; (4016bc <_tx_mutex_create+0x68>)
  401680:	681b      	ldr	r3, [r3, #0]
        previous_mutex =  next_mutex -> tx_mutex_created_previous;
  401682:	6a5a      	ldr	r2, [r3, #36]	; 0x24

        /* Place the new mutex in the list.  */
        next_mutex -> tx_mutex_created_previous =  mutex_ptr;
  401684:	625c      	str	r4, [r3, #36]	; 0x24
        previous_mutex -> tx_mutex_created_next =  mutex_ptr;
  401686:	6214      	str	r4, [r2, #32]

        /* Setup this mutex's next and previous created links.  */
        mutex_ptr -> tx_mutex_created_previous =  previous_mutex;
  401688:	6262      	str	r2, [r4, #36]	; 0x24
        mutex_ptr -> tx_mutex_created_next =      next_mutex;
  40168a:	6223      	str	r3, [r4, #32]
    }

    /* Increment the ownership count.  */
    _tx_mutex_created_count++;
  40168c:	4a0a      	ldr	r2, [pc, #40]	; (4016b8 <_tx_mutex_create+0x64>)
  40168e:	6813      	ldr	r3, [r2, #0]
  401690:	3301      	adds	r3, #1
  401692:	6013      	str	r3, [r2, #0]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  401694:	f381 8810 	msr	PRIMASK, r1
    /* Restore interrupts.  */
    TX_RESTORE

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
}
  401698:	2000      	movs	r0, #0
  40169a:	bd70      	pop	{r4, r5, r6, pc}
        _tx_mutex_created_ptr =                   mutex_ptr;
  40169c:	4b07      	ldr	r3, [pc, #28]	; (4016bc <_tx_mutex_create+0x68>)
  40169e:	601c      	str	r4, [r3, #0]
        mutex_ptr -> tx_mutex_created_next =      mutex_ptr;
  4016a0:	6224      	str	r4, [r4, #32]
        mutex_ptr -> tx_mutex_created_previous =  mutex_ptr;
  4016a2:	6264      	str	r4, [r4, #36]	; 0x24
  4016a4:	e7f2      	b.n	40168c <_tx_mutex_create+0x38>
  4016a6:	bf00      	nop
  4016a8:	00403361 	.word	0x00403361
  4016ac:	4d555445 	.word	0x4d555445
  4016b0:	0040160d 	.word	0x0040160d
  4016b4:	20400574 	.word	0x20400574
  4016b8:	204004c4 	.word	0x204004c4
  4016bc:	204004c8 	.word	0x204004c8

004016c0 <_tx_mutex_get>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_mutex_get(TX_MUTEX *mutex_ptr, ULONG wait_option)
{
  4016c0:	b570      	push	{r4, r5, r6, lr}
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  4016c2:	f3ef 8210 	mrs	r2, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  4016c6:	b672      	cpsid	i

    /* Log this kernel call.  */
    TX_EL_MUTEX_GET_INSERT

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
  4016c8:	4b3c      	ldr	r3, [pc, #240]	; (4017bc <_tx_mutex_get+0xfc>)
  4016ca:	681c      	ldr	r4, [r3, #0]

    /* Determine if this mutex is available.  */
    if (mutex_ptr -> tx_mutex_ownership_count == ((UINT) 0))
  4016cc:	6883      	ldr	r3, [r0, #8]
  4016ce:	bb0b      	cbnz	r3, 401714 <_tx_mutex_get+0x54>
    {

        /* Set the ownership count to 1.  */
        mutex_ptr -> tx_mutex_ownership_count =  ((UINT) 1);
  4016d0:	2301      	movs	r3, #1
  4016d2:	6083      	str	r3, [r0, #8]

        /* Remember that the calling thread owns the mutex.  */
        mutex_ptr -> tx_mutex_owner =  thread_ptr;
  4016d4:	60c4      	str	r4, [r0, #12]

        /* Determine if the thread pointer is valid.  */
        if (thread_ptr != TX_NULL)
  4016d6:	b17c      	cbz	r4, 4016f8 <_tx_mutex_get+0x38>
        {

            /* Determine if priority inheritance is required.  */
            if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
  4016d8:	6903      	ldr	r3, [r0, #16]
  4016da:	2b01      	cmp	r3, #1
  4016dc:	d010      	beq.n	401700 <_tx_mutex_get+0x40>
                /* Setup the highest priority waiting thread.  */
                mutex_ptr -> tx_mutex_highest_priority_waiting =  ((UINT) TX_MAX_PRIORITIES);
            }

            /* Pickup next mutex pointer, which is the head of the list.  */
            next_mutex =  thread_ptr -> tx_thread_owned_mutex_list;
  4016de:	f8d4 30a4 	ldr.w	r3, [r4, #164]	; 0xa4

            /* Determine if this thread owns any other mutexes that have priority inheritance.  */
            if (next_mutex != TX_NULL)
  4016e2:	b193      	cbz	r3, 40170a <_tx_mutex_get+0x4a>
            {

                /* Non-empty list. Link up the mutex.  */

                /* Pickup the next and previous mutex pointer.  */
                previous_mutex =  next_mutex -> tx_mutex_owned_previous;
  4016e4:	6b19      	ldr	r1, [r3, #48]	; 0x30

                /* Place the owned mutex in the list.  */
                next_mutex -> tx_mutex_owned_previous =  mutex_ptr;
  4016e6:	6318      	str	r0, [r3, #48]	; 0x30
                previous_mutex -> tx_mutex_owned_next =  mutex_ptr;
  4016e8:	62c8      	str	r0, [r1, #44]	; 0x2c

                /* Setup this mutex's next and previous created links.  */
                mutex_ptr -> tx_mutex_owned_previous =  previous_mutex;
  4016ea:	6301      	str	r1, [r0, #48]	; 0x30
                mutex_ptr -> tx_mutex_owned_next =      next_mutex;
  4016ec:	62c3      	str	r3, [r0, #44]	; 0x2c
                mutex_ptr -> tx_mutex_owned_next =             mutex_ptr;
                mutex_ptr -> tx_mutex_owned_previous =         mutex_ptr;
            }

            /* Increment the number of mutexes owned counter.  */
            thread_ptr -> tx_thread_owned_mutex_count++;
  4016ee:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
  4016f2:	3301      	adds	r3, #1
  4016f4:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  4016f8:	f382 8810 	msr	PRIMASK, r2

        /* Restore interrupts.  */
        TX_RESTORE

        /* Return success.  */
        status =  TX_SUCCESS;
  4016fc:	2000      	movs	r0, #0
  4016fe:	bd70      	pop	{r4, r5, r6, pc}
                mutex_ptr -> tx_mutex_original_priority =   thread_ptr -> tx_thread_priority;
  401700:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  401702:	6143      	str	r3, [r0, #20]
                mutex_ptr -> tx_mutex_highest_priority_waiting =  ((UINT) TX_MAX_PRIORITIES);
  401704:	2320      	movs	r3, #32
  401706:	6283      	str	r3, [r0, #40]	; 0x28
  401708:	e7e9      	b.n	4016de <_tx_mutex_get+0x1e>
                thread_ptr -> tx_thread_owned_mutex_list =     mutex_ptr;
  40170a:	f8c4 00a4 	str.w	r0, [r4, #164]	; 0xa4
                mutex_ptr -> tx_mutex_owned_next =             mutex_ptr;
  40170e:	62c0      	str	r0, [r0, #44]	; 0x2c
                mutex_ptr -> tx_mutex_owned_previous =         mutex_ptr;
  401710:	6300      	str	r0, [r0, #48]	; 0x30
  401712:	e7ec      	b.n	4016ee <_tx_mutex_get+0x2e>
    }

    /* Otherwise, see if the owning thread is trying to obtain the same mutex.  */
    else if (mutex_ptr -> tx_mutex_owner == thread_ptr)
  401714:	68c5      	ldr	r5, [r0, #12]
  401716:	42ac      	cmp	r4, r5
  401718:	d004      	beq.n	401724 <_tx_mutex_get+0x64>
    }
    else
    {

        /* Determine if the request specifies suspension.  */
        if (wait_option != TX_NO_WAIT)
  40171a:	b949      	cbnz	r1, 401730 <_tx_mutex_get+0x70>
  40171c:	f382 8810 	msr	PRIMASK, r2

            /* Restore interrupts.  */
            TX_RESTORE

            /* Immediate return, return error completion.  */
            status =  TX_NOT_AVAILABLE;
  401720:	201d      	movs	r0, #29
        }
    }

    /* Return completion status.  */
    return(status);
}
  401722:	bd70      	pop	{r4, r5, r6, pc}
        mutex_ptr -> tx_mutex_ownership_count++;
  401724:	3301      	adds	r3, #1
  401726:	6083      	str	r3, [r0, #8]
  401728:	f382 8810 	msr	PRIMASK, r2
        status =  TX_SUCCESS;
  40172c:	2000      	movs	r0, #0
  40172e:	bd70      	pop	{r4, r5, r6, pc}
            if (_tx_thread_preempt_disable != ((UINT) 0))
  401730:	4b23      	ldr	r3, [pc, #140]	; (4017c0 <_tx_mutex_get+0x100>)
  401732:	681b      	ldr	r3, [r3, #0]
  401734:	b11b      	cbz	r3, 40173e <_tx_mutex_get+0x7e>
  401736:	f382 8810 	msr	PRIMASK, r2
                status =  TX_NOT_AVAILABLE;
  40173a:	201d      	movs	r0, #29
  40173c:	bd70      	pop	{r4, r5, r6, pc}
                thread_ptr -> tx_thread_suspend_cleanup =  &(_tx_mutex_cleanup);
  40173e:	4b21      	ldr	r3, [pc, #132]	; (4017c4 <_tx_mutex_get+0x104>)
  401740:	66a3      	str	r3, [r4, #104]	; 0x68
                thread_ptr -> tx_thread_suspend_control_block =  (VOID *) mutex_ptr;
  401742:	66e0      	str	r0, [r4, #108]	; 0x6c
                thread_ptr -> tx_thread_suspension_sequence++;
  401744:	f8d4 30b0 	ldr.w	r3, [r4, #176]	; 0xb0
  401748:	3301      	adds	r3, #1
  40174a:	f8c4 30b0 	str.w	r3, [r4, #176]	; 0xb0
                if (mutex_ptr -> tx_mutex_suspended_count == TX_NO_SUSPENSIONS)
  40174e:	69c3      	ldr	r3, [r0, #28]
  401750:	b9cb      	cbnz	r3, 401786 <_tx_mutex_get+0xc6>
                    mutex_ptr -> tx_mutex_suspension_list =         thread_ptr;
  401752:	6184      	str	r4, [r0, #24]
                    thread_ptr -> tx_thread_suspended_next =        thread_ptr;
  401754:	6724      	str	r4, [r4, #112]	; 0x70
                    thread_ptr -> tx_thread_suspended_previous =    thread_ptr;
  401756:	6764      	str	r4, [r4, #116]	; 0x74
                mutex_ptr -> tx_mutex_suspended_count++;
  401758:	69c3      	ldr	r3, [r0, #28]
  40175a:	3301      	adds	r3, #1
  40175c:	61c3      	str	r3, [r0, #28]
                thread_ptr -> tx_thread_state =    TX_MUTEX_SUSP;
  40175e:	230d      	movs	r3, #13
  401760:	6323      	str	r3, [r4, #48]	; 0x30
                thread_ptr -> tx_thread_suspending =  TX_TRUE;
  401762:	2301      	movs	r3, #1
  401764:	63a3      	str	r3, [r4, #56]	; 0x38
                thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
  401766:	64e1      	str	r1, [r4, #76]	; 0x4c
                _tx_thread_preempt_disable++;
  401768:	4915      	ldr	r1, [pc, #84]	; (4017c0 <_tx_mutex_get+0x100>)
  40176a:	680b      	ldr	r3, [r1, #0]
  40176c:	3301      	adds	r3, #1
  40176e:	600b      	str	r3, [r1, #0]
  401770:	f382 8810 	msr	PRIMASK, r2
                if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
  401774:	6903      	ldr	r3, [r0, #16]
  401776:	2b01      	cmp	r3, #1
  401778:	d00c      	beq.n	401794 <_tx_mutex_get+0xd4>
                _tx_thread_system_suspend(thread_ptr);
  40177a:	4620      	mov	r0, r4
  40177c:	4b12      	ldr	r3, [pc, #72]	; (4017c8 <_tx_mutex_get+0x108>)
  40177e:	4798      	blx	r3
                status =  thread_ptr -> tx_thread_suspend_status;
  401780:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
  401784:	bd70      	pop	{r4, r5, r6, pc}
                    next_thread =                                   mutex_ptr -> tx_mutex_suspension_list;
  401786:	6983      	ldr	r3, [r0, #24]
                    thread_ptr -> tx_thread_suspended_next =        next_thread;
  401788:	6723      	str	r3, [r4, #112]	; 0x70
                    previous_thread =                               next_thread -> tx_thread_suspended_previous;
  40178a:	6f5e      	ldr	r6, [r3, #116]	; 0x74
                    thread_ptr -> tx_thread_suspended_previous =    previous_thread;
  40178c:	6766      	str	r6, [r4, #116]	; 0x74
                    previous_thread -> tx_thread_suspended_next =   thread_ptr;
  40178e:	6734      	str	r4, [r6, #112]	; 0x70
                    next_thread -> tx_thread_suspended_previous =   thread_ptr;
  401790:	675c      	str	r4, [r3, #116]	; 0x74
  401792:	e7e1      	b.n	401758 <_tx_mutex_get+0x98>
                    if (mutex_ptr -> tx_mutex_highest_priority_waiting > thread_ptr -> tx_thread_priority)
  401794:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  401796:	6a82      	ldr	r2, [r0, #40]	; 0x28
  401798:	429a      	cmp	r2, r3
                        mutex_ptr -> tx_mutex_highest_priority_waiting =  thread_ptr -> tx_thread_priority;
  40179a:	bf88      	it	hi
  40179c:	6283      	strhi	r3, [r0, #40]	; 0x28
                    if (thread_ptr -> tx_thread_priority < mutex_owner -> tx_thread_inherit_priority)
  40179e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  4017a0:	f8d5 209c 	ldr.w	r2, [r5, #156]	; 0x9c
  4017a4:	4293      	cmp	r3, r2
                        mutex_owner -> tx_thread_inherit_priority =  thread_ptr -> tx_thread_priority;
  4017a6:	bf38      	it	cc
  4017a8:	f8c5 309c 	strcc.w	r3, [r5, #156]	; 0x9c
                    if (mutex_owner -> tx_thread_priority > thread_ptr -> tx_thread_priority)
  4017ac:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
  4017ae:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
  4017b0:	428b      	cmp	r3, r1
  4017b2:	d9e2      	bls.n	40177a <_tx_mutex_get+0xba>
                        _tx_mutex_priority_change(mutex_owner, thread_ptr -> tx_thread_priority);
  4017b4:	4628      	mov	r0, r5
  4017b6:	4b05      	ldr	r3, [pc, #20]	; (4017cc <_tx_mutex_get+0x10c>)
  4017b8:	4798      	blx	r3
  4017ba:	e7de      	b.n	40177a <_tx_mutex_get+0xba>
  4017bc:	20400590 	.word	0x20400590
  4017c0:	2040058c 	.word	0x2040058c
  4017c4:	00401585 	.word	0x00401585
  4017c8:	004025d9 	.word	0x004025d9
  4017cc:	00401871 	.word	0x00401871

004017d0 <_tx_mutex_prioritize>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_mutex_prioritize(TX_MUTEX *mutex_ptr)
{
  4017d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  4017d2:	f3ef 8410 	mrs	r4, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  4017d6:	b672      	cpsid	i

    /* Log this kernel call.  */
    TX_EL_MUTEX_PRIORITIZE_INSERT

    /* Pickup the suspended count.  */
    suspended_count =  mutex_ptr -> tx_mutex_suspended_count;
  4017d8:	69c7      	ldr	r7, [r0, #28]

    /* Determine if there are fewer than 2 suspended threads.  */
    if (suspended_count < ((UINT) 2))
  4017da:	2f01      	cmp	r7, #1
  4017dc:	d909      	bls.n	4017f2 <_tx_mutex_prioritize+0x22>
        /* Restore interrupts.  */
        TX_RESTORE
    }

    /* Determine if there how many threads are suspended on this mutex.  */
    else if (suspended_count == ((UINT) 2))
  4017de:	2f02      	cmp	r7, #2
  4017e0:	d00a      	beq.n	4017f8 <_tx_mutex_prioritize+0x28>
    }
    else
    {

        /* Remember the suspension count and head pointer.  */
        head_ptr =   mutex_ptr -> tx_mutex_suspension_list;
  4017e2:	6981      	ldr	r1, [r0, #24]

        /* Default the highest priority thread to the thread at the front of the list.  */
        priority_thread_ptr =  head_ptr;

        /* Setup search pointer.  */
        thread_ptr =  priority_thread_ptr -> tx_thread_suspended_next;
  4017e4:	6f0a      	ldr	r2, [r1, #112]	; 0x70

        /* Disable preemption.  */
        _tx_thread_preempt_disable++;
  4017e6:	4d20      	ldr	r5, [pc, #128]	; (401868 <_tx_mutex_prioritize+0x98>)
  4017e8:	682b      	ldr	r3, [r5, #0]
  4017ea:	3301      	adds	r3, #1
  4017ec:	602b      	str	r3, [r5, #0]
        head_ptr =   mutex_ptr -> tx_mutex_suspension_list;
  4017ee:	460d      	mov	r5, r1
  4017f0:	e013      	b.n	40181a <_tx_mutex_prioritize+0x4a>
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  4017f2:	f384 8810 	msr	PRIMASK, r4
  4017f6:	e035      	b.n	401864 <_tx_mutex_prioritize+0x94>
        head_ptr =  mutex_ptr -> tx_mutex_suspension_list;
  4017f8:	6983      	ldr	r3, [r0, #24]
        next_thread =  head_ptr -> tx_thread_suspended_next;
  4017fa:	6f1a      	ldr	r2, [r3, #112]	; 0x70
        if ((next_thread -> tx_thread_priority) < (head_ptr -> tx_thread_priority))
  4017fc:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
  4017fe:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  401800:	4299      	cmp	r1, r3
            mutex_ptr -> tx_mutex_suspension_list =  next_thread;
  401802:	bf38      	it	cc
  401804:	6182      	strcc	r2, [r0, #24]
  401806:	f384 8810 	msr	PRIMASK, r4
  40180a:	e02b      	b.n	401864 <_tx_mutex_prioritize+0x94>
            }
            else
            {

                /* Is the suspended count the same?  */
                if (suspended_count != mutex_ptr -> tx_mutex_suspended_count)
  40180c:	69c5      	ldr	r5, [r0, #28]
  40180e:	42af      	cmp	r7, r5
  401810:	d110      	bne.n	401834 <_tx_mutex_prioritize+0x64>
            /* Determine if the list has changed.  */
            if (list_changed == TX_FALSE)
            {

                /* Move the thread pointer to the next thread.  */
                thread_ptr =  thread_ptr -> tx_thread_suspended_next;
  401812:	6f12      	ldr	r2, [r2, #112]	; 0x70
  401814:	461d      	mov	r5, r3

                /* Reset the list changed flag.  */
                list_changed =  TX_FALSE;
            }

        } while (thread_ptr != head_ptr);
  401816:	429a      	cmp	r2, r3
  401818:	d010      	beq.n	40183c <_tx_mutex_prioritize+0x6c>
            if (thread_ptr -> tx_thread_priority < priority_thread_ptr -> tx_thread_priority)
  40181a:	6ad6      	ldr	r6, [r2, #44]	; 0x2c
  40181c:	6acb      	ldr	r3, [r1, #44]	; 0x2c
                priority_thread_ptr =  thread_ptr;
  40181e:	429e      	cmp	r6, r3
  401820:	bf38      	it	cc
  401822:	4611      	movcc	r1, r2
  401824:	f384 8810 	msr	PRIMASK, r4
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  401828:	f3ef 8410 	mrs	r4, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  40182c:	b672      	cpsid	i
            if (head_ptr != mutex_ptr -> tx_mutex_suspension_list)
  40182e:	6983      	ldr	r3, [r0, #24]
  401830:	429d      	cmp	r5, r3
  401832:	d0eb      	beq.n	40180c <_tx_mutex_prioritize+0x3c>
                suspended_count =  mutex_ptr -> tx_mutex_suspended_count;
  401834:	69c7      	ldr	r7, [r0, #28]
                thread_ptr =  priority_thread_ptr -> tx_thread_suspended_next;
  401836:	6f1a      	ldr	r2, [r3, #112]	; 0x70
                priority_thread_ptr =  head_ptr;
  401838:	4619      	mov	r1, r3
  40183a:	e7eb      	b.n	401814 <_tx_mutex_prioritize+0x44>

        /* Release preemption.  */
        _tx_thread_preempt_disable--;
  40183c:	4d0a      	ldr	r5, [pc, #40]	; (401868 <_tx_mutex_prioritize+0x98>)
  40183e:	682b      	ldr	r3, [r5, #0]
  401840:	3b01      	subs	r3, #1
  401842:	602b      	str	r3, [r5, #0]

        /* Now determine if the highest priority thread is at the front
           of the list.  */
        if (priority_thread_ptr != head_ptr)
  401844:	428a      	cmp	r2, r1
  401846:	d009      	beq.n	40185c <_tx_mutex_prioritize+0x8c>
            /* No, we need to move the highest priority suspended thread to the
               front of the list.  */

            /* First, remove the highest priority thread by updating the
               adjacent suspended threads.  */
            next_thread =                                  priority_thread_ptr -> tx_thread_suspended_next;
  401848:	6f0d      	ldr	r5, [r1, #112]	; 0x70
            previous_thread =                              priority_thread_ptr -> tx_thread_suspended_previous;
  40184a:	6f4b      	ldr	r3, [r1, #116]	; 0x74
            next_thread -> tx_thread_suspended_previous =  previous_thread;
  40184c:	676b      	str	r3, [r5, #116]	; 0x74
            previous_thread -> tx_thread_suspended_next =  next_thread;
  40184e:	671d      	str	r5, [r3, #112]	; 0x70

            /* Now, link the highest priority thread at the front of the list.  */
            previous_thread =                                      head_ptr -> tx_thread_suspended_previous;
  401850:	6f53      	ldr	r3, [r2, #116]	; 0x74
            priority_thread_ptr -> tx_thread_suspended_next =      head_ptr;
  401852:	670a      	str	r2, [r1, #112]	; 0x70
            priority_thread_ptr -> tx_thread_suspended_previous =  previous_thread;
  401854:	674b      	str	r3, [r1, #116]	; 0x74
            previous_thread -> tx_thread_suspended_next =          priority_thread_ptr;
  401856:	6719      	str	r1, [r3, #112]	; 0x70
            head_ptr -> tx_thread_suspended_previous =             priority_thread_ptr;
  401858:	6751      	str	r1, [r2, #116]	; 0x74

            /* Move the list head pointer to the highest priority suspended thread.  */
            mutex_ptr -> tx_mutex_suspension_list =  priority_thread_ptr;
  40185a:	6181      	str	r1, [r0, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  40185c:	f384 8810 	msr	PRIMASK, r4

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
  401860:	4b02      	ldr	r3, [pc, #8]	; (40186c <_tx_mutex_prioritize+0x9c>)
  401862:	4798      	blx	r3
#else

    /* Return successful completion.  */
    return(TX_SUCCESS);
#endif
}
  401864:	2000      	movs	r0, #0
  401866:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  401868:	2040058c 	.word	0x2040058c
  40186c:	00402469 	.word	0x00402469

00401870 <_tx_mutex_priority_change>:
/*                                            priority rather than next,  */
/*                                            resulting in version 6.1.6  */
/*                                                                        */
/**************************************************************************/
VOID  _tx_mutex_priority_change(TX_THREAD *thread_ptr, UINT new_priority)
{
  401870:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  401872:	f3ef 8210 	mrs	r2, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  401876:	b672      	cpsid	i
    /* Lockout interrupts while the thread is being suspended.  */
    TX_DISABLE
#endif

    /* Determine if this thread is currently ready.  */
    if (thread_ptr -> tx_thread_state != TX_READY)
  401878:	6b03      	ldr	r3, [r0, #48]	; 0x30
  40187a:	b14b      	cbz	r3, 401890 <_tx_mutex_priority_change+0x20>
    {

        /* Change thread priority to the new mutex priority-inheritance priority.  */
        thread_ptr -> tx_thread_priority =  new_priority;
  40187c:	62c1      	str	r1, [r0, #44]	; 0x2c

        /* Determine how to setup the thread's preemption-threshold.  */
        if (thread_ptr -> tx_thread_user_preempt_threshold < new_priority)
  40187e:	f8d0 3098 	ldr.w	r3, [r0, #152]	; 0x98
        {

            /* Change thread preemption-threshold to the user's preemption-threshold.  */
            thread_ptr -> tx_thread_preempt_threshold =  thread_ptr -> tx_thread_user_preempt_threshold;
  401882:	428b      	cmp	r3, r1
  401884:	bf28      	it	cs
  401886:	460b      	movcs	r3, r1
  401888:	63c3      	str	r3, [r0, #60]	; 0x3c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  40188a:	f382 8810 	msr	PRIMASK, r2
  40188e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  401890:	460d      	mov	r5, r1
  401892:	4604      	mov	r4, r0
    }
    else
    {

        /* Pickup the next thread to execute.  */
        execute_ptr =  _tx_thread_execute_ptr;
  401894:	4b26      	ldr	r3, [pc, #152]	; (401930 <_tx_mutex_priority_change+0xc0>)
  401896:	681e      	ldr	r6, [r3, #0]

        /* Save the original priority.  */
        original_priority =  thread_ptr -> tx_thread_priority;
  401898:	6ac7      	ldr	r7, [r0, #44]	; 0x2c
        /* Decrement the preempt disable flag.  */
        _tx_thread_preempt_disable--;
#else

        /* Increment the preempt disable flag.  */
        _tx_thread_preempt_disable =  _tx_thread_preempt_disable + ((UINT) 2);
  40189a:	4926      	ldr	r1, [pc, #152]	; (401934 <_tx_mutex_priority_change+0xc4>)
  40189c:	680b      	ldr	r3, [r1, #0]
  40189e:	3302      	adds	r3, #2
  4018a0:	600b      	str	r3, [r1, #0]

        /* Set the state to priority change.  */
        thread_ptr -> tx_thread_state =    TX_PRIORITY_CHANGE;
  4018a2:	230e      	movs	r3, #14
  4018a4:	6303      	str	r3, [r0, #48]	; 0x30

        /* Set the suspending flag. */
        thread_ptr -> tx_thread_suspending =  TX_TRUE;
  4018a6:	2301      	movs	r3, #1
  4018a8:	6383      	str	r3, [r0, #56]	; 0x38

        /* Setup the timeout period.  */
        thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  ((ULONG) 0);
  4018aa:	2300      	movs	r3, #0
  4018ac:	64c3      	str	r3, [r0, #76]	; 0x4c
  4018ae:	f382 8810 	msr	PRIMASK, r2
        /* Restore interrupts.  */
        TX_RESTORE

        /* The thread is ready and must first be removed from the list.  Call the
           system suspend function to accomplish this.  */
        _tx_thread_system_suspend(thread_ptr);
  4018b2:	4b21      	ldr	r3, [pc, #132]	; (401938 <_tx_mutex_priority_change+0xc8>)
  4018b4:	4798      	blx	r3
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  4018b6:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  4018ba:	b672      	cpsid	i

        /* At this point, the preempt disable flag is still set, so we still have
           protection against all preemption.  */

        /* Change thread priority to the new mutex priority-inheritance priority.  */
        thread_ptr -> tx_thread_priority =  new_priority;
  4018bc:	62e5      	str	r5, [r4, #44]	; 0x2c

        /* Determine how to setup the thread's preemption-threshold.  */
        if (thread_ptr -> tx_thread_user_preempt_threshold < new_priority)
  4018be:	f8d4 2098 	ldr.w	r2, [r4, #152]	; 0x98
        {

            /* Change thread preemption-threshold to the user's preemption-threshold.  */
            thread_ptr -> tx_thread_preempt_threshold =  thread_ptr -> tx_thread_user_preempt_threshold;
  4018c2:	42aa      	cmp	r2, r5
  4018c4:	bf28      	it	cs
  4018c6:	462a      	movcs	r2, r5
  4018c8:	63e2      	str	r2, [r4, #60]	; 0x3c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  4018ca:	f383 8810 	msr	PRIMASK, r3

        /* Restore interrupts.  */
        TX_RESTORE

        /* Resume the thread with the new priority.  */
        _tx_thread_system_resume(thread_ptr);
  4018ce:	4620      	mov	r0, r4
  4018d0:	4b1a      	ldr	r3, [pc, #104]	; (40193c <_tx_mutex_priority_change+0xcc>)
  4018d2:	4798      	blx	r3
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  4018d4:	f3ef 8210 	mrs	r2, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  4018d8:	b672      	cpsid	i
        /* Disable interrupts.  */
        TX_DISABLE
#endif

        /* Pickup the next thread to execute.  */
        next_execute_ptr =  _tx_thread_execute_ptr;
  4018da:	4b15      	ldr	r3, [pc, #84]	; (401930 <_tx_mutex_priority_change+0xc0>)
  4018dc:	681b      	ldr	r3, [r3, #0]

        /* Determine if this thread is not the next thread to execute.  */
        if (thread_ptr != next_execute_ptr)
  4018de:	429c      	cmp	r4, r3
  4018e0:	d007      	beq.n	4018f2 <_tx_mutex_priority_change+0x82>
        {

            /* Make sure the thread is still ready.  */
            if (thread_ptr -> tx_thread_state == TX_READY)
  4018e2:	6b21      	ldr	r1, [r4, #48]	; 0x30
  4018e4:	b929      	cbnz	r1, 4018f2 <_tx_mutex_priority_change+0x82>
            {

                /* Now check and see if this thread has an equal or higher priority.  */
                if (thread_ptr -> tx_thread_priority <= next_execute_ptr -> tx_thread_priority)
  4018e6:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
  4018e8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4018ea:	4299      	cmp	r1, r3
  4018ec:	d80c      	bhi.n	401908 <_tx_mutex_priority_change+0x98>
                {

                    /* Now determine if this thread was the previously executing thread.  */
                    if (thread_ptr == execute_ptr)
  4018ee:	42b4      	cmp	r4, r6
  4018f0:	d002      	beq.n	4018f8 <_tx_mutex_priority_change+0x88>
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  4018f2:	f382 8810 	msr	PRIMASK, r2
  4018f6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

                        /* Yes, this thread was previously executing before we temporarily suspended and resumed
                           it in order to change the priority. A lower or same priority thread cannot be the next thread
                           to execute in this case since this thread really didn't suspend.  Simply reset the execute
                           pointer to this thread.  */
                        _tx_thread_execute_ptr =  thread_ptr;
  4018f8:	4b0d      	ldr	r3, [pc, #52]	; (401930 <_tx_mutex_priority_change+0xc0>)
  4018fa:	601c      	str	r4, [r3, #0]

                        /* Determine if we moved to a lower priority. If so, move the thread to the front of its priority list.  */
                        if (original_priority < new_priority)
  4018fc:	42bd      	cmp	r5, r7
  4018fe:	d9f8      	bls.n	4018f2 <_tx_mutex_priority_change+0x82>
                        {

                            /* Ensure that this thread is placed at the front of the priority list.  */
                            _tx_thread_priority_list[thread_ptr -> tx_thread_priority] =  thread_ptr;
  401900:	4b0f      	ldr	r3, [pc, #60]	; (401940 <_tx_mutex_priority_change+0xd0>)
  401902:	f843 4021 	str.w	r4, [r3, r1, lsl #2]
  401906:	e7f4      	b.n	4018f2 <_tx_mutex_priority_change+0x82>
                }
                else
                {

                    /* Now determine if this thread's preemption-threshold needs to be enforced.  */
                    if (thread_ptr -> tx_thread_preempt_threshold < thread_ptr -> tx_thread_priority)
  401908:	6be0      	ldr	r0, [r4, #60]	; 0x3c
  40190a:	4281      	cmp	r1, r0
  40190c:	d9f1      	bls.n	4018f2 <_tx_mutex_priority_change+0x82>
                    {

                        /* Yes, preemption-threshold is in force for this thread. */

                        /* Compare the next thread to execute thread's priority against the thread's preemption-threshold.  */
                        if (thread_ptr -> tx_thread_preempt_threshold <= next_execute_ptr -> tx_thread_priority)
  40190e:	4283      	cmp	r3, r0
  401910:	d307      	bcc.n	401922 <_tx_mutex_priority_change+0xb2>
                        {

                            /* We must swap execute pointers to enforce the preemption-threshold of a thread coming out of
                               priority inheritance.  */
                            _tx_thread_execute_ptr =  thread_ptr;
  401912:	4b07      	ldr	r3, [pc, #28]	; (401930 <_tx_mutex_priority_change+0xc0>)
  401914:	601c      	str	r4, [r3, #0]

                            /* Determine if we moved to a lower priority. If so, move the thread to the front of its priority list.  */
                            if (original_priority < new_priority)
  401916:	42bd      	cmp	r5, r7
  401918:	d9eb      	bls.n	4018f2 <_tx_mutex_priority_change+0x82>
                            {

                                /* Ensure that this thread is placed at the front of the priority list.  */
                                _tx_thread_priority_list[thread_ptr -> tx_thread_priority] =  thread_ptr;
  40191a:	4b09      	ldr	r3, [pc, #36]	; (401940 <_tx_mutex_priority_change+0xd0>)
  40191c:	f843 4021 	str.w	r4, [r3, r1, lsl #2]
  401920:	e7e7      	b.n	4018f2 <_tx_mutex_priority_change+0x82>
                            _tx_thread_preempted_map_active =  _tx_thread_preempted_map_active | priority_bit;
#endif

                            /* Remember that this thread was preempted by a thread above the thread's threshold.  */
                            TX_MOD32_BIT_SET(thread_ptr -> tx_thread_priority, priority_bit)
                            _tx_thread_preempted_maps[MAP_INDEX] =  _tx_thread_preempted_maps[MAP_INDEX] | priority_bit;
  401922:	4808      	ldr	r0, [pc, #32]	; (401944 <_tx_mutex_priority_change+0xd4>)
                            TX_MOD32_BIT_SET(thread_ptr -> tx_thread_priority, priority_bit)
  401924:	2301      	movs	r3, #1
  401926:	408b      	lsls	r3, r1
                            _tx_thread_preempted_maps[MAP_INDEX] =  _tx_thread_preempted_maps[MAP_INDEX] | priority_bit;
  401928:	6801      	ldr	r1, [r0, #0]
  40192a:	430b      	orrs	r3, r1
  40192c:	6003      	str	r3, [r0, #0]
  40192e:	e7e0      	b.n	4018f2 <_tx_mutex_priority_change+0x82>
  401930:	20400594 	.word	0x20400594
  401934:	2040058c 	.word	0x2040058c
  401938:	004025d9 	.word	0x004025d9
  40193c:	004024a5 	.word	0x004024a5
  401940:	204004f4 	.word	0x204004f4
  401944:	2040059c 	.word	0x2040059c

00401948 <_tx_mutex_put>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_mutex_put(TX_MUTEX *mutex_ptr)
{
  401948:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  40194a:	f3ef 8210 	mrs	r2, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  40194e:	b672      	cpsid	i

    /* Log this kernel call.  */
    TX_EL_MUTEX_PUT_INSERT

    /* Determine if this mutex is owned.  */
    if (mutex_ptr -> tx_mutex_ownership_count != ((UINT) 0))
  401950:	6883      	ldr	r3, [r0, #8]
  401952:	b91b      	cbnz	r3, 40195c <_tx_mutex_put+0x14>
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  401954:	f382 8810 	msr	PRIMASK, r2

        /* Restore interrupts.  */
        TX_RESTORE

        /* Caller does not own the mutex.  */
        status =  TX_NOT_OWNED;
  401958:	201e      	movs	r0, #30
    }

    /* Return the completion status.  */
    return(status);
  40195a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        thread_ptr =  mutex_ptr -> tx_mutex_owner;
  40195c:	68c1      	ldr	r1, [r0, #12]
        TX_THREAD_GET_CURRENT(current_thread)
  40195e:	4c7f      	ldr	r4, [pc, #508]	; (401b5c <_tx_mutex_put+0x214>)
        if (mutex_ptr -> tx_mutex_owner != current_thread)
  401960:	6824      	ldr	r4, [r4, #0]
  401962:	42a1      	cmp	r1, r4
  401964:	f000 80af 	beq.w	401ac6 <_tx_mutex_put+0x17e>
            if (_tx_thread_preempt_disable == ((UINT) 0))
  401968:	4c7d      	ldr	r4, [pc, #500]	; (401b60 <_tx_mutex_put+0x218>)
  40196a:	6824      	ldr	r4, [r4, #0]
  40196c:	2c00      	cmp	r4, #0
  40196e:	f040 80aa 	bne.w	401ac6 <_tx_mutex_put+0x17e>
  401972:	f382 8810 	msr	PRIMASK, r2
                status =  TX_NOT_OWNED;
  401976:	201e      	movs	r0, #30
  401978:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40197a:	f382 8810 	msr	PRIMASK, r2
                status =  TX_SUCCESS;
  40197e:	2000      	movs	r0, #0
  401980:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  401982:	f382 8810 	msr	PRIMASK, r2
                    status =  TX_SUCCESS;
  401986:	2000      	movs	r0, #0
  401988:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                        next_mutex =                             mutex_ptr -> tx_mutex_owned_next;
  40198a:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
                        previous_mutex =                         mutex_ptr -> tx_mutex_owned_previous;
  40198c:	6b04      	ldr	r4, [r0, #48]	; 0x30
                        next_mutex -> tx_mutex_owned_previous =  previous_mutex;
  40198e:	631c      	str	r4, [r3, #48]	; 0x30
                        previous_mutex -> tx_mutex_owned_next =  next_mutex;
  401990:	62e3      	str	r3, [r4, #44]	; 0x2c
                        if (thread_ptr -> tx_thread_owned_mutex_list == mutex_ptr)
  401992:	f8d1 40a4 	ldr.w	r4, [r1, #164]	; 0xa4
  401996:	42a0      	cmp	r0, r4
                            thread_ptr -> tx_thread_owned_mutex_list =  next_mutex;
  401998:	bf08      	it	eq
  40199a:	f8c1 30a4 	streq.w	r3, [r1, #164]	; 0xa4
  40199e:	e0a4      	b.n	401aea <_tx_mutex_put+0x1a2>
                        if (mutex_ptr -> tx_mutex_inherit == TX_FALSE)
  4019a0:	6903      	ldr	r3, [r0, #16]
  4019a2:	2b00      	cmp	r3, #0
  4019a4:	f040 80a5 	bne.w	401af2 <_tx_mutex_put+0x1aa>
                            mutex_ptr -> tx_mutex_owner =  TX_NULL;
  4019a8:	60c3      	str	r3, [r0, #12]
  4019aa:	f382 8810 	msr	PRIMASK, r2
                            status =  TX_SUCCESS;
  4019ae:	4618      	mov	r0, r3
  4019b0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                            _tx_thread_preempt_disable++;
  4019b2:	486b      	ldr	r0, [pc, #428]	; (401b60 <_tx_mutex_put+0x218>)
  4019b4:	6803      	ldr	r3, [r0, #0]
  4019b6:	3301      	adds	r3, #1
  4019b8:	6003      	str	r3, [r0, #0]
  4019ba:	f382 8810 	msr	PRIMASK, r2
                            next_mutex =  thread_ptr -> tx_thread_owned_mutex_list;
  4019be:	f8d1 00a4 	ldr.w	r0, [r1, #164]	; 0xa4
                            while (next_mutex != TX_NULL)
  4019c2:	b170      	cbz	r0, 4019e2 <_tx_mutex_put+0x9a>
  4019c4:	4603      	mov	r3, r0
  4019c6:	2520      	movs	r5, #32
  4019c8:	e003      	b.n	4019d2 <_tx_mutex_put+0x8a>
                                next_mutex =  next_mutex -> tx_mutex_owned_next;
  4019ca:	6adb      	ldr	r3, [r3, #44]	; 0x2c
                                if (next_mutex == thread_ptr -> tx_thread_owned_mutex_list)
  4019cc:	4298      	cmp	r0, r3
  4019ce:	d009      	beq.n	4019e4 <_tx_mutex_put+0x9c>
                            while (next_mutex != TX_NULL)
  4019d0:	b143      	cbz	r3, 4019e4 <_tx_mutex_put+0x9c>
                                if (next_mutex -> tx_mutex_inherit == TX_TRUE)
  4019d2:	691a      	ldr	r2, [r3, #16]
  4019d4:	2a01      	cmp	r2, #1
  4019d6:	d1f8      	bne.n	4019ca <_tx_mutex_put+0x82>
  4019d8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  4019da:	4295      	cmp	r5, r2
  4019dc:	bf28      	it	cs
  4019de:	4615      	movcs	r5, r2
  4019e0:	e7f3      	b.n	4019ca <_tx_mutex_put+0x82>
                            inheritance_priority =  ((UINT) TX_MAX_PRIORITIES);
  4019e2:	2520      	movs	r5, #32
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  4019e4:	f3ef 8210 	mrs	r2, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  4019e8:	b672      	cpsid	i
                            _tx_thread_preempt_disable--;
  4019ea:	485d      	ldr	r0, [pc, #372]	; (401b60 <_tx_mutex_put+0x218>)
  4019ec:	6803      	ldr	r3, [r0, #0]
  4019ee:	3b01      	subs	r3, #1
  4019f0:	6003      	str	r3, [r0, #0]
                            thread_ptr -> tx_thread_inherit_priority =  inheritance_priority;
  4019f2:	f8c1 509c 	str.w	r5, [r1, #156]	; 0x9c
  4019f6:	42ae      	cmp	r6, r5
  4019f8:	bf28      	it	cs
  4019fa:	462e      	movcs	r6, r5
                        if (mutex_ptr -> tx_mutex_suspended_count > ((UINT) 1))
  4019fc:	69e3      	ldr	r3, [r4, #28]
  4019fe:	2b01      	cmp	r3, #1
  401a00:	d911      	bls.n	401a26 <_tx_mutex_put+0xde>
                            if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
  401a02:	6923      	ldr	r3, [r4, #16]
  401a04:	2b01      	cmp	r3, #1
  401a06:	d17e      	bne.n	401b06 <_tx_mutex_put+0x1be>
                                _tx_thread_preempt_disable++;
  401a08:	4605      	mov	r5, r0
  401a0a:	6803      	ldr	r3, [r0, #0]
  401a0c:	3301      	adds	r3, #1
  401a0e:	6003      	str	r3, [r0, #0]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  401a10:	f382 8810 	msr	PRIMASK, r2
                                _tx_mutex_prioritize(mutex_ptr);
  401a14:	4620      	mov	r0, r4
  401a16:	4b53      	ldr	r3, [pc, #332]	; (401b64 <_tx_mutex_put+0x21c>)
  401a18:	4798      	blx	r3
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  401a1a:	f3ef 8210 	mrs	r2, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  401a1e:	b672      	cpsid	i
                                _tx_thread_preempt_disable--;
  401a20:	682b      	ldr	r3, [r5, #0]
  401a22:	3b01      	subs	r3, #1
  401a24:	602b      	str	r3, [r5, #0]
                        if (mutex_ptr -> tx_mutex_suspension_list == TX_NULL)
  401a26:	69a5      	ldr	r5, [r4, #24]
  401a28:	b145      	cbz	r5, 401a3c <_tx_mutex_put+0xf4>
                            if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
  401a2a:	6923      	ldr	r3, [r4, #16]
  401a2c:	2b01      	cmp	r3, #1
  401a2e:	d123      	bne.n	401a78 <_tx_mutex_put+0x130>
                                old_owner =  mutex_ptr -> tx_mutex_owner;
  401a30:	68e7      	ldr	r7, [r4, #12]
                                mutex_ptr -> tx_mutex_original_priority =   thread_ptr -> tx_thread_priority;
  401a32:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
  401a34:	6163      	str	r3, [r4, #20]
                                mutex_ptr -> tx_mutex_highest_priority_waiting =  (UINT) TX_MAX_PRIORITIES;
  401a36:	2320      	movs	r3, #32
  401a38:	62a3      	str	r3, [r4, #40]	; 0x28
  401a3a:	e068      	b.n	401b0e <_tx_mutex_put+0x1c6>
                            _tx_thread_preempt_disable++;
  401a3c:	4948      	ldr	r1, [pc, #288]	; (401b60 <_tx_mutex_put+0x218>)
  401a3e:	680b      	ldr	r3, [r1, #0]
  401a40:	3301      	adds	r3, #1
  401a42:	600b      	str	r3, [r1, #0]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  401a44:	f382 8810 	msr	PRIMASK, r2
                            mutex_ptr -> tx_mutex_highest_priority_waiting =  (UINT) TX_MAX_PRIORITIES;
  401a48:	2320      	movs	r3, #32
  401a4a:	62a3      	str	r3, [r4, #40]	; 0x28
                            if ((mutex_ptr -> tx_mutex_owner) -> tx_thread_priority != old_priority)
  401a4c:	68e0      	ldr	r0, [r4, #12]
  401a4e:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  401a50:	429e      	cmp	r6, r3
  401a52:	d002      	beq.n	401a5a <_tx_mutex_put+0x112>
                                _tx_mutex_priority_change(mutex_ptr -> tx_mutex_owner, old_priority);
  401a54:	4631      	mov	r1, r6
  401a56:	4b44      	ldr	r3, [pc, #272]	; (401b68 <_tx_mutex_put+0x220>)
  401a58:	4798      	blx	r3
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  401a5a:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  401a5e:	b672      	cpsid	i
                            _tx_thread_preempt_disable--;
  401a60:	493f      	ldr	r1, [pc, #252]	; (401b60 <_tx_mutex_put+0x218>)
  401a62:	680a      	ldr	r2, [r1, #0]
  401a64:	3a01      	subs	r2, #1
  401a66:	600a      	str	r2, [r1, #0]
                            mutex_ptr -> tx_mutex_owner =  TX_NULL;
  401a68:	2500      	movs	r5, #0
  401a6a:	60e5      	str	r5, [r4, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  401a6c:	f383 8810 	msr	PRIMASK, r3
                            _tx_thread_system_preempt_check();
  401a70:	4b3e      	ldr	r3, [pc, #248]	; (401b6c <_tx_mutex_put+0x224>)
  401a72:	4798      	blx	r3
                            status =  TX_SUCCESS;
  401a74:	4628      	mov	r0, r5
  401a76:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                        old_owner =      TX_NULL;
  401a78:	2700      	movs	r7, #0
  401a7a:	e048      	b.n	401b0e <_tx_mutex_put+0x1c6>
                                next_mutex =                            thread_ptr -> tx_thread_owned_mutex_list;
  401a7c:	f8d5 10a4 	ldr.w	r1, [r5, #164]	; 0xa4
                                previous_mutex =                        next_mutex -> tx_mutex_owned_previous;
  401a80:	6b08      	ldr	r0, [r1, #48]	; 0x30
                                next_mutex -> tx_mutex_owned_previous =  mutex_ptr;
  401a82:	630c      	str	r4, [r1, #48]	; 0x30
                                previous_mutex -> tx_mutex_owned_next =  mutex_ptr;
  401a84:	62c4      	str	r4, [r0, #44]	; 0x2c
                                mutex_ptr -> tx_mutex_owned_previous =   previous_mutex;
  401a86:	6320      	str	r0, [r4, #48]	; 0x30
                                mutex_ptr -> tx_mutex_owned_next =       next_mutex;
  401a88:	62e1      	str	r1, [r4, #44]	; 0x2c
  401a8a:	e048      	b.n	401b1e <_tx_mutex_put+0x1d6>
                                next_thread =                                  thread_ptr -> tx_thread_suspended_next;
  401a8c:	6f2b      	ldr	r3, [r5, #112]	; 0x70
                                mutex_ptr -> tx_mutex_suspension_list =        next_thread;
  401a8e:	61a3      	str	r3, [r4, #24]
                                previous_thread =                              thread_ptr -> tx_thread_suspended_previous;
  401a90:	6f69      	ldr	r1, [r5, #116]	; 0x74
                                next_thread -> tx_thread_suspended_previous =  previous_thread;
  401a92:	6759      	str	r1, [r3, #116]	; 0x74
                                previous_thread -> tx_thread_suspended_next =  next_thread;
  401a94:	670b      	str	r3, [r1, #112]	; 0x70
  401a96:	e04e      	b.n	401b36 <_tx_mutex_put+0x1ee>
                                if (mutex_ptr -> tx_mutex_suspended_count != TX_NO_SUSPENSIONS)
  401a98:	69e3      	ldr	r3, [r4, #28]
  401a9a:	b93b      	cbnz	r3, 401aac <_tx_mutex_put+0x164>
                                if (old_owner -> tx_thread_priority != old_priority)
  401a9c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401a9e:	429e      	cmp	r6, r3
  401aa0:	d056      	beq.n	401b50 <_tx_mutex_put+0x208>
                                    _tx_mutex_priority_change(old_owner, old_priority);
  401aa2:	4631      	mov	r1, r6
  401aa4:	4638      	mov	r0, r7
  401aa6:	4b30      	ldr	r3, [pc, #192]	; (401b68 <_tx_mutex_put+0x220>)
  401aa8:	4798      	blx	r3
  401aaa:	e051      	b.n	401b50 <_tx_mutex_put+0x208>
                                    _tx_mutex_prioritize(mutex_ptr);
  401aac:	4620      	mov	r0, r4
  401aae:	4b2d      	ldr	r3, [pc, #180]	; (401b64 <_tx_mutex_put+0x21c>)
  401ab0:	4798      	blx	r3
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  401ab2:	f3ef 8210 	mrs	r2, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  401ab6:	b672      	cpsid	i
                                    suspended_thread =  mutex_ptr -> tx_mutex_suspension_list;
  401ab8:	69a3      	ldr	r3, [r4, #24]
                                    if (suspended_thread != TX_NULL)
  401aba:	b10b      	cbz	r3, 401ac0 <_tx_mutex_put+0x178>
                                        mutex_ptr -> tx_mutex_highest_priority_waiting =  suspended_thread -> tx_thread_priority;
  401abc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  401abe:	62a3      	str	r3, [r4, #40]	; 0x28
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  401ac0:	f382 8810 	msr	PRIMASK, r2
  401ac4:	e7ea      	b.n	401a9c <_tx_mutex_put+0x154>
            mutex_ptr -> tx_mutex_ownership_count--;
  401ac6:	3b01      	subs	r3, #1
  401ac8:	6083      	str	r3, [r0, #8]
            if (mutex_ptr -> tx_mutex_ownership_count != ((UINT) 0))
  401aca:	2b00      	cmp	r3, #0
  401acc:	f47f af55 	bne.w	40197a <_tx_mutex_put+0x32>
                if (thread_ptr == TX_NULL)
  401ad0:	2900      	cmp	r1, #0
  401ad2:	f43f af56 	beq.w	401982 <_tx_mutex_put+0x3a>
                    thread_ptr -> tx_thread_owned_mutex_count--;
  401ad6:	f8d1 30a0 	ldr.w	r3, [r1, #160]	; 0xa0
  401ada:	3b01      	subs	r3, #1
  401adc:	f8c1 30a0 	str.w	r3, [r1, #160]	; 0xa0
                    if (thread_ptr -> tx_thread_owned_mutex_count == ((UINT) 0))
  401ae0:	2b00      	cmp	r3, #0
  401ae2:	f47f af52 	bne.w	40198a <_tx_mutex_put+0x42>
                        thread_ptr -> tx_thread_owned_mutex_list =  TX_NULL;
  401ae6:	f8c1 30a4 	str.w	r3, [r1, #164]	; 0xa4
                    if (mutex_ptr -> tx_mutex_suspension_list == TX_NULL)
  401aea:	6983      	ldr	r3, [r0, #24]
  401aec:	2b00      	cmp	r3, #0
  401aee:	f43f af57 	beq.w	4019a0 <_tx_mutex_put+0x58>
  401af2:	4604      	mov	r4, r0
                        old_priority =   thread_ptr -> tx_thread_user_priority;
  401af4:	f8d1 6094 	ldr.w	r6, [r1, #148]	; 0x94
                        if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
  401af8:	6903      	ldr	r3, [r0, #16]
  401afa:	2b01      	cmp	r3, #1
  401afc:	f43f af59 	beq.w	4019b2 <_tx_mutex_put+0x6a>
                        if (mutex_ptr -> tx_mutex_suspended_count > ((UINT) 1))
  401b00:	69c3      	ldr	r3, [r0, #28]
  401b02:	2b01      	cmp	r3, #1
  401b04:	d98f      	bls.n	401a26 <_tx_mutex_put+0xde>
                        if (mutex_ptr -> tx_mutex_suspension_list == TX_NULL)
  401b06:	69a5      	ldr	r5, [r4, #24]
  401b08:	2d00      	cmp	r5, #0
  401b0a:	d097      	beq.n	401a3c <_tx_mutex_put+0xf4>
                        old_owner =      TX_NULL;
  401b0c:	2700      	movs	r7, #0
                            owned_count =  thread_ptr -> tx_thread_owned_mutex_count;
  401b0e:	f8d5 30a0 	ldr.w	r3, [r5, #160]	; 0xa0
                            if (owned_count == ((UINT) 0))
  401b12:	2b00      	cmp	r3, #0
  401b14:	d1b2      	bne.n	401a7c <_tx_mutex_put+0x134>
                                thread_ptr -> tx_thread_owned_mutex_list =     mutex_ptr;
  401b16:	f8c5 40a4 	str.w	r4, [r5, #164]	; 0xa4
                                mutex_ptr -> tx_mutex_owned_next =             mutex_ptr;
  401b1a:	62e4      	str	r4, [r4, #44]	; 0x2c
                                mutex_ptr -> tx_mutex_owned_previous =         mutex_ptr;
  401b1c:	6324      	str	r4, [r4, #48]	; 0x30
                            thread_ptr -> tx_thread_owned_mutex_count =  owned_count + ((UINT) 1);
  401b1e:	3301      	adds	r3, #1
  401b20:	f8c5 30a0 	str.w	r3, [r5, #160]	; 0xa0
                            mutex_ptr -> tx_mutex_ownership_count =  (UINT) 1;
  401b24:	2301      	movs	r3, #1
  401b26:	60a3      	str	r3, [r4, #8]
                            mutex_ptr -> tx_mutex_owner =            thread_ptr;
  401b28:	60e5      	str	r5, [r4, #12]
                            mutex_ptr -> tx_mutex_suspended_count--;
  401b2a:	69e3      	ldr	r3, [r4, #28]
  401b2c:	3b01      	subs	r3, #1
  401b2e:	61e3      	str	r3, [r4, #28]
                            if (suspended_count == TX_NO_SUSPENSIONS)
  401b30:	2b00      	cmp	r3, #0
  401b32:	d1ab      	bne.n	401a8c <_tx_mutex_put+0x144>
                                mutex_ptr -> tx_mutex_suspension_list =  TX_NULL;
  401b34:	61a3      	str	r3, [r4, #24]
                            thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
  401b36:	2300      	movs	r3, #0
  401b38:	66ab      	str	r3, [r5, #104]	; 0x68
                            thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
  401b3a:	f8c5 3084 	str.w	r3, [r5, #132]	; 0x84
                            _tx_thread_preempt_disable++;
  401b3e:	4908      	ldr	r1, [pc, #32]	; (401b60 <_tx_mutex_put+0x218>)
  401b40:	680b      	ldr	r3, [r1, #0]
  401b42:	3301      	adds	r3, #1
  401b44:	600b      	str	r3, [r1, #0]
  401b46:	f382 8810 	msr	PRIMASK, r2
                            if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
  401b4a:	6923      	ldr	r3, [r4, #16]
  401b4c:	2b01      	cmp	r3, #1
  401b4e:	d0a3      	beq.n	401a98 <_tx_mutex_put+0x150>
                            _tx_thread_system_resume(thread_ptr);
  401b50:	4628      	mov	r0, r5
  401b52:	4b07      	ldr	r3, [pc, #28]	; (401b70 <_tx_mutex_put+0x228>)
  401b54:	4798      	blx	r3
                            status =  TX_SUCCESS;
  401b56:	2000      	movs	r0, #0
  401b58:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  401b5a:	bf00      	nop
  401b5c:	20400590 	.word	0x20400590
  401b60:	2040058c 	.word	0x2040058c
  401b64:	004017d1 	.word	0x004017d1
  401b68:	00401871 	.word	0x00401871
  401b6c:	00402469 	.word	0x00402469
  401b70:	004024a5 	.word	0x004024a5

00401b74 <_tx_queue_cleanup>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_queue_cleanup(TX_THREAD  *thread_ptr, ULONG suspension_sequence)
{
  401b74:	b510      	push	{r4, lr}
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  401b76:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  401b7a:	b672      	cpsid	i

    /* Disable interrupts to remove the suspended thread from the queue.  */
    TX_DISABLE

    /* Determine if the cleanup is still required.  */
    if (thread_ptr -> tx_thread_suspend_cleanup == &(_tx_queue_cleanup))
  401b7c:	6e84      	ldr	r4, [r0, #104]	; 0x68
  401b7e:	4a1e      	ldr	r2, [pc, #120]	; (401bf8 <_tx_queue_cleanup+0x84>)
  401b80:	4294      	cmp	r4, r2
  401b82:	d002      	beq.n	401b8a <_tx_queue_cleanup+0x16>
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  401b84:	f383 8810 	msr	PRIMASK, r3
  401b88:	bd10      	pop	{r4, pc}
    {

        /* Check for valid suspension sequence.  */
        if (suspension_sequence == thread_ptr -> tx_thread_suspension_sequence)
  401b8a:	f8d0 20b0 	ldr.w	r2, [r0, #176]	; 0xb0
  401b8e:	428a      	cmp	r2, r1
  401b90:	d1f8      	bne.n	401b84 <_tx_queue_cleanup+0x10>
        {

            /* Setup pointer to queue control block.  */
            queue_ptr =  TX_VOID_TO_QUEUE_POINTER_CONVERT(thread_ptr -> tx_thread_suspend_control_block);
  401b92:	6ec2      	ldr	r2, [r0, #108]	; 0x6c

            /* Check for NULL queue pointer.  */
            if (queue_ptr != TX_NULL)
  401b94:	2a00      	cmp	r2, #0
  401b96:	d0f5      	beq.n	401b84 <_tx_queue_cleanup+0x10>
            {

                /* Is the queue ID valid?  */
                if (queue_ptr -> tx_queue_id == TX_QUEUE_ID)
  401b98:	6814      	ldr	r4, [r2, #0]
  401b9a:	4918      	ldr	r1, [pc, #96]	; (401bfc <_tx_queue_cleanup+0x88>)
  401b9c:	428c      	cmp	r4, r1
  401b9e:	d1f1      	bne.n	401b84 <_tx_queue_cleanup+0x10>
                {

                    /* Determine if there are any thread suspensions.  */
                    if (queue_ptr -> tx_queue_suspended_count != TX_NO_SUSPENSIONS)
  401ba0:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
  401ba2:	2900      	cmp	r1, #0
  401ba4:	d0ee      	beq.n	401b84 <_tx_queue_cleanup+0x10>
#endif

                        /* Yes, we still have thread suspension!  */

                        /* Clear the suspension cleanup flag.  */
                        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
  401ba6:	2100      	movs	r1, #0
  401ba8:	6681      	str	r1, [r0, #104]	; 0x68

                        /* Decrement the suspended count.  */
                        queue_ptr -> tx_queue_suspended_count--;
  401baa:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
  401bac:	3901      	subs	r1, #1
  401bae:	62d1      	str	r1, [r2, #44]	; 0x2c
                        suspended_count =  queue_ptr -> tx_queue_suspended_count;

                        /* Remove the suspended thread from the list.  */

                        /* See if this is the only suspended thread on the list.  */
                        if (suspended_count == TX_NO_SUSPENSIONS)
  401bb0:	b9a1      	cbnz	r1, 401bdc <_tx_queue_cleanup+0x68>
                        {

                            /* Yes, the only suspended thread.  */

                            /* Update the head pointer.  */
                            queue_ptr -> tx_queue_suspension_list =  TX_NULL;
  401bb2:	6291      	str	r1, [r2, #40]	; 0x28
                            }
                        }

                        /* Now we need to determine if this cleanup is from a terminate, timeout,
                           or from a wait abort.  */
                        if (thread_ptr -> tx_thread_state == TX_QUEUE_SUSP)
  401bb4:	6b01      	ldr	r1, [r0, #48]	; 0x30
  401bb6:	2905      	cmp	r1, #5
  401bb8:	d1e4      	bne.n	401b84 <_tx_queue_cleanup+0x10>
                            /* Increment the number of timeouts on this queue.  */
                            queue_ptr -> tx_queue_performance_timeout_count++;
#endif

                            /* Setup return status.  */
                            if (queue_ptr -> tx_queue_enqueued != TX_NO_MESSAGES)
  401bba:	6912      	ldr	r2, [r2, #16]
  401bbc:	b1ba      	cbz	r2, 401bee <_tx_queue_cleanup+0x7a>
                            {

                                /* Queue full timeout!  */
                                thread_ptr -> tx_thread_suspend_status =  TX_QUEUE_FULL;
  401bbe:	220b      	movs	r2, #11
  401bc0:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84
                            /* Resume the thread!  */
                            _tx_thread_system_ni_resume(thread_ptr);
#else

                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
  401bc4:	490e      	ldr	r1, [pc, #56]	; (401c00 <_tx_queue_cleanup+0x8c>)
  401bc6:	680a      	ldr	r2, [r1, #0]
  401bc8:	3201      	adds	r2, #1
  401bca:	600a      	str	r2, [r1, #0]
  401bcc:	f383 8810 	msr	PRIMASK, r3

                            /* Restore interrupts.  */
                            TX_RESTORE

                            /* Resume the thread!  */
                            _tx_thread_system_resume(thread_ptr);
  401bd0:	4b0c      	ldr	r3, [pc, #48]	; (401c04 <_tx_queue_cleanup+0x90>)
  401bd2:	4798      	blx	r3
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  401bd4:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  401bd8:	b672      	cpsid	i
  401bda:	e7d3      	b.n	401b84 <_tx_queue_cleanup+0x10>
                            next_thread =                                   thread_ptr -> tx_thread_suspended_next;
  401bdc:	6f01      	ldr	r1, [r0, #112]	; 0x70
                            previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
  401bde:	6f44      	ldr	r4, [r0, #116]	; 0x74
                            next_thread -> tx_thread_suspended_previous =   previous_thread;
  401be0:	674c      	str	r4, [r1, #116]	; 0x74
                            previous_thread -> tx_thread_suspended_next =   next_thread;
  401be2:	6721      	str	r1, [r4, #112]	; 0x70
                            if (queue_ptr -> tx_queue_suspension_list == thread_ptr)
  401be4:	6a94      	ldr	r4, [r2, #40]	; 0x28
  401be6:	42a0      	cmp	r0, r4
                                queue_ptr -> tx_queue_suspension_list =         next_thread;
  401be8:	bf08      	it	eq
  401bea:	6291      	streq	r1, [r2, #40]	; 0x28
  401bec:	e7e2      	b.n	401bb4 <_tx_queue_cleanup+0x40>
                                thread_ptr -> tx_thread_suspend_status =  TX_QUEUE_EMPTY;
  401bee:	220a      	movs	r2, #10
  401bf0:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84
  401bf4:	e7e6      	b.n	401bc4 <_tx_queue_cleanup+0x50>
  401bf6:	bf00      	nop
  401bf8:	00401b75 	.word	0x00401b75
  401bfc:	51554555 	.word	0x51554555
  401c00:	2040058c 	.word	0x2040058c
  401c04:	004024a5 	.word	0x004024a5

00401c08 <_tx_queue_create>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_queue_create(TX_QUEUE *queue_ptr, CHAR *name_ptr, UINT message_size,
                        VOID *queue_start, ULONG queue_size)
{
  401c08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  401c0a:	4604      	mov	r4, r0
  401c0c:	460f      	mov	r7, r1
  401c0e:	4615      	mov	r5, r2
  401c10:	461e      	mov	r6, r3
TX_QUEUE        *next_queue;
TX_QUEUE        *previous_queue;


    /* Initialize queue control block to all zeros.  */
    TX_MEMSET(queue_ptr, 0, (sizeof(TX_QUEUE)));
  401c12:	223c      	movs	r2, #60	; 0x3c
  401c14:	2100      	movs	r1, #0
  401c16:	4b16      	ldr	r3, [pc, #88]	; (401c70 <_tx_queue_create+0x68>)
  401c18:	4798      	blx	r3

    /* Setup the basic queue fields.  */
    queue_ptr -> tx_queue_name =             name_ptr;
  401c1a:	6067      	str	r7, [r4, #4]

    /* Save the message size in the control block.  */
    queue_ptr -> tx_queue_message_size =  message_size;
  401c1c:	60a5      	str	r5, [r4, #8]

    /* Determine how many messages will fit in the queue area and the number
       of ULONGs used.  */
    capacity =    (UINT) (queue_size / ((ULONG) (((ULONG) message_size) * (sizeof(ULONG)))));
  401c1e:	00ad      	lsls	r5, r5, #2
  401c20:	9b06      	ldr	r3, [sp, #24]
  401c22:	fbb3 f3f5 	udiv	r3, r3, r5
    used_words =  capacity * message_size;

    /* Save the starting address and calculate the ending address of
       the queue.  Note that the ending address is really one past the
       end!  */
    queue_ptr -> tx_queue_start =  TX_VOID_TO_ULONG_POINTER_CONVERT(queue_start);
  401c26:	61a6      	str	r6, [r4, #24]
    queue_ptr -> tx_queue_end =    TX_ULONG_POINTER_ADD(queue_ptr -> tx_queue_start, used_words);
  401c28:	fb03 6505 	mla	r5, r3, r5, r6
  401c2c:	61e5      	str	r5, [r4, #28]

    /* Set the read and write pointers to the beginning of the queue
       area.  */
    queue_ptr -> tx_queue_read =   TX_VOID_TO_ULONG_POINTER_CONVERT(queue_start);
  401c2e:	6226      	str	r6, [r4, #32]
    queue_ptr -> tx_queue_write =  TX_VOID_TO_ULONG_POINTER_CONVERT(queue_start);
  401c30:	6266      	str	r6, [r4, #36]	; 0x24

    /* Setup the number of enqueued messages and the number of message
       slots available in the queue.  */
    queue_ptr -> tx_queue_available_storage =  (UINT) capacity;
  401c32:	6163      	str	r3, [r4, #20]
    queue_ptr -> tx_queue_capacity =           (UINT) capacity;
  401c34:	60e3      	str	r3, [r4, #12]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  401c36:	f3ef 8110 	mrs	r1, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  401c3a:	b672      	cpsid	i

    /* Disable interrupts to put the queue on the created list.  */
    TX_DISABLE

    /* Setup the queue ID to make it valid.  */
    queue_ptr -> tx_queue_id =  TX_QUEUE_ID;
  401c3c:	4b0d      	ldr	r3, [pc, #52]	; (401c74 <_tx_queue_create+0x6c>)
  401c3e:	6023      	str	r3, [r4, #0]

    /* Place the queue on the list of created queues.  First,
       check for an empty list.  */
    if (_tx_queue_created_count == TX_EMPTY)
  401c40:	4b0d      	ldr	r3, [pc, #52]	; (401c78 <_tx_queue_create+0x70>)
  401c42:	681b      	ldr	r3, [r3, #0]
  401c44:	b173      	cbz	r3, 401c64 <_tx_queue_create+0x5c>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_queue =      _tx_queue_created_ptr;
  401c46:	4b0d      	ldr	r3, [pc, #52]	; (401c7c <_tx_queue_create+0x74>)
  401c48:	681b      	ldr	r3, [r3, #0]
        previous_queue =  next_queue -> tx_queue_created_previous;
  401c4a:	6b5a      	ldr	r2, [r3, #52]	; 0x34

        /* Place the new queue in the list.  */
        next_queue -> tx_queue_created_previous =  queue_ptr;
  401c4c:	635c      	str	r4, [r3, #52]	; 0x34
        previous_queue -> tx_queue_created_next =  queue_ptr;
  401c4e:	6314      	str	r4, [r2, #48]	; 0x30

        /* Setup this queues's created links.  */
        queue_ptr -> tx_queue_created_previous =  previous_queue;
  401c50:	6362      	str	r2, [r4, #52]	; 0x34
        queue_ptr -> tx_queue_created_next =      next_queue;
  401c52:	6323      	str	r3, [r4, #48]	; 0x30
    }

    /* Increment the created queue count.  */
    _tx_queue_created_count++;
  401c54:	4a08      	ldr	r2, [pc, #32]	; (401c78 <_tx_queue_create+0x70>)
  401c56:	6813      	ldr	r3, [r2, #0]
  401c58:	3301      	adds	r3, #1
  401c5a:	6013      	str	r3, [r2, #0]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  401c5c:	f381 8810 	msr	PRIMASK, r1
    /* Restore interrupts.  */
    TX_RESTORE

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
}
  401c60:	2000      	movs	r0, #0
  401c62:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        _tx_queue_created_ptr =                   queue_ptr;
  401c64:	4b05      	ldr	r3, [pc, #20]	; (401c7c <_tx_queue_create+0x74>)
  401c66:	601c      	str	r4, [r3, #0]
        queue_ptr -> tx_queue_created_next =      queue_ptr;
  401c68:	6324      	str	r4, [r4, #48]	; 0x30
        queue_ptr -> tx_queue_created_previous =  queue_ptr;
  401c6a:	6364      	str	r4, [r4, #52]	; 0x34
  401c6c:	e7f2      	b.n	401c54 <_tx_queue_create+0x4c>
  401c6e:	bf00      	nop
  401c70:	00403361 	.word	0x00403361
  401c74:	51554555 	.word	0x51554555
  401c78:	204004cc 	.word	0x204004cc
  401c7c:	204004ec 	.word	0x204004ec

00401c80 <_tx_queue_receive>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_queue_receive(TX_QUEUE *queue_ptr, VOID *destination_ptr, ULONG wait_option)
{
  401c80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  401c82:	f3ef 8510 	mrs	r5, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  401c86:	b672      	cpsid	i

    /* Log this kernel call.  */
    TX_EL_QUEUE_RECEIVE_INSERT

    /* Pickup the thread suspension count.  */
    suspended_count =  queue_ptr -> tx_queue_suspended_count;
  401c88:	6ac4      	ldr	r4, [r0, #44]	; 0x2c

    /* Determine if there is anything in the queue.  */
    if (queue_ptr -> tx_queue_enqueued != TX_NO_MESSAGES)
  401c8a:	6903      	ldr	r3, [r0, #16]
  401c8c:	2b00      	cmp	r3, #0
  401c8e:	f000 80b3 	beq.w	401df8 <_tx_queue_receive+0x178>
    {

        /* Determine if there are any suspensions.  */
        if (suspended_count == TX_NO_SUSPENSIONS)
  401c92:	bb1c      	cbnz	r4, 401cdc <_tx_queue_receive+0x5c>
        {

            /* There is a message waiting in the queue and there are no suspensi.  */

            /* Setup source and destination pointers.  */
            source =       queue_ptr -> tx_queue_read;
  401c94:	6a03      	ldr	r3, [r0, #32]
            destination =  TX_VOID_TO_ULONG_POINTER_CONVERT(destination_ptr);
            size =         queue_ptr -> tx_queue_message_size;
  401c96:	6887      	ldr	r7, [r0, #8]

            /* Copy message. Note that the source and destination pointers are
               incremented by the macro.  */
            TX_QUEUE_MESSAGE_COPY(source, destination, size)
  401c98:	1d1e      	adds	r6, r3, #4
  401c9a:	681b      	ldr	r3, [r3, #0]
  401c9c:	600b      	str	r3, [r1, #0]
  401c9e:	2f01      	cmp	r7, #1
  401ca0:	d90d      	bls.n	401cbe <_tx_queue_receive+0x3e>
  401ca2:	1e7b      	subs	r3, r7, #1
  401ca4:	d00b      	beq.n	401cbe <_tx_queue_receive+0x3e>
  401ca6:	4632      	mov	r2, r6
  401ca8:	f852 4b04 	ldr.w	r4, [r2], #4
  401cac:	f841 4f04 	str.w	r4, [r1, #4]!
  401cb0:	3b01      	subs	r3, #1
  401cb2:	d1f9      	bne.n	401ca8 <_tx_queue_receive+0x28>
  401cb4:	f06f 4340 	mvn.w	r3, #3221225472	; 0xc0000000
  401cb8:	443b      	add	r3, r7
  401cba:	eb06 0683 	add.w	r6, r6, r3, lsl #2

            /* Determine if we are at the end.  */
            if (source == queue_ptr -> tx_queue_end)
  401cbe:	69c3      	ldr	r3, [r0, #28]
  401cc0:	429e      	cmp	r6, r3
            {

                /* Yes, wrap around to the beginning.  */
                source =  queue_ptr -> tx_queue_start;
  401cc2:	bf08      	it	eq
  401cc4:	6986      	ldreq	r6, [r0, #24]
            }

            /* Setup the queue read pointer.   */
            queue_ptr -> tx_queue_read =  source;
  401cc6:	6206      	str	r6, [r0, #32]

            /* Increase the amount of available storage.  */
            queue_ptr -> tx_queue_available_storage++;
  401cc8:	6943      	ldr	r3, [r0, #20]
  401cca:	3301      	adds	r3, #1
  401ccc:	6143      	str	r3, [r0, #20]

            /* Decrease the enqueued count.  */
            queue_ptr -> tx_queue_enqueued--;
  401cce:	6903      	ldr	r3, [r0, #16]
  401cd0:	3b01      	subs	r3, #1
  401cd2:	6103      	str	r3, [r0, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  401cd4:	f385 8810 	msr	PRIMASK, r5
    status =  TX_SUCCESS;
  401cd8:	2000      	movs	r0, #0
  401cda:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        {

            /* At this point we know the queue is full.  */

            /* Pickup thread suspension list head pointer.  */
            thread_ptr =  queue_ptr -> tx_queue_suspension_list;
  401cdc:	6a87      	ldr	r7, [r0, #40]	; 0x28

            /* Now determine if there is a queue front suspension active.   */

            /* Is the front suspension flag set?  */
            if (thread_ptr -> tx_thread_suspend_option == TX_TRUE)
  401cde:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  401ce2:	2b01      	cmp	r3, #1
  401ce4:	d059      	beq.n	401d9a <_tx_queue_receive+0x11a>
                /* At this point, we know that the queue is full and there
                   are one or more threads suspended trying to send another
                   message to this queue.  */

                /* Setup source and destination pointers.  */
                source =       queue_ptr -> tx_queue_read;
  401ce6:	6a03      	ldr	r3, [r0, #32]
                destination =  TX_VOID_TO_ULONG_POINTER_CONVERT(destination_ptr);
                size =         queue_ptr -> tx_queue_message_size;
  401ce8:	f8d0 c008 	ldr.w	ip, [r0, #8]

                /* Copy message. Note that the source and destination pointers are
                   incremented by the macro.  */
                TX_QUEUE_MESSAGE_COPY(source, destination, size)
  401cec:	f103 0e04 	add.w	lr, r3, #4
  401cf0:	681b      	ldr	r3, [r3, #0]
  401cf2:	600b      	str	r3, [r1, #0]
  401cf4:	f1bc 0f01 	cmp.w	ip, #1
  401cf8:	d90e      	bls.n	401d18 <_tx_queue_receive+0x98>
  401cfa:	f1bc 0301 	subs.w	r3, ip, #1
  401cfe:	d00b      	beq.n	401d18 <_tx_queue_receive+0x98>
  401d00:	4672      	mov	r2, lr
  401d02:	f852 6b04 	ldr.w	r6, [r2], #4
  401d06:	f841 6f04 	str.w	r6, [r1, #4]!
  401d0a:	3b01      	subs	r3, #1
  401d0c:	d1f9      	bne.n	401d02 <_tx_queue_receive+0x82>
  401d0e:	f06f 4340 	mvn.w	r3, #3221225472	; 0xc0000000
  401d12:	4463      	add	r3, ip
  401d14:	eb0e 0e83 	add.w	lr, lr, r3, lsl #2

                /* Determine if we are at the end.  */
                if (source == queue_ptr -> tx_queue_end)
  401d18:	69c3      	ldr	r3, [r0, #28]
  401d1a:	459e      	cmp	lr, r3
                {

                    /* Yes, wrap around to the beginning.  */
                    source =  queue_ptr -> tx_queue_start;
  401d1c:	bf08      	it	eq
  401d1e:	f8d0 e018 	ldreq.w	lr, [r0, #24]
                }

                /* Setup the queue read pointer.   */
                queue_ptr -> tx_queue_read =  source;
  401d22:	f8c0 e020 	str.w	lr, [r0, #32]

                /* Disable preemption.  */
                _tx_thread_preempt_disable++;
  401d26:	4b50      	ldr	r3, [pc, #320]	; (401e68 <_tx_queue_receive+0x1e8>)
  401d28:	681a      	ldr	r2, [r3, #0]
  401d2a:	3201      	adds	r2, #1
  401d2c:	601a      	str	r2, [r3, #0]
                /* Disable interrupts again.  */
                TX_DISABLE
#endif

                /* Decrement the preemption disable variable.  */
                _tx_thread_preempt_disable--;
  401d2e:	681a      	ldr	r2, [r3, #0]
  401d30:	3a01      	subs	r2, #1
  401d32:	601a      	str	r2, [r3, #0]

                /* Setup source and destination pointers.  */
                source =       TX_VOID_TO_ULONG_POINTER_CONVERT(thread_ptr -> tx_thread_additional_suspend_info);
  401d34:	6ff9      	ldr	r1, [r7, #124]	; 0x7c
                destination =  queue_ptr -> tx_queue_write;
  401d36:	6a42      	ldr	r2, [r0, #36]	; 0x24
                size =         queue_ptr -> tx_queue_message_size;
  401d38:	f8d0 e008 	ldr.w	lr, [r0, #8]

                /* Copy message. Note that the source and destination pointers are
                   incremented by the macro.  */
                TX_QUEUE_MESSAGE_COPY(source, destination, size)
  401d3c:	1d17      	adds	r7, r2, #4
  401d3e:	680b      	ldr	r3, [r1, #0]
  401d40:	6013      	str	r3, [r2, #0]
  401d42:	f1be 0f01 	cmp.w	lr, #1
  401d46:	d90e      	bls.n	401d66 <_tx_queue_receive+0xe6>
  401d48:	f1be 0301 	subs.w	r3, lr, #1
  401d4c:	d00b      	beq.n	401d66 <_tx_queue_receive+0xe6>
  401d4e:	3104      	adds	r1, #4
  401d50:	f851 6b04 	ldr.w	r6, [r1], #4
  401d54:	f842 6f04 	str.w	r6, [r2, #4]!
  401d58:	3b01      	subs	r3, #1
  401d5a:	d1f9      	bne.n	401d50 <_tx_queue_receive+0xd0>
  401d5c:	f06f 4340 	mvn.w	r3, #3221225472	; 0xc0000000
  401d60:	4473      	add	r3, lr
  401d62:	eb07 0783 	add.w	r7, r7, r3, lsl #2

                /* Determine if we are at the end.  */
                if (destination == queue_ptr -> tx_queue_end)
  401d66:	69c3      	ldr	r3, [r0, #28]
  401d68:	429f      	cmp	r7, r3
                {

                    /* Yes, wrap around to the beginning.  */
                    destination =  queue_ptr -> tx_queue_start;
  401d6a:	bf08      	it	eq
  401d6c:	6987      	ldreq	r7, [r0, #24]
                }

                /* Adjust the write pointer.  */
                queue_ptr -> tx_queue_write =  destination;
  401d6e:	6247      	str	r7, [r0, #36]	; 0x24

                /* Pickup thread pointer.  */
                thread_ptr =  queue_ptr -> tx_queue_suspension_list;
  401d70:	6a83      	ldr	r3, [r0, #40]	; 0x28

                /* Message is now in the queue.  See if this is the only suspended thread
                   on the list.  */
                suspended_count--;
                if (suspended_count == TX_NO_SUSPENSIONS)
  401d72:	3c01      	subs	r4, #1
  401d74:	d13a      	bne.n	401dec <_tx_queue_receive+0x16c>
                {

                  /* Yes, the only suspended thread.  */

                    /* Update the head pointer.  */
                    queue_ptr -> tx_queue_suspension_list =  TX_NULL;
  401d76:	2200      	movs	r2, #0
  401d78:	6282      	str	r2, [r0, #40]	; 0x28
                    next_thread -> tx_thread_suspended_previous =   previous_thread;
                    previous_thread -> tx_thread_suspended_next =   next_thread;
                }

                /* Decrement the suspension count.  */
                queue_ptr -> tx_queue_suspended_count =  suspended_count;
  401d7a:	62c4      	str	r4, [r0, #44]	; 0x2c

                /* Prepare for resumption of the first thread.  */

                /* Clear cleanup routine to avoid timeout.  */
                thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
  401d7c:	2400      	movs	r4, #0
  401d7e:	669c      	str	r4, [r3, #104]	; 0x68

                /* Put return status into the thread control block.  */
                thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
  401d80:	f8c3 4084 	str.w	r4, [r3, #132]	; 0x84
                /* Restore interrupts.  */
                TX_RESTORE
#else

                /* Temporarily disable preemption.  */
                _tx_thread_preempt_disable++;
  401d84:	4938      	ldr	r1, [pc, #224]	; (401e68 <_tx_queue_receive+0x1e8>)
  401d86:	680a      	ldr	r2, [r1, #0]
  401d88:	3201      	adds	r2, #1
  401d8a:	600a      	str	r2, [r1, #0]
  401d8c:	f385 8810 	msr	PRIMASK, r5

                /* Restore interrupts.  */
                TX_RESTORE

                /* Resume thread.  */
                _tx_thread_system_resume(thread_ptr);
  401d90:	4618      	mov	r0, r3
  401d92:	4b36      	ldr	r3, [pc, #216]	; (401e6c <_tx_queue_receive+0x1ec>)
  401d94:	4798      	blx	r3
    status =  TX_SUCCESS;
  401d96:	4620      	mov	r0, r4
  401d98:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                source =       TX_VOID_TO_ULONG_POINTER_CONVERT(thread_ptr -> tx_thread_additional_suspend_info);
  401d9a:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
                size =         queue_ptr -> tx_queue_message_size;
  401d9c:	6883      	ldr	r3, [r0, #8]
                TX_QUEUE_MESSAGE_COPY(source, destination, size)
  401d9e:	6816      	ldr	r6, [r2, #0]
  401da0:	600e      	str	r6, [r1, #0]
  401da2:	2b01      	cmp	r3, #1
  401da4:	d908      	bls.n	401db8 <_tx_queue_receive+0x138>
  401da6:	3b01      	subs	r3, #1
  401da8:	d006      	beq.n	401db8 <_tx_queue_receive+0x138>
  401daa:	3204      	adds	r2, #4
  401dac:	f852 6b04 	ldr.w	r6, [r2], #4
  401db0:	f841 6f04 	str.w	r6, [r1, #4]!
  401db4:	3b01      	subs	r3, #1
  401db6:	d1f9      	bne.n	401dac <_tx_queue_receive+0x12c>
                if (suspended_count == TX_NO_SUSPENSIONS)
  401db8:	3c01      	subs	r4, #1
  401dba:	d111      	bne.n	401de0 <_tx_queue_receive+0x160>
                    queue_ptr -> tx_queue_suspension_list =  TX_NULL;
  401dbc:	2300      	movs	r3, #0
  401dbe:	6283      	str	r3, [r0, #40]	; 0x28
                queue_ptr -> tx_queue_suspended_count =  suspended_count;
  401dc0:	62c4      	str	r4, [r0, #44]	; 0x2c
                thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
  401dc2:	2400      	movs	r4, #0
  401dc4:	66bc      	str	r4, [r7, #104]	; 0x68
                thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
  401dc6:	f8c7 4084 	str.w	r4, [r7, #132]	; 0x84
                _tx_thread_preempt_disable++;
  401dca:	4a27      	ldr	r2, [pc, #156]	; (401e68 <_tx_queue_receive+0x1e8>)
  401dcc:	6813      	ldr	r3, [r2, #0]
  401dce:	3301      	adds	r3, #1
  401dd0:	6013      	str	r3, [r2, #0]
  401dd2:	f385 8810 	msr	PRIMASK, r5
                _tx_thread_system_resume(thread_ptr);
  401dd6:	4638      	mov	r0, r7
  401dd8:	4b24      	ldr	r3, [pc, #144]	; (401e6c <_tx_queue_receive+0x1ec>)
  401dda:	4798      	blx	r3
    status =  TX_SUCCESS;
  401ddc:	4620      	mov	r0, r4
  401dde:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                    next_thread =                            thread_ptr -> tx_thread_suspended_next;
  401de0:	6f3b      	ldr	r3, [r7, #112]	; 0x70
                    queue_ptr -> tx_queue_suspension_list =  next_thread;
  401de2:	6283      	str	r3, [r0, #40]	; 0x28
                    previous_thread =                              thread_ptr -> tx_thread_suspended_previous;
  401de4:	6f7a      	ldr	r2, [r7, #116]	; 0x74
                    next_thread -> tx_thread_suspended_previous =  previous_thread;
  401de6:	675a      	str	r2, [r3, #116]	; 0x74
                    previous_thread -> tx_thread_suspended_next =  next_thread;
  401de8:	6713      	str	r3, [r2, #112]	; 0x70
  401dea:	e7e9      	b.n	401dc0 <_tx_queue_receive+0x140>
                    next_thread =                            thread_ptr -> tx_thread_suspended_next;
  401dec:	6f1a      	ldr	r2, [r3, #112]	; 0x70
                    queue_ptr -> tx_queue_suspension_list =  next_thread;
  401dee:	6282      	str	r2, [r0, #40]	; 0x28
                    previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
  401df0:	6f59      	ldr	r1, [r3, #116]	; 0x74
                    next_thread -> tx_thread_suspended_previous =   previous_thread;
  401df2:	6751      	str	r1, [r2, #116]	; 0x74
                    previous_thread -> tx_thread_suspended_next =   next_thread;
  401df4:	670a      	str	r2, [r1, #112]	; 0x70
  401df6:	e7c0      	b.n	401d7a <_tx_queue_receive+0xfa>
            }
        }
    }

    /* Determine if the request specifies suspension.  */
    else if (wait_option != TX_NO_WAIT)
  401df8:	b91a      	cbnz	r2, 401e02 <_tx_queue_receive+0x182>
  401dfa:	f385 8810 	msr	PRIMASK, r5

        /* Restore interrupts.  */
        TX_RESTORE

        /* Immediate return, return error completion.  */
        status =  TX_QUEUE_EMPTY;
  401dfe:	200a      	movs	r0, #10
    }

    /* Return completion status.  */
    return(status);
}
  401e00:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (_tx_thread_preempt_disable != ((UINT) 0))
  401e02:	4b19      	ldr	r3, [pc, #100]	; (401e68 <_tx_queue_receive+0x1e8>)
  401e04:	681b      	ldr	r3, [r3, #0]
  401e06:	b11b      	cbz	r3, 401e10 <_tx_queue_receive+0x190>
  401e08:	f385 8810 	msr	PRIMASK, r5
            status =  TX_QUEUE_EMPTY;
  401e0c:	200a      	movs	r0, #10
  401e0e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            TX_THREAD_GET_CURRENT(thread_ptr)
  401e10:	4b17      	ldr	r3, [pc, #92]	; (401e70 <_tx_queue_receive+0x1f0>)
  401e12:	681e      	ldr	r6, [r3, #0]
            thread_ptr -> tx_thread_suspend_cleanup =  &(_tx_queue_cleanup);
  401e14:	4b17      	ldr	r3, [pc, #92]	; (401e74 <_tx_queue_receive+0x1f4>)
  401e16:	66b3      	str	r3, [r6, #104]	; 0x68
            thread_ptr -> tx_thread_suspend_control_block =    (VOID *) queue_ptr;
  401e18:	66f0      	str	r0, [r6, #108]	; 0x6c
            thread_ptr -> tx_thread_additional_suspend_info =  (VOID *) destination_ptr;
  401e1a:	67f1      	str	r1, [r6, #124]	; 0x7c
            thread_ptr -> tx_thread_suspend_option =           TX_FALSE;
  401e1c:	2300      	movs	r3, #0
  401e1e:	f8c6 3080 	str.w	r3, [r6, #128]	; 0x80
            thread_ptr -> tx_thread_suspension_sequence++;
  401e22:	f8d6 30b0 	ldr.w	r3, [r6, #176]	; 0xb0
  401e26:	3301      	adds	r3, #1
  401e28:	f8c6 30b0 	str.w	r3, [r6, #176]	; 0xb0
            if (suspended_count == TX_NO_SUSPENSIONS)
  401e2c:	b9ac      	cbnz	r4, 401e5a <_tx_queue_receive+0x1da>
                queue_ptr -> tx_queue_suspension_list =         thread_ptr;
  401e2e:	6286      	str	r6, [r0, #40]	; 0x28
                thread_ptr -> tx_thread_suspended_next =        thread_ptr;
  401e30:	6736      	str	r6, [r6, #112]	; 0x70
                thread_ptr -> tx_thread_suspended_previous =    thread_ptr;
  401e32:	6776      	str	r6, [r6, #116]	; 0x74
            queue_ptr -> tx_queue_suspended_count =  suspended_count + ((UINT) 1);
  401e34:	3401      	adds	r4, #1
  401e36:	62c4      	str	r4, [r0, #44]	; 0x2c
            thread_ptr -> tx_thread_state =    TX_QUEUE_SUSP;
  401e38:	2305      	movs	r3, #5
  401e3a:	6333      	str	r3, [r6, #48]	; 0x30
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
  401e3c:	2301      	movs	r3, #1
  401e3e:	63b3      	str	r3, [r6, #56]	; 0x38
            thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
  401e40:	64f2      	str	r2, [r6, #76]	; 0x4c
            _tx_thread_preempt_disable++;
  401e42:	4a09      	ldr	r2, [pc, #36]	; (401e68 <_tx_queue_receive+0x1e8>)
  401e44:	6813      	ldr	r3, [r2, #0]
  401e46:	3301      	adds	r3, #1
  401e48:	6013      	str	r3, [r2, #0]
  401e4a:	f385 8810 	msr	PRIMASK, r5
            _tx_thread_system_suspend(thread_ptr);
  401e4e:	4630      	mov	r0, r6
  401e50:	4b09      	ldr	r3, [pc, #36]	; (401e78 <_tx_queue_receive+0x1f8>)
  401e52:	4798      	blx	r3
            status =  thread_ptr -> tx_thread_suspend_status;
  401e54:	f8d6 0084 	ldr.w	r0, [r6, #132]	; 0x84
  401e58:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                next_thread =                                   queue_ptr -> tx_queue_suspension_list;
  401e5a:	6a83      	ldr	r3, [r0, #40]	; 0x28
                thread_ptr -> tx_thread_suspended_next =        next_thread;
  401e5c:	6733      	str	r3, [r6, #112]	; 0x70
                previous_thread =                               next_thread -> tx_thread_suspended_previous;
  401e5e:	6f59      	ldr	r1, [r3, #116]	; 0x74
                thread_ptr -> tx_thread_suspended_previous =    previous_thread;
  401e60:	6771      	str	r1, [r6, #116]	; 0x74
                previous_thread -> tx_thread_suspended_next =   thread_ptr;
  401e62:	670e      	str	r6, [r1, #112]	; 0x70
                next_thread -> tx_thread_suspended_previous =   thread_ptr;
  401e64:	675e      	str	r6, [r3, #116]	; 0x74
  401e66:	e7e5      	b.n	401e34 <_tx_queue_receive+0x1b4>
  401e68:	2040058c 	.word	0x2040058c
  401e6c:	004024a5 	.word	0x004024a5
  401e70:	20400590 	.word	0x20400590
  401e74:	00401b75 	.word	0x00401b75
  401e78:	004025d9 	.word	0x004025d9

00401e7c <_tx_queue_send>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_queue_send(TX_QUEUE *queue_ptr, VOID *source_ptr, ULONG wait_option)
{
  401e7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  401e7e:	4604      	mov	r4, r0
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  401e80:	f3ef 8610 	mrs	r6, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  401e84:	b672      	cpsid	i

    /* Log this kernel call.  */
    TX_EL_QUEUE_SEND_INSERT

    /* Pickup the thread suspension count.  */
    suspended_count =  queue_ptr -> tx_queue_suspended_count;
  401e86:	6ac5      	ldr	r5, [r0, #44]	; 0x2c

    /* Determine if there is room in the queue.  */
    if (queue_ptr -> tx_queue_available_storage != TX_NO_MESSAGES)
  401e88:	6943      	ldr	r3, [r0, #20]
  401e8a:	2b00      	cmp	r3, #0
  401e8c:	d059      	beq.n	401f42 <_tx_queue_send+0xc6>
    {

        /* There is room for the message in the queue.  */

        /* Determine if there are suspended on this queue.  */
        if (suspended_count == TX_NO_SUSPENSIONS)
  401e8e:	bb3d      	cbnz	r5, 401ee0 <_tx_queue_send+0x64>
        {

            /* No suspended threads, simply place the message in the queue.  */

            /* Reduce the amount of available storage.  */
            queue_ptr -> tx_queue_available_storage--;
  401e90:	3b01      	subs	r3, #1
  401e92:	6143      	str	r3, [r0, #20]

            /* Increase the enqueued count.  */
            queue_ptr -> tx_queue_enqueued++;
  401e94:	6903      	ldr	r3, [r0, #16]
  401e96:	3301      	adds	r3, #1
  401e98:	6103      	str	r3, [r0, #16]

            /* Setup source and destination pointers.  */
            source =       TX_VOID_TO_ULONG_POINTER_CONVERT(source_ptr);
            destination =  queue_ptr -> tx_queue_write;
  401e9a:	6a42      	ldr	r2, [r0, #36]	; 0x24
            size =         queue_ptr -> tx_queue_message_size;
  401e9c:	6887      	ldr	r7, [r0, #8]

            /* Copy message. Note that the source and destination pointers are
               incremented by the macro.  */
            TX_QUEUE_MESSAGE_COPY(source, destination, size)
  401e9e:	1d15      	adds	r5, r2, #4
  401ea0:	680b      	ldr	r3, [r1, #0]
  401ea2:	6013      	str	r3, [r2, #0]
  401ea4:	2f01      	cmp	r7, #1
  401ea6:	d90d      	bls.n	401ec4 <_tx_queue_send+0x48>
  401ea8:	1e7b      	subs	r3, r7, #1
  401eaa:	d00b      	beq.n	401ec4 <_tx_queue_send+0x48>
  401eac:	3104      	adds	r1, #4
  401eae:	f851 0b04 	ldr.w	r0, [r1], #4
  401eb2:	f842 0f04 	str.w	r0, [r2, #4]!
  401eb6:	3b01      	subs	r3, #1
  401eb8:	d1f9      	bne.n	401eae <_tx_queue_send+0x32>
  401eba:	f06f 4340 	mvn.w	r3, #3221225472	; 0xc0000000
  401ebe:	443b      	add	r3, r7
  401ec0:	eb05 0583 	add.w	r5, r5, r3, lsl #2

            /* Determine if we are at the end.  */
            if (destination == queue_ptr -> tx_queue_end)
  401ec4:	69e3      	ldr	r3, [r4, #28]
  401ec6:	429d      	cmp	r5, r3
            {

                /* Yes, wrap around to the beginning.  */
                destination =  queue_ptr -> tx_queue_start;
  401ec8:	bf08      	it	eq
  401eca:	69a5      	ldreq	r5, [r4, #24]
            }

            /* Adjust the write pointer.  */
            queue_ptr -> tx_queue_write =  destination;
  401ecc:	6265      	str	r5, [r4, #36]	; 0x24

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

            /* Pickup the notify callback routine for this queue.  */
            queue_send_notify =  queue_ptr -> tx_queue_send_notify;
  401ece:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  401ed0:	f386 8810 	msr	PRIMASK, r6
            TX_RESTORE

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

            /* Determine if a notify callback is required.  */
            if (queue_send_notify != TX_NULL)
  401ed4:	2b00      	cmp	r3, #0
  401ed6:	d073      	beq.n	401fc0 <_tx_queue_send+0x144>
            {

                /* Call application queue send notification.  */
                (queue_send_notify)(queue_ptr);
  401ed8:	4620      	mov	r0, r4
  401eda:	4798      	blx	r3
    status =  TX_SUCCESS;
  401edc:	2000      	movs	r0, #0
  401ede:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            /* There is a thread suspended on an empty queue. Simply
               copy the message to the suspended thread's destination
               pointer.  */

            /* Pickup the head of the suspension list.  */
            thread_ptr =  queue_ptr -> tx_queue_suspension_list;
  401ee0:	6a80      	ldr	r0, [r0, #40]	; 0x28

            /* See if this is the only suspended thread on the list.  */
            suspended_count--;
            if (suspended_count == TX_NO_SUSPENSIONS)
  401ee2:	3d01      	subs	r5, #1
  401ee4:	d125      	bne.n	401f32 <_tx_queue_send+0xb6>
            {

                /* Yes, the only suspended thread.  */

                /* Update the head pointer.  */
                queue_ptr -> tx_queue_suspension_list =  TX_NULL;
  401ee6:	2300      	movs	r3, #0
  401ee8:	62a3      	str	r3, [r4, #40]	; 0x28
                next_thread -> tx_thread_suspended_previous =   previous_thread;
                previous_thread -> tx_thread_suspended_next =   next_thread;
            }

            /* Decrement the suspension count.  */
            queue_ptr -> tx_queue_suspended_count =  suspended_count;
  401eea:	62e5      	str	r5, [r4, #44]	; 0x2c

            /* Prepare for resumption of the thread.  */

            /* Clear cleanup routine to avoid timeout.  */
            thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
  401eec:	2300      	movs	r3, #0
  401eee:	6683      	str	r3, [r0, #104]	; 0x68

            /* Setup source and destination pointers.  */
            source =       TX_VOID_TO_ULONG_POINTER_CONVERT(source_ptr);
            destination =  TX_VOID_TO_ULONG_POINTER_CONVERT(thread_ptr -> tx_thread_additional_suspend_info);
  401ef0:	6fc2      	ldr	r2, [r0, #124]	; 0x7c
            size =         queue_ptr -> tx_queue_message_size;
  401ef2:	68a3      	ldr	r3, [r4, #8]

            /* Copy message. Note that the source and destination pointers are
               incremented by the macro.  */
            TX_QUEUE_MESSAGE_COPY(source, destination, size)
  401ef4:	680d      	ldr	r5, [r1, #0]
  401ef6:	6015      	str	r5, [r2, #0]
  401ef8:	2b01      	cmp	r3, #1
  401efa:	d908      	bls.n	401f0e <_tx_queue_send+0x92>
  401efc:	3b01      	subs	r3, #1
  401efe:	d006      	beq.n	401f0e <_tx_queue_send+0x92>
  401f00:	3104      	adds	r1, #4
  401f02:	f851 5b04 	ldr.w	r5, [r1], #4
  401f06:	f842 5f04 	str.w	r5, [r2, #4]!
  401f0a:	3b01      	subs	r3, #1
  401f0c:	d1f9      	bne.n	401f02 <_tx_queue_send+0x86>

            /* Put return status into the thread control block.  */
            thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
  401f0e:	2300      	movs	r3, #0
  401f10:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

            /* Pickup the notify callback routine for this queue.  */
            queue_send_notify =  queue_ptr -> tx_queue_send_notify;
  401f14:	6ba5      	ldr	r5, [r4, #56]	; 0x38
            /* Restore interrupts.  */
            TX_RESTORE
#else

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
  401f16:	4a2c      	ldr	r2, [pc, #176]	; (401fc8 <_tx_queue_send+0x14c>)
  401f18:	6813      	ldr	r3, [r2, #0]
  401f1a:	3301      	adds	r3, #1
  401f1c:	6013      	str	r3, [r2, #0]
  401f1e:	f386 8810 	msr	PRIMASK, r6

            /* Restore interrupts.  */
            TX_RESTORE

            /* Resume thread.  */
            _tx_thread_system_resume(thread_ptr);
  401f22:	4b2a      	ldr	r3, [pc, #168]	; (401fcc <_tx_queue_send+0x150>)
  401f24:	4798      	blx	r3
#endif

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

            /* Determine if a notify callback is required.  */
            if (queue_send_notify != TX_NULL)
  401f26:	2d00      	cmp	r5, #0
  401f28:	d04c      	beq.n	401fc4 <_tx_queue_send+0x148>
            {

                /* Call application queue send notification.  */
                (queue_send_notify)(queue_ptr);
  401f2a:	4620      	mov	r0, r4
  401f2c:	47a8      	blx	r5
    status =  TX_SUCCESS;
  401f2e:	2000      	movs	r0, #0
  401f30:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                queue_ptr -> tx_queue_suspension_list =  thread_ptr -> tx_thread_suspended_next;
  401f32:	6f03      	ldr	r3, [r0, #112]	; 0x70
  401f34:	62a3      	str	r3, [r4, #40]	; 0x28
                next_thread =                            thread_ptr -> tx_thread_suspended_next;
  401f36:	6f03      	ldr	r3, [r0, #112]	; 0x70
                queue_ptr -> tx_queue_suspension_list =  next_thread;
  401f38:	62a3      	str	r3, [r4, #40]	; 0x28
                previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
  401f3a:	6f42      	ldr	r2, [r0, #116]	; 0x74
                next_thread -> tx_thread_suspended_previous =   previous_thread;
  401f3c:	675a      	str	r2, [r3, #116]	; 0x74
                previous_thread -> tx_thread_suspended_next =   next_thread;
  401f3e:	6713      	str	r3, [r2, #112]	; 0x70
  401f40:	e7d3      	b.n	401eea <_tx_queue_send+0x6e>
#endif
        }
    }

    /* At this point, the queue is full. Determine if suspension is requested.  */
    else if (wait_option != TX_NO_WAIT)
  401f42:	b91a      	cbnz	r2, 401f4c <_tx_queue_send+0xd0>
  401f44:	f386 8810 	msr	PRIMASK, r6

        /* Restore interrupts.  */
        TX_RESTORE

        /* Return error completion.  */
        status =  TX_QUEUE_FULL;
  401f48:	200b      	movs	r0, #11
  401f4a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (_tx_thread_preempt_disable != ((UINT) 0))
  401f4c:	4b1e      	ldr	r3, [pc, #120]	; (401fc8 <_tx_queue_send+0x14c>)
  401f4e:	681b      	ldr	r3, [r3, #0]
  401f50:	b11b      	cbz	r3, 401f5a <_tx_queue_send+0xde>
  401f52:	f386 8810 	msr	PRIMASK, r6
            status =  TX_QUEUE_FULL;
  401f56:	200b      	movs	r0, #11
  401f58:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            TX_THREAD_GET_CURRENT(thread_ptr)
  401f5a:	4b1d      	ldr	r3, [pc, #116]	; (401fd0 <_tx_queue_send+0x154>)
  401f5c:	681f      	ldr	r7, [r3, #0]
            thread_ptr -> tx_thread_suspend_cleanup =  &(_tx_queue_cleanup);
  401f5e:	4b1d      	ldr	r3, [pc, #116]	; (401fd4 <_tx_queue_send+0x158>)
  401f60:	66bb      	str	r3, [r7, #104]	; 0x68
            thread_ptr -> tx_thread_suspend_control_block =    (VOID *) queue_ptr;
  401f62:	66f8      	str	r0, [r7, #108]	; 0x6c
            thread_ptr -> tx_thread_additional_suspend_info =  (VOID *) source_ptr;
  401f64:	67f9      	str	r1, [r7, #124]	; 0x7c
            thread_ptr -> tx_thread_suspend_option =           TX_FALSE;
  401f66:	2300      	movs	r3, #0
  401f68:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
            thread_ptr -> tx_thread_suspension_sequence++;
  401f6c:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
  401f70:	3301      	adds	r3, #1
  401f72:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
            if (suspended_count == TX_NO_SUSPENSIONS)
  401f76:	b9e5      	cbnz	r5, 401fb2 <_tx_queue_send+0x136>
                queue_ptr -> tx_queue_suspension_list =         thread_ptr;
  401f78:	6287      	str	r7, [r0, #40]	; 0x28
                thread_ptr -> tx_thread_suspended_next =        thread_ptr;
  401f7a:	673f      	str	r7, [r7, #112]	; 0x70
                thread_ptr -> tx_thread_suspended_previous =    thread_ptr;
  401f7c:	677f      	str	r7, [r7, #116]	; 0x74
            queue_ptr -> tx_queue_suspended_count =  suspended_count + ((UINT) 1);
  401f7e:	3501      	adds	r5, #1
  401f80:	62e5      	str	r5, [r4, #44]	; 0x2c
            thread_ptr -> tx_thread_state =    TX_QUEUE_SUSP;
  401f82:	2305      	movs	r3, #5
  401f84:	633b      	str	r3, [r7, #48]	; 0x30
            queue_send_notify =  queue_ptr -> tx_queue_send_notify;
  401f86:	6ba5      	ldr	r5, [r4, #56]	; 0x38
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
  401f88:	2301      	movs	r3, #1
  401f8a:	63bb      	str	r3, [r7, #56]	; 0x38
            thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
  401f8c:	64fa      	str	r2, [r7, #76]	; 0x4c
            _tx_thread_preempt_disable++;
  401f8e:	4a0e      	ldr	r2, [pc, #56]	; (401fc8 <_tx_queue_send+0x14c>)
  401f90:	6813      	ldr	r3, [r2, #0]
  401f92:	3301      	adds	r3, #1
  401f94:	6013      	str	r3, [r2, #0]
  401f96:	f386 8810 	msr	PRIMASK, r6
            _tx_thread_system_suspend(thread_ptr);
  401f9a:	4638      	mov	r0, r7
  401f9c:	4b0e      	ldr	r3, [pc, #56]	; (401fd8 <_tx_queue_send+0x15c>)
  401f9e:	4798      	blx	r3
            if (thread_ptr -> tx_thread_suspend_status == TX_SUCCESS)
  401fa0:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
                if (queue_send_notify != TX_NULL)
  401fa4:	b913      	cbnz	r3, 401fac <_tx_queue_send+0x130>
  401fa6:	b10d      	cbz	r5, 401fac <_tx_queue_send+0x130>
                    (queue_send_notify)(queue_ptr);
  401fa8:	4620      	mov	r0, r4
  401faa:	47a8      	blx	r5
            status =  thread_ptr -> tx_thread_suspend_status;
  401fac:	f8d7 0084 	ldr.w	r0, [r7, #132]	; 0x84
  401fb0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                next_thread =                                   queue_ptr -> tx_queue_suspension_list;
  401fb2:	6a83      	ldr	r3, [r0, #40]	; 0x28
                thread_ptr -> tx_thread_suspended_next =        next_thread;
  401fb4:	673b      	str	r3, [r7, #112]	; 0x70
                previous_thread =                               next_thread -> tx_thread_suspended_previous;
  401fb6:	6f59      	ldr	r1, [r3, #116]	; 0x74
                thread_ptr -> tx_thread_suspended_previous =    previous_thread;
  401fb8:	6779      	str	r1, [r7, #116]	; 0x74
                previous_thread -> tx_thread_suspended_next =   thread_ptr;
  401fba:	670f      	str	r7, [r1, #112]	; 0x70
                next_thread -> tx_thread_suspended_previous =   thread_ptr;
  401fbc:	675f      	str	r7, [r3, #116]	; 0x74
  401fbe:	e7de      	b.n	401f7e <_tx_queue_send+0x102>
    status =  TX_SUCCESS;
  401fc0:	2000      	movs	r0, #0
  401fc2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  401fc4:	2000      	movs	r0, #0
    }

    /* Return completion status.  */
    return(status);
}
  401fc6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  401fc8:	2040058c 	.word	0x2040058c
  401fcc:	004024a5 	.word	0x004024a5
  401fd0:	20400590 	.word	0x20400590
  401fd4:	00401b75 	.word	0x00401b75
  401fd8:	004025d9 	.word	0x004025d9

00401fdc <_tx_semaphore_cleanup>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_semaphore_cleanup(TX_THREAD *thread_ptr, ULONG suspension_sequence)
{
  401fdc:	b510      	push	{r4, lr}
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  401fde:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  401fe2:	b672      	cpsid	i

    /* Disable interrupts to remove the suspended thread from the semaphore.  */
    TX_DISABLE

    /* Determine if the cleanup is still required.  */
    if (thread_ptr -> tx_thread_suspend_cleanup == &(_tx_semaphore_cleanup))
  401fe4:	6e84      	ldr	r4, [r0, #104]	; 0x68
  401fe6:	4a1b      	ldr	r2, [pc, #108]	; (402054 <_tx_semaphore_cleanup+0x78>)
  401fe8:	4294      	cmp	r4, r2
  401fea:	d002      	beq.n	401ff2 <_tx_semaphore_cleanup+0x16>
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  401fec:	f383 8810 	msr	PRIMASK, r3
  401ff0:	bd10      	pop	{r4, pc}
    {

        /* Check for valid suspension sequence.  */
        if (suspension_sequence == thread_ptr -> tx_thread_suspension_sequence)
  401ff2:	f8d0 20b0 	ldr.w	r2, [r0, #176]	; 0xb0
  401ff6:	428a      	cmp	r2, r1
  401ff8:	d1f8      	bne.n	401fec <_tx_semaphore_cleanup+0x10>
        {

            /* Setup pointer to semaphore control block.  */
            semaphore_ptr =  TX_VOID_TO_SEMAPHORE_POINTER_CONVERT(thread_ptr -> tx_thread_suspend_control_block);
  401ffa:	6ec2      	ldr	r2, [r0, #108]	; 0x6c

            /* Check for a NULL semaphore pointer.  */
            if (semaphore_ptr != TX_NULL)
  401ffc:	2a00      	cmp	r2, #0
  401ffe:	d0f5      	beq.n	401fec <_tx_semaphore_cleanup+0x10>
            {

                /* Check for a valid semaphore ID.  */
                if (semaphore_ptr -> tx_semaphore_id == TX_SEMAPHORE_ID)
  402000:	6814      	ldr	r4, [r2, #0]
  402002:	4915      	ldr	r1, [pc, #84]	; (402058 <_tx_semaphore_cleanup+0x7c>)
  402004:	428c      	cmp	r4, r1
  402006:	d1f1      	bne.n	401fec <_tx_semaphore_cleanup+0x10>
                {

                    /* Determine if there are any thread suspensions.  */
                    if (semaphore_ptr -> tx_semaphore_suspended_count != TX_NO_SUSPENSIONS)
  402008:	6911      	ldr	r1, [r2, #16]
  40200a:	2900      	cmp	r1, #0
  40200c:	d0ee      	beq.n	401fec <_tx_semaphore_cleanup+0x10>
#endif

                        /* Yes, we still have thread suspension!  */

                        /* Clear the suspension cleanup flag.  */
                        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
  40200e:	2100      	movs	r1, #0
  402010:	6681      	str	r1, [r0, #104]	; 0x68

                        /* Decrement the suspended count.  */
                        semaphore_ptr -> tx_semaphore_suspended_count--;
  402012:	6911      	ldr	r1, [r2, #16]
  402014:	3901      	subs	r1, #1
  402016:	6111      	str	r1, [r2, #16]
                        suspended_count =  semaphore_ptr -> tx_semaphore_suspended_count;

                        /* Remove the suspended thread from the list.  */

                        /* See if this is the only suspended thread on the list.  */
                        if (suspended_count == TX_NO_SUSPENSIONS)
  402018:	b991      	cbnz	r1, 402040 <_tx_semaphore_cleanup+0x64>
                        {

                            /* Yes, the only suspended thread.  */

                            /* Update the head pointer.  */
                            semaphore_ptr -> tx_semaphore_suspension_list =  TX_NULL;
  40201a:	60d1      	str	r1, [r2, #12]
                            }
                        }

                        /* Now we need to determine if this cleanup is from a terminate, timeout,
                           or from a wait abort.  */
                        if (thread_ptr -> tx_thread_state == TX_SEMAPHORE_SUSP)
  40201c:	6b02      	ldr	r2, [r0, #48]	; 0x30
  40201e:	2a06      	cmp	r2, #6
  402020:	d1e4      	bne.n	401fec <_tx_semaphore_cleanup+0x10>
                            /* Increment the number of timeouts on this semaphore.  */
                            semaphore_ptr -> tx_semaphore_performance_timeout_count++;
#endif

                            /* Setup return status.  */
                            thread_ptr -> tx_thread_suspend_status =  TX_NO_INSTANCE;
  402022:	220d      	movs	r2, #13
  402024:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84
                            /* Resume the thread!  */
                            _tx_thread_system_ni_resume(thread_ptr);
#else

                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
  402028:	490c      	ldr	r1, [pc, #48]	; (40205c <_tx_semaphore_cleanup+0x80>)
  40202a:	680a      	ldr	r2, [r1, #0]
  40202c:	3201      	adds	r2, #1
  40202e:	600a      	str	r2, [r1, #0]
  402030:	f383 8810 	msr	PRIMASK, r3

                            /* Restore interrupts.  */
                            TX_RESTORE

                            /* Resume the thread!  */
                            _tx_thread_system_resume(thread_ptr);
  402034:	4b0a      	ldr	r3, [pc, #40]	; (402060 <_tx_semaphore_cleanup+0x84>)
  402036:	4798      	blx	r3
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  402038:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  40203c:	b672      	cpsid	i
  40203e:	e7d5      	b.n	401fec <_tx_semaphore_cleanup+0x10>
                            next_thread =                                   thread_ptr -> tx_thread_suspended_next;
  402040:	6f01      	ldr	r1, [r0, #112]	; 0x70
                            previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
  402042:	6f44      	ldr	r4, [r0, #116]	; 0x74
                            next_thread -> tx_thread_suspended_previous =   previous_thread;
  402044:	674c      	str	r4, [r1, #116]	; 0x74
                            previous_thread -> tx_thread_suspended_next =   next_thread;
  402046:	6721      	str	r1, [r4, #112]	; 0x70
                            if (semaphore_ptr -> tx_semaphore_suspension_list == thread_ptr)
  402048:	68d4      	ldr	r4, [r2, #12]
  40204a:	42a0      	cmp	r0, r4
                                semaphore_ptr -> tx_semaphore_suspension_list =   next_thread;
  40204c:	bf08      	it	eq
  40204e:	60d1      	streq	r1, [r2, #12]
  402050:	e7e4      	b.n	40201c <_tx_semaphore_cleanup+0x40>
  402052:	bf00      	nop
  402054:	00401fdd 	.word	0x00401fdd
  402058:	53454d41 	.word	0x53454d41
  40205c:	2040058c 	.word	0x2040058c
  402060:	004024a5 	.word	0x004024a5

00402064 <_tx_semaphore_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_semaphore_create(TX_SEMAPHORE *semaphore_ptr, CHAR *name_ptr, ULONG initial_count)
{
  402064:	b570      	push	{r4, r5, r6, lr}
  402066:	4604      	mov	r4, r0
  402068:	460e      	mov	r6, r1
  40206a:	4615      	mov	r5, r2
TX_SEMAPHORE    *next_semaphore;
TX_SEMAPHORE    *previous_semaphore;


    /* Initialize semaphore control block to all zeros.  */
    TX_MEMSET(semaphore_ptr, 0, (sizeof(TX_SEMAPHORE)));
  40206c:	2220      	movs	r2, #32
  40206e:	2100      	movs	r1, #0
  402070:	4b0f      	ldr	r3, [pc, #60]	; (4020b0 <_tx_semaphore_create+0x4c>)
  402072:	4798      	blx	r3

    /* Setup the basic semaphore fields.  */
    semaphore_ptr -> tx_semaphore_name =             name_ptr;
  402074:	6066      	str	r6, [r4, #4]
    semaphore_ptr -> tx_semaphore_count =            initial_count;
  402076:	60a5      	str	r5, [r4, #8]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  402078:	f3ef 8110 	mrs	r1, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  40207c:	b672      	cpsid	i

    /* Disable interrupts to place the semaphore on the created list.  */
    TX_DISABLE

    /* Setup the semaphore ID to make it valid.  */
    semaphore_ptr -> tx_semaphore_id =  TX_SEMAPHORE_ID;
  40207e:	4b0d      	ldr	r3, [pc, #52]	; (4020b4 <_tx_semaphore_create+0x50>)
  402080:	6023      	str	r3, [r4, #0]

    /* Place the semaphore on the list of created semaphores.  First,
       check for an empty list.  */
    if (_tx_semaphore_created_count == TX_EMPTY)
  402082:	4b0d      	ldr	r3, [pc, #52]	; (4020b8 <_tx_semaphore_create+0x54>)
  402084:	681b      	ldr	r3, [r3, #0]
  402086:	b173      	cbz	r3, 4020a6 <_tx_semaphore_create+0x42>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_semaphore =      _tx_semaphore_created_ptr;
  402088:	4b0c      	ldr	r3, [pc, #48]	; (4020bc <_tx_semaphore_create+0x58>)
  40208a:	681b      	ldr	r3, [r3, #0]
        previous_semaphore =  next_semaphore -> tx_semaphore_created_previous;
  40208c:	699a      	ldr	r2, [r3, #24]

        /* Place the new semaphore in the list.  */
        next_semaphore -> tx_semaphore_created_previous =  semaphore_ptr;
  40208e:	619c      	str	r4, [r3, #24]
        previous_semaphore -> tx_semaphore_created_next =  semaphore_ptr;
  402090:	6154      	str	r4, [r2, #20]

        /* Setup this semaphore's next and previous created links.  */
        semaphore_ptr -> tx_semaphore_created_previous =  previous_semaphore;
  402092:	61a2      	str	r2, [r4, #24]
        semaphore_ptr -> tx_semaphore_created_next =      next_semaphore;
  402094:	6163      	str	r3, [r4, #20]
    }

    /* Increment the created count.  */
    _tx_semaphore_created_count++;
  402096:	4a08      	ldr	r2, [pc, #32]	; (4020b8 <_tx_semaphore_create+0x54>)
  402098:	6813      	ldr	r3, [r2, #0]
  40209a:	3301      	adds	r3, #1
  40209c:	6013      	str	r3, [r2, #0]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  40209e:	f381 8810 	msr	PRIMASK, r1
    /* Restore interrupts.  */
    TX_RESTORE

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
}
  4020a2:	2000      	movs	r0, #0
  4020a4:	bd70      	pop	{r4, r5, r6, pc}
        _tx_semaphore_created_ptr =                       semaphore_ptr;
  4020a6:	4b05      	ldr	r3, [pc, #20]	; (4020bc <_tx_semaphore_create+0x58>)
  4020a8:	601c      	str	r4, [r3, #0]
        semaphore_ptr -> tx_semaphore_created_next =      semaphore_ptr;
  4020aa:	6164      	str	r4, [r4, #20]
        semaphore_ptr -> tx_semaphore_created_previous =  semaphore_ptr;
  4020ac:	61a4      	str	r4, [r4, #24]
  4020ae:	e7f2      	b.n	402096 <_tx_semaphore_create+0x32>
  4020b0:	00403361 	.word	0x00403361
  4020b4:	53454d41 	.word	0x53454d41
  4020b8:	204004e0 	.word	0x204004e0
  4020bc:	204004d0 	.word	0x204004d0

004020c0 <_tx_semaphore_get>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_semaphore_get(TX_SEMAPHORE *semaphore_ptr, ULONG wait_option)
{
  4020c0:	b538      	push	{r3, r4, r5, lr}
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  4020c2:	f3ef 8210 	mrs	r2, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  4020c6:	b672      	cpsid	i

    /* Log this kernel call.  */
    TX_EL_SEMAPHORE_GET_INSERT

    /* Determine if there is an instance of the semaphore.  */
    if (semaphore_ptr -> tx_semaphore_count != ((ULONG) 0))
  4020c8:	6883      	ldr	r3, [r0, #8]
  4020ca:	b923      	cbnz	r3, 4020d6 <_tx_semaphore_get+0x16>
        /* Restore interrupts.  */
        TX_RESTORE
    }

    /* Determine if the request specifies suspension.  */
    else if (wait_option != TX_NO_WAIT)
  4020cc:	b949      	cbnz	r1, 4020e2 <_tx_semaphore_get+0x22>
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  4020ce:	f382 8810 	msr	PRIMASK, r2

        /* Restore interrupts.  */
        TX_RESTORE

        /* Immediate return, return error completion.  */
        status =  TX_NO_INSTANCE;
  4020d2:	200d      	movs	r0, #13
    }

    /* Return completion status.  */
    return(status);
}
  4020d4:	bd38      	pop	{r3, r4, r5, pc}
        semaphore_ptr -> tx_semaphore_count--;
  4020d6:	3b01      	subs	r3, #1
  4020d8:	6083      	str	r3, [r0, #8]
  4020da:	f382 8810 	msr	PRIMASK, r2
    status =  TX_SUCCESS;
  4020de:	2000      	movs	r0, #0
  4020e0:	bd38      	pop	{r3, r4, r5, pc}
        if (_tx_thread_preempt_disable != ((UINT) 0))
  4020e2:	4b18      	ldr	r3, [pc, #96]	; (402144 <_tx_semaphore_get+0x84>)
  4020e4:	681b      	ldr	r3, [r3, #0]
  4020e6:	b11b      	cbz	r3, 4020f0 <_tx_semaphore_get+0x30>
  4020e8:	f382 8810 	msr	PRIMASK, r2
            status =  TX_NO_INSTANCE;
  4020ec:	200d      	movs	r0, #13
  4020ee:	bd38      	pop	{r3, r4, r5, pc}
            TX_THREAD_GET_CURRENT(thread_ptr)
  4020f0:	4b15      	ldr	r3, [pc, #84]	; (402148 <_tx_semaphore_get+0x88>)
  4020f2:	681c      	ldr	r4, [r3, #0]
            thread_ptr -> tx_thread_suspend_cleanup =  &(_tx_semaphore_cleanup);
  4020f4:	4b15      	ldr	r3, [pc, #84]	; (40214c <_tx_semaphore_get+0x8c>)
  4020f6:	66a3      	str	r3, [r4, #104]	; 0x68
            thread_ptr -> tx_thread_suspend_control_block =  (VOID *) semaphore_ptr;
  4020f8:	66e0      	str	r0, [r4, #108]	; 0x6c
            thread_ptr -> tx_thread_suspension_sequence++;
  4020fa:	f8d4 30b0 	ldr.w	r3, [r4, #176]	; 0xb0
  4020fe:	3301      	adds	r3, #1
  402100:	f8c4 30b0 	str.w	r3, [r4, #176]	; 0xb0
            if (semaphore_ptr -> tx_semaphore_suspended_count == TX_NO_SUSPENSIONS)
  402104:	6903      	ldr	r3, [r0, #16]
  402106:	b9b3      	cbnz	r3, 402136 <_tx_semaphore_get+0x76>
                semaphore_ptr -> tx_semaphore_suspension_list =         thread_ptr;
  402108:	60c4      	str	r4, [r0, #12]
                thread_ptr -> tx_thread_suspended_next =                thread_ptr;
  40210a:	6724      	str	r4, [r4, #112]	; 0x70
                thread_ptr -> tx_thread_suspended_previous =            thread_ptr;
  40210c:	6764      	str	r4, [r4, #116]	; 0x74
            semaphore_ptr -> tx_semaphore_suspended_count++;
  40210e:	6903      	ldr	r3, [r0, #16]
  402110:	3301      	adds	r3, #1
  402112:	6103      	str	r3, [r0, #16]
            thread_ptr -> tx_thread_state =    TX_SEMAPHORE_SUSP;
  402114:	2306      	movs	r3, #6
  402116:	6323      	str	r3, [r4, #48]	; 0x30
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
  402118:	2301      	movs	r3, #1
  40211a:	63a3      	str	r3, [r4, #56]	; 0x38
            thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
  40211c:	64e1      	str	r1, [r4, #76]	; 0x4c
            _tx_thread_preempt_disable++;
  40211e:	4909      	ldr	r1, [pc, #36]	; (402144 <_tx_semaphore_get+0x84>)
  402120:	680b      	ldr	r3, [r1, #0]
  402122:	3301      	adds	r3, #1
  402124:	600b      	str	r3, [r1, #0]
  402126:	f382 8810 	msr	PRIMASK, r2
            _tx_thread_system_suspend(thread_ptr);
  40212a:	4620      	mov	r0, r4
  40212c:	4b08      	ldr	r3, [pc, #32]	; (402150 <_tx_semaphore_get+0x90>)
  40212e:	4798      	blx	r3
            status =  thread_ptr -> tx_thread_suspend_status;
  402130:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
  402134:	bd38      	pop	{r3, r4, r5, pc}
                next_thread =                                   semaphore_ptr -> tx_semaphore_suspension_list;
  402136:	68c3      	ldr	r3, [r0, #12]
                thread_ptr -> tx_thread_suspended_next =        next_thread;
  402138:	6723      	str	r3, [r4, #112]	; 0x70
                previous_thread =                               next_thread -> tx_thread_suspended_previous;
  40213a:	6f5d      	ldr	r5, [r3, #116]	; 0x74
                thread_ptr -> tx_thread_suspended_previous =    previous_thread;
  40213c:	6765      	str	r5, [r4, #116]	; 0x74
                previous_thread -> tx_thread_suspended_next =   thread_ptr;
  40213e:	672c      	str	r4, [r5, #112]	; 0x70
                next_thread -> tx_thread_suspended_previous =   thread_ptr;
  402140:	675c      	str	r4, [r3, #116]	; 0x74
  402142:	e7e4      	b.n	40210e <_tx_semaphore_get+0x4e>
  402144:	2040058c 	.word	0x2040058c
  402148:	20400590 	.word	0x20400590
  40214c:	00401fdd 	.word	0x00401fdd
  402150:	004025d9 	.word	0x004025d9

00402154 <_tx_semaphore_put>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_semaphore_put(TX_SEMAPHORE *semaphore_ptr)
{
  402154:	b538      	push	{r3, r4, r5, lr}
  402156:	4604      	mov	r4, r0
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  402158:	f3ef 8210 	mrs	r2, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  40215c:	b672      	cpsid	i

    /* Log this kernel call.  */
    TX_EL_SEMAPHORE_PUT_INSERT

    /* Pickup the number of suspended threads.  */
    suspended_count =  semaphore_ptr -> tx_semaphore_suspended_count;
  40215e:	6903      	ldr	r3, [r0, #16]

    /* Determine if there are any threads suspended on the semaphore.  */
    if (suspended_count == TX_NO_SUSPENSIONS)
  402160:	b943      	cbnz	r3, 402174 <_tx_semaphore_put+0x20>
    {

        /* Increment the semaphore count.  */
        semaphore_ptr -> tx_semaphore_count++;
  402162:	6883      	ldr	r3, [r0, #8]
  402164:	3301      	adds	r3, #1
  402166:	6083      	str	r3, [r0, #8]

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

        /* Pickup the application notify function.  */
        semaphore_put_notify =  semaphore_ptr -> tx_semaphore_put_notify;
  402168:	69c3      	ldr	r3, [r0, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  40216a:	f382 8810 	msr	PRIMASK, r2
        TX_RESTORE

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

        /* Determine if notification is required.  */
        if (semaphore_put_notify != TX_NULL)
  40216e:	b1bb      	cbz	r3, 4021a0 <_tx_semaphore_put+0x4c>
        {

            /* Yes, call the appropriate notify callback function.  */
            (semaphore_put_notify)(semaphore_ptr);
  402170:	4798      	blx	r3
  402172:	e015      	b.n	4021a0 <_tx_semaphore_put+0x4c>
    {

        /* A thread is suspended on this semaphore.  */

        /* Pickup the pointer to the first suspended thread.  */
        thread_ptr =  semaphore_ptr -> tx_semaphore_suspension_list;
  402174:	68c0      	ldr	r0, [r0, #12]

        /* Remove the suspended thread from the list.  */

        /* See if this is the only suspended thread on the list.  */
        suspended_count--;
        if (suspended_count == TX_NO_SUSPENSIONS)
  402176:	3b01      	subs	r3, #1
  402178:	d114      	bne.n	4021a4 <_tx_semaphore_put+0x50>
        {

            /* Yes, the only suspended thread.  */

            /* Update the head pointer.  */
            semaphore_ptr -> tx_semaphore_suspension_list =  TX_NULL;
  40217a:	2100      	movs	r1, #0
  40217c:	60e1      	str	r1, [r4, #12]
            next_thread -> tx_thread_suspended_previous =   previous_thread;
            previous_thread -> tx_thread_suspended_next =   next_thread;
        }

        /* Decrement the suspension count.  */
        semaphore_ptr -> tx_semaphore_suspended_count =  suspended_count;
  40217e:	6123      	str	r3, [r4, #16]

        /* Prepare for resumption of the first thread.  */

        /* Clear cleanup routine to avoid timeout.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
  402180:	2300      	movs	r3, #0
  402182:	6683      	str	r3, [r0, #104]	; 0x68

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

        /* Pickup the application notify function.  */
        semaphore_put_notify =  semaphore_ptr -> tx_semaphore_put_notify;
  402184:	69e5      	ldr	r5, [r4, #28]
#endif

        /* Put return status into the thread control block.  */
        thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
  402186:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
        /* Restore interrupts.  */
        TX_RESTORE
#else

        /* Temporarily disable preemption.  */
        _tx_thread_preempt_disable++;
  40218a:	4909      	ldr	r1, [pc, #36]	; (4021b0 <_tx_semaphore_put+0x5c>)
  40218c:	680b      	ldr	r3, [r1, #0]
  40218e:	3301      	adds	r3, #1
  402190:	600b      	str	r3, [r1, #0]
  402192:	f382 8810 	msr	PRIMASK, r2

        /* Restore interrupts.  */
        TX_RESTORE

        /* Resume thread.  */
        _tx_thread_system_resume(thread_ptr);
  402196:	4b07      	ldr	r3, [pc, #28]	; (4021b4 <_tx_semaphore_put+0x60>)
  402198:	4798      	blx	r3
#endif

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

        /* Determine if notification is required.  */
        if (semaphore_put_notify != TX_NULL)
  40219a:	b10d      	cbz	r5, 4021a0 <_tx_semaphore_put+0x4c>
        {

            /* Yes, call the appropriate notify callback function.  */
            (semaphore_put_notify)(semaphore_ptr);
  40219c:	4620      	mov	r0, r4
  40219e:	47a8      	blx	r5
#endif
    }

    /* Return successful completion.  */
    return(TX_SUCCESS);
}
  4021a0:	2000      	movs	r0, #0
  4021a2:	bd38      	pop	{r3, r4, r5, pc}
            next_thread =                                     thread_ptr -> tx_thread_suspended_next;
  4021a4:	6f01      	ldr	r1, [r0, #112]	; 0x70
            semaphore_ptr -> tx_semaphore_suspension_list =   next_thread;
  4021a6:	60e1      	str	r1, [r4, #12]
            previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
  4021a8:	6f45      	ldr	r5, [r0, #116]	; 0x74
            next_thread -> tx_thread_suspended_previous =   previous_thread;
  4021aa:	674d      	str	r5, [r1, #116]	; 0x74
            previous_thread -> tx_thread_suspended_next =   next_thread;
  4021ac:	6729      	str	r1, [r5, #112]	; 0x70
  4021ae:	e7e6      	b.n	40217e <_tx_semaphore_put+0x2a>
  4021b0:	2040058c 	.word	0x2040058c
  4021b4:	004024a5 	.word	0x004024a5

004021b8 <_tx_thread_create>:
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_create(TX_THREAD *thread_ptr, CHAR *name_ptr, VOID (*entry_function)(ULONG id), ULONG entry_input,
                            VOID *stack_start, ULONG stack_size, UINT priority, UINT preempt_threshold,
                            ULONG time_slice, UINT auto_start)
{
  4021b8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4021bc:	4604      	mov	r4, r0
  4021be:	468b      	mov	fp, r1
  4021c0:	4692      	mov	sl, r2
  4021c2:	4699      	mov	r9, r3
  4021c4:	9d0a      	ldr	r5, [sp, #40]	; 0x28
  4021c6:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
  4021c8:	9f0c      	ldr	r7, [sp, #48]	; 0x30
#ifndef TX_DISABLE_STACK_FILLING

    /* Set the thread stack to a pattern prior to creating the initial
       stack frame.  This pattern is used by the stack checking routines
       to see how much has been used.  */
    TX_MEMSET(stack_start, ((UCHAR) TX_STACK_FILL), stack_size);
  4021ca:	4632      	mov	r2, r6
  4021cc:	21ef      	movs	r1, #239	; 0xef
  4021ce:	4628      	mov	r0, r5
  4021d0:	f8df 811c 	ldr.w	r8, [pc, #284]	; 4022f0 <_tx_thread_create+0x138>
  4021d4:	47c0      	blx	r8

    /* Prepare the thread control block prior to placing it on the created
       list.  */

    /* Initialize thread control block to all zeros.  */
    TX_MEMSET(thread_ptr, 0, (sizeof(TX_THREAD)));
  4021d6:	22b4      	movs	r2, #180	; 0xb4
  4021d8:	2100      	movs	r1, #0
  4021da:	4620      	mov	r0, r4
  4021dc:	47c0      	blx	r8

    /* Place the supplied parameters into the thread's control block.  */
    thread_ptr -> tx_thread_name =              name_ptr;
  4021de:	f8c4 b028 	str.w	fp, [r4, #40]	; 0x28
    thread_ptr -> tx_thread_entry =             entry_function;
  4021e2:	f8c4 a044 	str.w	sl, [r4, #68]	; 0x44
    thread_ptr -> tx_thread_entry_parameter =   entry_input;
  4021e6:	f8c4 9048 	str.w	r9, [r4, #72]	; 0x48
    thread_ptr -> tx_thread_stack_start =       stack_start;
  4021ea:	60e5      	str	r5, [r4, #12]
    thread_ptr -> tx_thread_stack_size =        stack_size;
  4021ec:	6166      	str	r6, [r4, #20]
    thread_ptr -> tx_thread_priority =          priority;
  4021ee:	62e7      	str	r7, [r4, #44]	; 0x2c
    thread_ptr -> tx_thread_user_priority =     priority;
  4021f0:	f8c4 7094 	str.w	r7, [r4, #148]	; 0x94
    thread_ptr -> tx_thread_time_slice =        time_slice;
  4021f4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  4021f6:	61a3      	str	r3, [r4, #24]
    thread_ptr -> tx_thread_new_time_slice =    time_slice;
  4021f8:	61e3      	str	r3, [r4, #28]
    thread_ptr -> tx_thread_inherit_priority =  ((UINT) TX_MAX_PRIORITIES);
  4021fa:	2320      	movs	r3, #32
  4021fc:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c

    /* Calculate the end of the thread's stack area.  */
    temp_ptr =  TX_VOID_TO_UCHAR_POINTER_CONVERT(stack_start);
    temp_ptr =  (TX_UCHAR_POINTER_ADD(temp_ptr, (stack_size - ((ULONG) 1))));
  402200:	3e01      	subs	r6, #1
  402202:	4435      	add	r5, r6
    thread_ptr -> tx_thread_stack_end =         TX_UCHAR_TO_VOID_POINTER_CONVERT(temp_ptr);
  402204:	6125      	str	r5, [r4, #16]

#ifndef TX_DISABLE_PREEMPTION_THRESHOLD

    /* Preemption-threshold is enabled, setup accordingly.  */
    thread_ptr -> tx_thread_preempt_threshold =       preempt_threshold;
  402206:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  402208:	63e3      	str	r3, [r4, #60]	; 0x3c
    thread_ptr -> tx_thread_user_preempt_threshold =  preempt_threshold;
  40220a:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
        thread_ptr -> tx_thread_user_preempt_threshold =  priority;
    }
#endif

    /* Now fill in the values that are required for thread initialization.  */
    thread_ptr -> tx_thread_state =  TX_SUSPENDED;
  40220e:	2303      	movs	r3, #3
  402210:	6323      	str	r3, [r4, #48]	; 0x30

    /* Setup the necessary fields in the thread timer block.  */
    TX_THREAD_CREATE_TIMEOUT_SETUP(thread_ptr)
  402212:	4b2c      	ldr	r3, [pc, #176]	; (4022c4 <_tx_thread_create+0x10c>)
  402214:	6563      	str	r3, [r4, #84]	; 0x54
  402216:	65a4      	str	r4, [r4, #88]	; 0x58
    TX_THREAD_CREATE_INTERNAL_EXTENSION(thread_ptr)

    /* Call the target specific stack frame building routine to build the
       thread's initial stack and to setup the actual stack pointer in the
       control block.  */
    _tx_thread_stack_build(thread_ptr, _tx_thread_shell_entry);
  402218:	492b      	ldr	r1, [pc, #172]	; (4022c8 <_tx_thread_create+0x110>)
  40221a:	4620      	mov	r0, r4
  40221c:	4b2b      	ldr	r3, [pc, #172]	; (4022cc <_tx_thread_create+0x114>)
  40221e:	4798      	blx	r3
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  402220:	f3ef 8110 	mrs	r1, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  402224:	b672      	cpsid	i

    /* Prepare to make this thread a member of the created thread list.  */
    TX_DISABLE

    /* Load the thread ID field in the thread control block.  */
    thread_ptr -> tx_thread_id =  TX_THREAD_ID;
  402226:	4b2a      	ldr	r3, [pc, #168]	; (4022d0 <_tx_thread_create+0x118>)
  402228:	6023      	str	r3, [r4, #0]

    /* Place the thread on the list of created threads.  First,
       check for an empty list.  */
    if (_tx_thread_created_count == TX_EMPTY)
  40222a:	4b2a      	ldr	r3, [pc, #168]	; (4022d4 <_tx_thread_create+0x11c>)
  40222c:	681b      	ldr	r3, [r3, #0]
  40222e:	bb03      	cbnz	r3, 402272 <_tx_thread_create+0xba>
    {

        /* The created thread list is empty.  Add thread to empty list.  */
        _tx_thread_created_ptr =                    thread_ptr;
  402230:	4b29      	ldr	r3, [pc, #164]	; (4022d8 <_tx_thread_create+0x120>)
  402232:	601c      	str	r4, [r3, #0]
        thread_ptr -> tx_thread_created_next =      thread_ptr;
  402234:	f8c4 4088 	str.w	r4, [r4, #136]	; 0x88
        thread_ptr -> tx_thread_created_previous =  thread_ptr;
  402238:	f8c4 408c 	str.w	r4, [r4, #140]	; 0x8c
        thread_ptr -> tx_thread_created_previous =  previous_thread;
        thread_ptr -> tx_thread_created_next =      next_thread;
    }

    /* Increment the thread created count.  */
    _tx_thread_created_count++;
  40223c:	4a25      	ldr	r2, [pc, #148]	; (4022d4 <_tx_thread_create+0x11c>)
  40223e:	6813      	ldr	r3, [r2, #0]
  402240:	3301      	adds	r3, #1
  402242:	6013      	str	r3, [r2, #0]
    TX_EL_THREAD_CREATE_INSERT

#ifndef TX_NOT_INTERRUPTABLE

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
  402244:	4a25      	ldr	r2, [pc, #148]	; (4022dc <_tx_thread_create+0x124>)
  402246:	6813      	ldr	r3, [r2, #0]
  402248:	3301      	adds	r3, #1
  40224a:	6013      	str	r3, [r2, #0]
#endif

    /* Determine if an automatic start was requested.  If so, call the resume
       thread function and then check for a preemption condition.  */
    if (auto_start == TX_AUTO_START)
  40224c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  40224e:	2b01      	cmp	r3, #1
  402250:	d01c      	beq.n	40228c <_tx_thread_create+0xd4>
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  402252:	f381 8810 	msr	PRIMASK, r1
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  402256:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  40225a:	b672      	cpsid	i

        /* Disable interrupts.  */
        TX_DISABLE

        /* Re-enable preemption.  */
        _tx_thread_preempt_disable--;
  40225c:	491f      	ldr	r1, [pc, #124]	; (4022dc <_tx_thread_create+0x124>)
  40225e:	680a      	ldr	r2, [r1, #0]
  402260:	3a01      	subs	r2, #1
  402262:	600a      	str	r2, [r1, #0]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  402264:	f383 8810 	msr	PRIMASK, r3

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
  402268:	4b1d      	ldr	r3, [pc, #116]	; (4022e0 <_tx_thread_create+0x128>)
  40226a:	4798      	blx	r3
#endif
    }

    /* Always return a success.  */
    return(TX_SUCCESS);
}
  40226c:	2000      	movs	r0, #0
  40226e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        next_thread =  _tx_thread_created_ptr;
  402272:	4b19      	ldr	r3, [pc, #100]	; (4022d8 <_tx_thread_create+0x120>)
  402274:	681b      	ldr	r3, [r3, #0]
        previous_thread =  next_thread -> tx_thread_created_previous;
  402276:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
        next_thread -> tx_thread_created_previous =  thread_ptr;
  40227a:	f8c3 408c 	str.w	r4, [r3, #140]	; 0x8c
        previous_thread -> tx_thread_created_next =  thread_ptr;
  40227e:	f8c2 4088 	str.w	r4, [r2, #136]	; 0x88
        thread_ptr -> tx_thread_created_previous =  previous_thread;
  402282:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
        thread_ptr -> tx_thread_created_next =      next_thread;
  402286:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
  40228a:	e7d7      	b.n	40223c <_tx_thread_create+0x84>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
  40228c:	f3ef 8305 	mrs	r3, IPSR
        if (TX_THREAD_GET_SYSTEM_STATE() >= TX_INITIALIZE_IN_PROGRESS)
  402290:	4a14      	ldr	r2, [pc, #80]	; (4022e4 <_tx_thread_create+0x12c>)
  402292:	6812      	ldr	r2, [r2, #0]
  402294:	4313      	orrs	r3, r2
  402296:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
  40229a:	d306      	bcc.n	4022aa <_tx_thread_create+0xf2>
            saved_thread_ptr =  _tx_thread_execute_ptr;
  40229c:	4b12      	ldr	r3, [pc, #72]	; (4022e8 <_tx_thread_create+0x130>)
  40229e:	681d      	ldr	r5, [r3, #0]
            if (saved_thread_ptr != TX_NULL)
  4022a0:	b175      	cbz	r5, 4022c0 <_tx_thread_create+0x108>
                saved_threshold =  saved_thread_ptr -> tx_thread_preempt_threshold;
  4022a2:	6bee      	ldr	r6, [r5, #60]	; 0x3c
                saved_thread_ptr -> tx_thread_preempt_threshold =  saved_thread_ptr -> tx_thread_priority;
  4022a4:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
  4022a6:	63eb      	str	r3, [r5, #60]	; 0x3c
  4022a8:	e001      	b.n	4022ae <_tx_thread_create+0xf6>
UINT                    saved_threshold =  ((UINT) 0);
  4022aa:	2600      	movs	r6, #0
            saved_thread_ptr =  TX_NULL;
  4022ac:	4635      	mov	r5, r6
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  4022ae:	f381 8810 	msr	PRIMASK, r1
        _tx_thread_system_resume(thread_ptr);
  4022b2:	4620      	mov	r0, r4
  4022b4:	4b0d      	ldr	r3, [pc, #52]	; (4022ec <_tx_thread_create+0x134>)
  4022b6:	4798      	blx	r3
        if (saved_thread_ptr != TX_NULL)
  4022b8:	2d00      	cmp	r5, #0
  4022ba:	d0d7      	beq.n	40226c <_tx_thread_create+0xb4>
            saved_thread_ptr -> tx_thread_preempt_threshold =  saved_threshold;
  4022bc:	63ee      	str	r6, [r5, #60]	; 0x3c
  4022be:	e7d5      	b.n	40226c <_tx_thread_create+0xb4>
UINT                    saved_threshold =  ((UINT) 0);
  4022c0:	2600      	movs	r6, #0
  4022c2:	e7f4      	b.n	4022ae <_tx_thread_create+0xf6>
  4022c4:	00402795 	.word	0x00402795
  4022c8:	00402365 	.word	0x00402365
  4022cc:	00402c21 	.word	0x00402c21
  4022d0:	54485244 	.word	0x54485244
  4022d4:	20400584 	.word	0x20400584
  4022d8:	2040057c 	.word	0x2040057c
  4022dc:	2040058c 	.word	0x2040058c
  4022e0:	00402469 	.word	0x00402469
  4022e4:	20400000 	.word	0x20400000
  4022e8:	20400594 	.word	0x20400594
  4022ec:	004024a5 	.word	0x004024a5
  4022f0:	00403361 	.word	0x00403361

004022f4 <_tx_thread_initialize>:
/*                                            stack check error handling, */
/*                                            resulting in version 6.1.9  */   
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_initialize(VOID)
{
  4022f4:	b510      	push	{r4, lr}
       respectively.  */

#ifndef TX_DISABLE_REDUNDANT_CLEARING

    /* Set current thread pointer to NULL.  */
    TX_THREAD_SET_CURRENT(TX_NULL)
  4022f6:	2400      	movs	r4, #0
  4022f8:	4b0e      	ldr	r3, [pc, #56]	; (402334 <_tx_thread_initialize+0x40>)
  4022fa:	601c      	str	r4, [r3, #0]

    /* Initialize the execute thread pointer to NULL.  */
    _tx_thread_execute_ptr =  TX_NULL;
  4022fc:	4b0e      	ldr	r3, [pc, #56]	; (402338 <_tx_thread_initialize+0x44>)
  4022fe:	601c      	str	r4, [r3, #0]

    /* Initialize the priority information.  */
    TX_MEMSET(&_tx_thread_priority_maps[0], 0, (sizeof(_tx_thread_priority_maps)));
  402300:	4b0e      	ldr	r3, [pc, #56]	; (40233c <_tx_thread_initialize+0x48>)
  402302:	601c      	str	r4, [r3, #0]

#ifndef TX_DISABLE_PREEMPTION_THRESHOLD
    TX_MEMSET(&_tx_thread_preempted_maps[0], 0, (sizeof(_tx_thread_preempted_maps)));
  402304:	4b0e      	ldr	r3, [pc, #56]	; (402340 <_tx_thread_initialize+0x4c>)
  402306:	601c      	str	r4, [r3, #0]
#endif
#endif

    /* Setup the highest priority variable to the max, indicating no thread is currently
       ready.  */
    _tx_thread_highest_priority =  ((UINT) TX_MAX_PRIORITIES);
  402308:	2220      	movs	r2, #32
  40230a:	4b0e      	ldr	r3, [pc, #56]	; (402344 <_tx_thread_initialize+0x50>)
  40230c:	601a      	str	r2, [r3, #0]


#ifndef TX_DISABLE_REDUNDANT_CLEARING

    /* Initialize the array of priority head pointers.  */
    TX_MEMSET(&_tx_thread_priority_list[0], 0, (sizeof(_tx_thread_priority_list)));
  40230e:	2280      	movs	r2, #128	; 0x80
  402310:	4621      	mov	r1, r4
  402312:	480d      	ldr	r0, [pc, #52]	; (402348 <_tx_thread_initialize+0x54>)
  402314:	4b0d      	ldr	r3, [pc, #52]	; (40234c <_tx_thread_initialize+0x58>)
  402316:	4798      	blx	r3

    /* Initialize the head pointer of the created threads list and the
       number of threads created.  */
    _tx_thread_created_ptr =        TX_NULL;
  402318:	4b0d      	ldr	r3, [pc, #52]	; (402350 <_tx_thread_initialize+0x5c>)
  40231a:	601c      	str	r4, [r3, #0]
    _tx_thread_created_count =      TX_EMPTY;
  40231c:	4b0d      	ldr	r3, [pc, #52]	; (402354 <_tx_thread_initialize+0x60>)
  40231e:	601c      	str	r4, [r3, #0]

    /* Clear the global preempt disable variable.  */
    _tx_thread_preempt_disable =    ((UINT) 0);
  402320:	4b0d      	ldr	r3, [pc, #52]	; (402358 <_tx_thread_initialize+0x64>)
  402322:	601c      	str	r4, [r3, #0]

    /* Initialize the thread mutex release function pointer.  */
    _tx_thread_mutex_release =      TX_NULL;
  402324:	4b0d      	ldr	r3, [pc, #52]	; (40235c <_tx_thread_initialize+0x68>)
  402326:	601c      	str	r4, [r3, #0]
    TX_MEMSET(&_tx_thread_performance_execute_log[0], 0, (sizeof(_tx_thread_performance_execute_log)));
#endif
#endif

    /* Setup the build options flag. This is used to identify how the ThreadX library was constructed.  */
    _tx_build_options =  _tx_build_options 
  402328:	4a0d      	ldr	r2, [pc, #52]	; (402360 <_tx_thread_initialize+0x6c>)
                            | (((ULONG) (TX_MAX_PRIORITIES/32)) << 24) 
  40232a:	6813      	ldr	r3, [r2, #0]
  40232c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    _tx_build_options =  _tx_build_options 
  402330:	6013      	str	r3, [r2, #0]
  402332:	bd10      	pop	{r4, pc}
  402334:	20400590 	.word	0x20400590
  402338:	20400594 	.word	0x20400594
  40233c:	20400578 	.word	0x20400578
  402340:	2040059c 	.word	0x2040059c
  402344:	20400598 	.word	0x20400598
  402348:	204004f4 	.word	0x204004f4
  40234c:	00403361 	.word	0x00403361
  402350:	2040057c 	.word	0x2040057c
  402354:	20400584 	.word	0x20400584
  402358:	2040058c 	.word	0x2040058c
  40235c:	20400574 	.word	0x20400574
  402360:	20400580 	.word	0x20400580

00402364 <_tx_thread_shell_entry>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_shell_entry(VOID)
{
  402364:	b538      	push	{r3, r4, r5, lr}
VOID            (*entry_exit_notify)(TX_THREAD *notify_thread_ptr, UINT type);
#endif


    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
  402366:	4b19      	ldr	r3, [pc, #100]	; (4023cc <_tx_thread_shell_entry+0x68>)
  402368:	681c      	ldr	r4, [r3, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  40236a:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  40236e:	b672      	cpsid	i

    /* Disable interrupts.  */
    TX_DISABLE

    /* Pickup the entry/exit application callback routine.  */
    entry_exit_notify =  thread_ptr -> tx_thread_entry_exit_notify;
  402370:	f8d4 20ac 	ldr.w	r2, [r4, #172]	; 0xac
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  402374:	f383 8810 	msr	PRIMASK, r3

    /* Restore interrupts.  */
    TX_RESTORE

    /* Determine if an application callback routine is specified.  */
    if (entry_exit_notify != TX_NULL)
  402378:	b112      	cbz	r2, 402380 <_tx_thread_shell_entry+0x1c>
    {

        /* Yes, notify application that this thread has been entered!  */
        (entry_exit_notify)(thread_ptr, TX_THREAD_ENTRY);
  40237a:	2100      	movs	r1, #0
  40237c:	4620      	mov	r0, r4
  40237e:	4790      	blx	r2
    }
#endif

    /* Call current thread's entry function.  */
    (thread_ptr -> tx_thread_entry) (thread_ptr -> tx_thread_entry_parameter);
  402380:	6c63      	ldr	r3, [r4, #68]	; 0x44
  402382:	6ca0      	ldr	r0, [r4, #72]	; 0x48
  402384:	4798      	blx	r3

    /* Suspend thread with a "completed" state.  */

    /* Determine if the application is using mutexes.  */
    if (_tx_thread_mutex_release != TX_NULL)
  402386:	4b12      	ldr	r3, [pc, #72]	; (4023d0 <_tx_thread_shell_entry+0x6c>)
  402388:	681b      	ldr	r3, [r3, #0]
  40238a:	b10b      	cbz	r3, 402390 <_tx_thread_shell_entry+0x2c>
    {

        /* Yes, call the mutex release function via a function pointer that
           is setup during mutex initialization.  */
        (_tx_thread_mutex_release)(thread_ptr);
  40238c:	4620      	mov	r0, r4
  40238e:	4798      	blx	r3
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  402390:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  402394:	b672      	cpsid	i
    TX_DISABLE

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

    /* Pickup the entry/exit application callback routine again.  */
    entry_exit_notify =  thread_ptr -> tx_thread_entry_exit_notify;
  402396:	f8d4 50ac 	ldr.w	r5, [r4, #172]	; 0xac
#endif

    /* Set the status to suspending, in order to indicate the suspension
       is in progress.  */
    thread_ptr -> tx_thread_state =  TX_COMPLETED;
  40239a:	2201      	movs	r2, #1
  40239c:	6322      	str	r2, [r4, #48]	; 0x30
    /* Restore interrupts.  */
    TX_RESTORE
#else

    /* Set the suspending flag. */
    thread_ptr -> tx_thread_suspending =  TX_TRUE;
  40239e:	63a2      	str	r2, [r4, #56]	; 0x38

    /* Setup for no timeout period.  */
    thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  ((ULONG) 0);
  4023a0:	2200      	movs	r2, #0
  4023a2:	64e2      	str	r2, [r4, #76]	; 0x4c

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
  4023a4:	490b      	ldr	r1, [pc, #44]	; (4023d4 <_tx_thread_shell_entry+0x70>)
  4023a6:	680a      	ldr	r2, [r1, #0]
  4023a8:	3201      	adds	r2, #1
  4023aa:	600a      	str	r2, [r1, #0]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  4023ac:	f383 8810 	msr	PRIMASK, r3
    __asm__ volatile (" MRS  %0,CONTROL ": "=r" (control_value) );
  4023b0:	f3ef 8314 	mrs	r3, CONTROL

    /* Restore interrupts.  */
    TX_RESTORE

    /* Perform any additional activities for tool or user purpose.  */
    TX_THREAD_COMPLETED_EXTENSION(thread_ptr)
  4023b4:	f023 0304 	bic.w	r3, r3, #4
    __asm__ volatile (" MSR  CONTROL,%0": : "r" (control_value): "memory" );
  4023b8:	f383 8814 	msr	CONTROL, r3

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

    /* Determine if an application callback routine is specified.  */
    if (entry_exit_notify != TX_NULL)
  4023bc:	b115      	cbz	r5, 4023c4 <_tx_thread_shell_entry+0x60>
    {

        /* Yes, notify application that this thread has exited!  */
        (entry_exit_notify)(thread_ptr, TX_THREAD_EXIT);
  4023be:	2101      	movs	r1, #1
  4023c0:	4620      	mov	r0, r4
  4023c2:	47a8      	blx	r5
    }
#endif

    /* Call actual thread suspension routine.  */
    _tx_thread_system_suspend(thread_ptr);
  4023c4:	4620      	mov	r0, r4
  4023c6:	4b04      	ldr	r3, [pc, #16]	; (4023d8 <_tx_thread_shell_entry+0x74>)
  4023c8:	4798      	blx	r3
  4023ca:	bd38      	pop	{r3, r4, r5, pc}
  4023cc:	20400590 	.word	0x20400590
  4023d0:	20400574 	.word	0x20400574
  4023d4:	2040058c 	.word	0x2040058c
  4023d8:	004025d9 	.word	0x004025d9

004023dc <_tx_thread_sleep>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_sleep(ULONG timer_ticks)
{
  4023dc:	b510      	push	{r4, lr}
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  4023de:	f3ef 8210 	mrs	r2, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  4023e2:	b672      	cpsid	i

    /* Lockout interrupts while the thread is being resumed.  */
    TX_DISABLE

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
  4023e4:	4b1b      	ldr	r3, [pc, #108]	; (402454 <_tx_thread_sleep+0x78>)
  4023e6:	681c      	ldr	r4, [r3, #0]

    /* Determine if this is a legal request.  */

    /* Is there a current thread?  */
    if (thread_ptr == TX_NULL)
  4023e8:	b14c      	cbz	r4, 4023fe <_tx_thread_sleep+0x22>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
  4023ea:	f3ef 8305 	mrs	r3, IPSR
        /* Illegal caller of this service.  */
        status =  TX_CALLER_ERROR;
    }

    /* Is the caller an ISR or Initialization?  */
    else if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
  4023ee:	491a      	ldr	r1, [pc, #104]	; (402458 <_tx_thread_sleep+0x7c>)
  4023f0:	6809      	ldr	r1, [r1, #0]
  4023f2:	430b      	orrs	r3, r1
  4023f4:	d007      	beq.n	402406 <_tx_thread_sleep+0x2a>
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  4023f6:	f382 8810 	msr	PRIMASK, r2

        /* Restore interrupts.  */
        TX_RESTORE

        /* Illegal caller of this service.  */
        status =  TX_CALLER_ERROR;
  4023fa:	2013      	movs	r0, #19
  4023fc:	bd10      	pop	{r4, pc}
  4023fe:	f382 8810 	msr	PRIMASK, r2
        status =  TX_CALLER_ERROR;
  402402:	2013      	movs	r0, #19
  402404:	bd10      	pop	{r4, pc}
    }

#ifndef TX_TIMER_PROCESS_IN_ISR

    /* Is the caller the system timer thread?  */
    else if (thread_ptr == &_tx_timer_thread)
  402406:	4b15      	ldr	r3, [pc, #84]	; (40245c <_tx_thread_sleep+0x80>)
  402408:	429c      	cmp	r4, r3
  40240a:	d007      	beq.n	40241c <_tx_thread_sleep+0x40>
        status =  TX_CALLER_ERROR;
    }
#endif

    /* Determine if the requested number of ticks is zero.  */
    else if (timer_ticks == ((ULONG) 0))
  40240c:	b150      	cbz	r0, 402424 <_tx_thread_sleep+0x48>
    }
    else
    {

        /* Determine if the preempt disable flag is non-zero.  */
        if (_tx_thread_preempt_disable != ((UINT) 0))
  40240e:	4b14      	ldr	r3, [pc, #80]	; (402460 <_tx_thread_sleep+0x84>)
  402410:	681b      	ldr	r3, [r3, #0]
  402412:	b153      	cbz	r3, 40242a <_tx_thread_sleep+0x4e>
  402414:	f382 8810 	msr	PRIMASK, r2

            /* Restore interrupts.  */
            TX_RESTORE

            /* Suspension is not allowed if the preempt disable flag is non-zero at this point - return error completion.  */
            status =  TX_CALLER_ERROR;
  402418:	2013      	movs	r0, #19
  40241a:	bd10      	pop	{r4, pc}
  40241c:	f382 8810 	msr	PRIMASK, r2
        status =  TX_CALLER_ERROR;
  402420:	2013      	movs	r0, #19
  402422:	bd10      	pop	{r4, pc}
  402424:	f382 8810 	msr	PRIMASK, r2
  402428:	bd10      	pop	{r4, pc}
            TX_EL_THREAD_SLEEP_INSERT

            /* Suspend the current thread.  */

            /* Set the state to suspended.  */
            thread_ptr -> tx_thread_state =    TX_SLEEP;
  40242a:	2304      	movs	r3, #4
  40242c:	6323      	str	r3, [r4, #48]	; 0x30
            /* Restore interrupts.  */
            TX_RESTORE
#else

            /* Set the suspending flag. */
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
  40242e:	2301      	movs	r3, #1
  402430:	63a3      	str	r3, [r4, #56]	; 0x38

            /* Initialize the status to successful.  */
            thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
  402432:	2300      	movs	r3, #0
  402434:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84

            /* Setup the timeout period.  */
            thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  timer_ticks;
  402438:	64e0      	str	r0, [r4, #76]	; 0x4c

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
  40243a:	4909      	ldr	r1, [pc, #36]	; (402460 <_tx_thread_sleep+0x84>)
  40243c:	680b      	ldr	r3, [r1, #0]
  40243e:	3301      	adds	r3, #1
  402440:	600b      	str	r3, [r1, #0]
  402442:	f382 8810 	msr	PRIMASK, r2

            /* Restore interrupts.  */
            TX_RESTORE

            /* Call actual thread suspension routine.  */
            _tx_thread_system_suspend(thread_ptr);
  402446:	4620      	mov	r0, r4
  402448:	4b06      	ldr	r3, [pc, #24]	; (402464 <_tx_thread_sleep+0x88>)
  40244a:	4798      	blx	r3
#endif

            /* Return status to the caller.  */
            status =  thread_ptr -> tx_thread_suspend_status;
  40244c:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
        }
    }

    /* Return completion status.  */
    return(status);
}
  402450:	bd10      	pop	{r4, pc}
  402452:	bf00      	nop
  402454:	20400590 	.word	0x20400590
  402458:	20400000 	.word	0x20400000
  40245c:	20400634 	.word	0x20400634
  402460:	2040058c 	.word	0x2040058c
  402464:	004025d9 	.word	0x004025d9

00402468 <_tx_thread_system_preempt_check>:
TX_THREAD       *current_thread;
TX_THREAD       *thread_ptr;


    /* Combine the system state and preempt disable flags into one for comparison.  */
    TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
  402468:	4b0a      	ldr	r3, [pc, #40]	; (402494 <_tx_thread_system_preempt_check+0x2c>)
  40246a:	681b      	ldr	r3, [r3, #0]

    /* Determine if we are in a system state (ISR or Initialization) or internal preemption is disabled.  */
    if (combined_flags == ((ULONG) 0))
  40246c:	b98b      	cbnz	r3, 402492 <_tx_thread_system_preempt_check+0x2a>
    {

        /* No, at thread execution level so continue checking for preemption.  */

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(current_thread)
  40246e:	4b0a      	ldr	r3, [pc, #40]	; (402498 <_tx_thread_system_preempt_check+0x30>)

        /* Pickup the next execute pointer.  */
        thread_ptr =  _tx_thread_execute_ptr;

        /* Determine if preemption should take place.  */
        if (current_thread != thread_ptr)
  402470:	681a      	ldr	r2, [r3, #0]
  402472:	4b0a      	ldr	r3, [pc, #40]	; (40249c <_tx_thread_system_preempt_check+0x34>)
  402474:	681b      	ldr	r3, [r3, #0]
  402476:	429a      	cmp	r2, r3
  402478:	d00b      	beq.n	402492 <_tx_thread_system_preempt_check+0x2a>
__attribute__( ( always_inline ) ) static inline void _tx_thread_system_return_inline(void)
{
unsigned int interrupt_save;

    /* Set PendSV to invoke ThreadX scheduler.  */
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
  40247a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  40247e:	4b08      	ldr	r3, [pc, #32]	; (4024a0 <_tx_thread_system_preempt_check+0x38>)
  402480:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
  402482:	f3ef 8305 	mrs	r3, IPSR
    if (__get_ipsr_value() == 0)
  402486:	b923      	cbnz	r3, 402492 <_tx_thread_system_preempt_check+0x2a>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  402488:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSIE  i": : : "memory");
  40248c:	b662      	cpsie	i
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  40248e:	f383 8810 	msr	PRIMASK, r3
  402492:	4770      	bx	lr
  402494:	2040058c 	.word	0x2040058c
  402498:	20400590 	.word	0x20400590
  40249c:	20400594 	.word	0x20400594
  4024a0:	e000ed04 	.word	0xe000ed04

004024a4 <_tx_thread_system_resume>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_system_resume(TX_THREAD *thread_ptr)
#ifndef TX_NOT_INTERRUPTABLE
{
  4024a4:	b538      	push	{r3, r4, r5, lr}
  4024a6:	4604      	mov	r4, r0
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  4024a8:	f3ef 8510 	mrs	r5, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  4024ac:	b672      	cpsid	i
    TX_DISABLE

#ifndef TX_NO_TIMER

    /* Deactivate the timeout timer if necessary.  */
    if (thread_ptr -> tx_thread_timer.tx_timer_internal_list_head != TX_NULL)
  4024ae:	6e43      	ldr	r3, [r0, #100]	; 0x64
  4024b0:	b1db      	cbz	r3, 4024ea <_tx_thread_system_resume+0x46>
    {

        /* Deactivate the thread's timeout timer.  */
        _tx_timer_system_deactivate(&(thread_ptr -> tx_thread_timer));
  4024b2:	304c      	adds	r0, #76	; 0x4c
  4024b4:	4b3f      	ldr	r3, [pc, #252]	; (4025b4 <_tx_thread_system_resume+0x110>)
  4024b6:	4798      	blx	r3
        time_stamp =  entry_ptr -> tx_trace_buffer_entry_time_stamp;
    }
#endif

    /* Decrease the preempt disabled count.  */
    _tx_thread_preempt_disable--;
  4024b8:	4a3f      	ldr	r2, [pc, #252]	; (4025b8 <_tx_thread_system_resume+0x114>)
  4024ba:	6813      	ldr	r3, [r2, #0]
  4024bc:	3b01      	subs	r3, #1
  4024be:	6013      	str	r3, [r2, #0]

    /* Determine if the thread is in the process of suspending.  If so, the thread
       control block is already on the linked list so nothing needs to be done.  */
    if (thread_ptr -> tx_thread_suspending == TX_FALSE)
  4024c0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  4024c2:	2b00      	cmp	r3, #0
  4024c4:	d151      	bne.n	40256a <_tx_thread_system_resume+0xc6>
    {

        /* Thread is not in the process of suspending. Now check to make sure the thread
           has not already been resumed.  */
        if (thread_ptr -> tx_thread_state != TX_READY)
  4024c6:	6b23      	ldr	r3, [r4, #48]	; 0x30
  4024c8:	2b00      	cmp	r3, #0
  4024ca:	d056      	beq.n	40257a <_tx_thread_system_resume+0xd6>
        {

            /* No, now check to see if the delayed suspension flag is set.  */
            if (thread_ptr -> tx_thread_delayed_suspend == TX_FALSE)
  4024cc:	6b63      	ldr	r3, [r4, #52]	; 0x34
  4024ce:	2b00      	cmp	r3, #0
  4024d0:	d146      	bne.n	402560 <_tx_thread_system_resume+0xbc>
                /* Resume the thread!  */

                /* Make this thread ready.  */

                /* Change the state to ready.  */
                thread_ptr -> tx_thread_state =  TX_READY;
  4024d2:	6323      	str	r3, [r4, #48]	; 0x30

                /* Pickup priority of thread.  */
                priority =  thread_ptr -> tx_thread_priority;
  4024d4:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
                thread_ptr -> tx_thread_performance_resume_count++;
#endif

                /* Determine if there are other threads at this priority that are
                   ready.  */
                head_ptr =  _tx_thread_priority_list[priority];
  4024d6:	4b39      	ldr	r3, [pc, #228]	; (4025bc <_tx_thread_system_resume+0x118>)
  4024d8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
                if (head_ptr == TX_NULL)
  4024dc:	b143      	cbz	r3, 4024f0 <_tx_thread_system_resume+0x4c>
                {

                    /* No, there are other threads at this priority already ready.  */

                    /* Just add this thread to the priority list.  */
                    tail_ptr =                                 head_ptr -> tx_thread_ready_previous;
  4024de:	6a5a      	ldr	r2, [r3, #36]	; 0x24
                    tail_ptr -> tx_thread_ready_next =         thread_ptr;
  4024e0:	6214      	str	r4, [r2, #32]
                    head_ptr -> tx_thread_ready_previous =     thread_ptr;
  4024e2:	625c      	str	r4, [r3, #36]	; 0x24
                    thread_ptr -> tx_thread_ready_previous =   tail_ptr;
  4024e4:	6262      	str	r2, [r4, #36]	; 0x24
                    thread_ptr -> tx_thread_ready_next =       head_ptr;
  4024e6:	6223      	str	r3, [r4, #32]
  4024e8:	e047      	b.n	40257a <_tx_thread_system_resume+0xd6>
        thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  ((ULONG) 0);
  4024ea:	2300      	movs	r3, #0
  4024ec:	64c3      	str	r3, [r0, #76]	; 0x4c
  4024ee:	e7e3      	b.n	4024b8 <_tx_thread_system_resume+0x14>
                    _tx_thread_priority_list[priority] =       thread_ptr;
  4024f0:	4b32      	ldr	r3, [pc, #200]	; (4025bc <_tx_thread_system_resume+0x118>)
  4024f2:	f843 4022 	str.w	r4, [r3, r2, lsl #2]
                    thread_ptr -> tx_thread_ready_next =       thread_ptr;
  4024f6:	6224      	str	r4, [r4, #32]
                    thread_ptr -> tx_thread_ready_previous =   thread_ptr;
  4024f8:	6264      	str	r4, [r4, #36]	; 0x24
                    _tx_thread_priority_maps[MAP_INDEX] =  _tx_thread_priority_maps[MAP_INDEX] | priority_bit;
  4024fa:	4931      	ldr	r1, [pc, #196]	; (4025c0 <_tx_thread_system_resume+0x11c>)
                    TX_MOD32_BIT_SET(priority, priority_bit)
  4024fc:	2301      	movs	r3, #1
  4024fe:	4093      	lsls	r3, r2
                    _tx_thread_priority_maps[MAP_INDEX] =  _tx_thread_priority_maps[MAP_INDEX] | priority_bit;
  402500:	6808      	ldr	r0, [r1, #0]
  402502:	4303      	orrs	r3, r0
  402504:	600b      	str	r3, [r1, #0]
                    if (priority < _tx_thread_highest_priority)
  402506:	4b2f      	ldr	r3, [pc, #188]	; (4025c4 <_tx_thread_system_resume+0x120>)
  402508:	681b      	ldr	r3, [r3, #0]
  40250a:	429a      	cmp	r2, r3
  40250c:	d235      	bcs.n	40257a <_tx_thread_system_resume+0xd6>
                        _tx_thread_highest_priority =  priority;
  40250e:	4b2d      	ldr	r3, [pc, #180]	; (4025c4 <_tx_thread_system_resume+0x120>)
  402510:	601a      	str	r2, [r3, #0]
                        execute_ptr =  _tx_thread_execute_ptr;
  402512:	4b2d      	ldr	r3, [pc, #180]	; (4025c8 <_tx_thread_system_resume+0x124>)
  402514:	681b      	ldr	r3, [r3, #0]
                        if (execute_ptr == TX_NULL)
  402516:	b303      	cbz	r3, 40255a <_tx_thread_system_resume+0xb6>
                            if (priority < execute_ptr -> tx_thread_preempt_threshold)
  402518:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
  40251a:	428a      	cmp	r2, r1
  40251c:	d22d      	bcs.n	40257a <_tx_thread_system_resume+0xd6>
                                if (execute_ptr -> tx_thread_preempt_threshold != execute_ptr -> tx_thread_priority)
  40251e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  402520:	4291      	cmp	r1, r2
  402522:	d005      	beq.n	402530 <_tx_thread_system_resume+0x8c>
                                    _tx_thread_preempted_maps[MAP_INDEX] =  _tx_thread_preempted_maps[MAP_INDEX] | priority_bit;
  402524:	4929      	ldr	r1, [pc, #164]	; (4025cc <_tx_thread_system_resume+0x128>)
                                    TX_MOD32_BIT_SET(execute_ptr -> tx_thread_priority, priority_bit)
  402526:	2301      	movs	r3, #1
  402528:	4093      	lsls	r3, r2
                                    _tx_thread_preempted_maps[MAP_INDEX] =  _tx_thread_preempted_maps[MAP_INDEX] | priority_bit;
  40252a:	680a      	ldr	r2, [r1, #0]
  40252c:	4313      	orrs	r3, r2
  40252e:	600b      	str	r3, [r1, #0]
                                _tx_thread_execute_ptr =  thread_ptr;
  402530:	4b25      	ldr	r3, [pc, #148]	; (4025c8 <_tx_thread_system_resume+0x124>)
  402532:	601c      	str	r4, [r3, #0]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  402534:	f385 8810 	msr	PRIMASK, r5
                                TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
  402538:	4b1f      	ldr	r3, [pc, #124]	; (4025b8 <_tx_thread_system_resume+0x114>)
  40253a:	681b      	ldr	r3, [r3, #0]
                                if (combined_flags == ((ULONG) 0))
  40253c:	2b00      	cmp	r3, #0
  40253e:	d133      	bne.n	4025a8 <_tx_thread_system_resume+0x104>
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
  402540:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  402544:	4b22      	ldr	r3, [pc, #136]	; (4025d0 <_tx_thread_system_resume+0x12c>)
  402546:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
  402548:	f3ef 8305 	mrs	r3, IPSR
    if (__get_ipsr_value() == 0)
  40254c:	bb63      	cbnz	r3, 4025a8 <_tx_thread_system_resume+0x104>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  40254e:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSIE  i": : : "memory");
  402552:	b662      	cpsie	i
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  402554:	f383 8810 	msr	PRIMASK, r3
  402558:	bd38      	pop	{r3, r4, r5, pc}
                            _tx_thread_execute_ptr =  thread_ptr;
  40255a:	4b1b      	ldr	r3, [pc, #108]	; (4025c8 <_tx_thread_system_resume+0x124>)
  40255c:	601c      	str	r4, [r3, #0]
  40255e:	e00c      	b.n	40257a <_tx_thread_system_resume+0xd6>
            /* Else, delayed suspend flag was set.  */
            else
            {

                /* Clear the delayed suspend flag and change the state.  */
                thread_ptr -> tx_thread_delayed_suspend =  TX_FALSE;
  402560:	2300      	movs	r3, #0
  402562:	6363      	str	r3, [r4, #52]	; 0x34
                thread_ptr -> tx_thread_state =            TX_SUSPENDED;
  402564:	2303      	movs	r3, #3
  402566:	6323      	str	r3, [r4, #48]	; 0x30
  402568:	e007      	b.n	40257a <_tx_thread_system_resume+0xd6>
           interrupted suspension processing.  */
        if (thread_ptr -> tx_thread_state != TX_COMPLETED)
        {

            /* Make sure the thread isn't terminated.  */
            if (thread_ptr -> tx_thread_state != TX_TERMINATED)
  40256a:	6b23      	ldr	r3, [r4, #48]	; 0x30
  40256c:	3b01      	subs	r3, #1
  40256e:	2b01      	cmp	r3, #1
  402570:	d903      	bls.n	40257a <_tx_thread_system_resume+0xd6>
            {

                /* No, now check to see if the delayed suspension flag is set.  */
                if (thread_ptr -> tx_thread_delayed_suspend == TX_FALSE)
  402572:	6b63      	ldr	r3, [r4, #52]	; 0x34
  402574:	b9cb      	cbnz	r3, 4025aa <_tx_thread_system_resume+0x106>
                {

                    /* Clear the suspending flag.  */
                    thread_ptr -> tx_thread_suspending =   TX_FALSE;
  402576:	63a3      	str	r3, [r4, #56]	; 0x38

                    /* Restore the state to ready.  */
                    thread_ptr -> tx_thread_state =        TX_READY;
  402578:	6323      	str	r3, [r4, #48]	; 0x30
        }
    }
#endif

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(current_thread)
  40257a:	4b16      	ldr	r3, [pc, #88]	; (4025d4 <_tx_thread_system_resume+0x130>)
  40257c:	681a      	ldr	r2, [r3, #0]
  40257e:	f385 8810 	msr	PRIMASK, r5

    /* Restore interrupts.  */
    TX_RESTORE

    /* Determine if a preemption condition is present.  */
    if (current_thread != _tx_thread_execute_ptr)
  402582:	4b11      	ldr	r3, [pc, #68]	; (4025c8 <_tx_thread_system_resume+0x124>)
  402584:	681b      	ldr	r3, [r3, #0]
  402586:	429a      	cmp	r2, r3
  402588:	d00e      	beq.n	4025a8 <_tx_thread_system_resume+0x104>
        TX_THREAD_STACK_CHECK(thread_ptr)
#endif

        /* Now determine if preemption should take place. This is only possible if the current thread pointer is
           not the same as the execute thread pointer AND the system state and preempt disable flags are clear.  */
        TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
  40258a:	4b0b      	ldr	r3, [pc, #44]	; (4025b8 <_tx_thread_system_resume+0x114>)
  40258c:	681b      	ldr	r3, [r3, #0]
        if (combined_flags == ((ULONG) 0))
  40258e:	b95b      	cbnz	r3, 4025a8 <_tx_thread_system_resume+0x104>
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
  402590:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  402594:	4b0e      	ldr	r3, [pc, #56]	; (4025d0 <_tx_thread_system_resume+0x12c>)
  402596:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
  402598:	f3ef 8305 	mrs	r3, IPSR
    if (__get_ipsr_value() == 0)
  40259c:	b923      	cbnz	r3, 4025a8 <_tx_thread_system_resume+0x104>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  40259e:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSIE  i": : : "memory");
  4025a2:	b662      	cpsie	i
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  4025a4:	f383 8810 	msr	PRIMASK, r3
  4025a8:	bd38      	pop	{r3, r4, r5, pc}
                    thread_ptr -> tx_thread_delayed_suspend =  TX_FALSE;
  4025aa:	2300      	movs	r3, #0
  4025ac:	6363      	str	r3, [r4, #52]	; 0x34
                    thread_ptr -> tx_thread_state =            TX_SUSPENDED;
  4025ae:	2303      	movs	r3, #3
  4025b0:	6323      	str	r3, [r4, #48]	; 0x30
  4025b2:	e7e2      	b.n	40257a <_tx_thread_system_resume+0xd6>
  4025b4:	00402981 	.word	0x00402981
  4025b8:	2040058c 	.word	0x2040058c
  4025bc:	204004f4 	.word	0x204004f4
  4025c0:	20400578 	.word	0x20400578
  4025c4:	20400598 	.word	0x20400598
  4025c8:	20400594 	.word	0x20400594
  4025cc:	2040059c 	.word	0x2040059c
  4025d0:	e000ed04 	.word	0xe000ed04
  4025d4:	20400590 	.word	0x20400590

004025d8 <_tx_thread_system_suspend>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_system_suspend(TX_THREAD *thread_ptr)
#ifndef TX_NOT_INTERRUPTABLE
{
  4025d8:	b570      	push	{r4, r5, r6, lr}
  4025da:	4604      	mov	r4, r0
TX_TRACE_BUFFER_ENTRY       *entry_ptr;
ULONG                       time_stamp =  ((ULONG) 0);
#endif

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(current_thread)
  4025dc:	4b63      	ldr	r3, [pc, #396]	; (40276c <_tx_thread_system_suspend+0x194>)
  4025de:	681d      	ldr	r5, [r3, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  4025e0:	f3ef 8610 	mrs	r6, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  4025e4:	b672      	cpsid	i
    TX_DISABLE

#ifndef TX_NO_TIMER

    /* Is the current thread suspending?  */
    if (thread_ptr == current_thread)
  4025e6:	4285      	cmp	r5, r0
  4025e8:	d01c      	beq.n	402624 <_tx_thread_system_suspend+0x4c>
        _tx_timer_time_slice =  thread_ptr -> tx_thread_new_time_slice;
    }
#endif

    /* Decrease the preempt disabled count.  */
    _tx_thread_preempt_disable--;
  4025ea:	4a61      	ldr	r2, [pc, #388]	; (402770 <_tx_thread_system_suspend+0x198>)
  4025ec:	6813      	ldr	r3, [r2, #0]
  4025ee:	3b01      	subs	r3, #1
  4025f0:	6013      	str	r3, [r2, #0]
    _tx_thread_performance_suspend_count++;
#endif

    /* Check to make sure the thread suspending flag is still set.  If not, it
       has already been resumed.  */
    if (thread_ptr -> tx_thread_suspending == TX_TRUE)
  4025f2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  4025f4:	2b01      	cmp	r3, #1
  4025f6:	d021      	beq.n	40263c <_tx_thread_system_suspend+0x64>
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  4025f8:	f386 8810 	msr	PRIMASK, r6

    /* Restore interrupts.  */
    TX_RESTORE

    /* Determine if a preemption condition is present.  */
    if (current_thread != _tx_thread_execute_ptr)
  4025fc:	4b5d      	ldr	r3, [pc, #372]	; (402774 <_tx_thread_system_suspend+0x19c>)
  4025fe:	681b      	ldr	r3, [r3, #0]
  402600:	429d      	cmp	r5, r3
  402602:	d00e      	beq.n	402622 <_tx_thread_system_suspend+0x4a>
        TX_THREAD_STACK_CHECK(thread_ptr)
#endif

        /* Determine if preemption should take place. This is only possible if the current thread pointer is
           not the same as the execute thread pointer AND the system state and preempt disable flags are clear.  */
        TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
  402604:	4b5a      	ldr	r3, [pc, #360]	; (402770 <_tx_thread_system_suspend+0x198>)
  402606:	681b      	ldr	r3, [r3, #0]
        if (combined_flags == ((ULONG) 0))
  402608:	b95b      	cbnz	r3, 402622 <_tx_thread_system_suspend+0x4a>
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
  40260a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  40260e:	4b5a      	ldr	r3, [pc, #360]	; (402778 <_tx_thread_system_suspend+0x1a0>)
  402610:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
  402612:	f3ef 8305 	mrs	r3, IPSR
    if (__get_ipsr_value() == 0)
  402616:	b923      	cbnz	r3, 402622 <_tx_thread_system_suspend+0x4a>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  402618:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSIE  i": : : "memory");
  40261c:	b662      	cpsie	i
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  40261e:	f383 8810 	msr	PRIMASK, r3
  402622:	bd70      	pop	{r4, r5, r6, pc}
            if (timeout != TX_WAIT_FOREVER)
  402624:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
  402626:	3b01      	subs	r3, #1
  402628:	f113 0f03 	cmn.w	r3, #3
  40262c:	d802      	bhi.n	402634 <_tx_thread_system_suspend+0x5c>
                _tx_timer_system_activate(&(thread_ptr -> tx_thread_timer));
  40262e:	304c      	adds	r0, #76	; 0x4c
  402630:	4b52      	ldr	r3, [pc, #328]	; (40277c <_tx_thread_system_suspend+0x1a4>)
  402632:	4798      	blx	r3
        _tx_timer_time_slice =  thread_ptr -> tx_thread_new_time_slice;
  402634:	69e2      	ldr	r2, [r4, #28]
  402636:	4b52      	ldr	r3, [pc, #328]	; (402780 <_tx_thread_system_suspend+0x1a8>)
  402638:	601a      	str	r2, [r3, #0]
  40263a:	e7d6      	b.n	4025ea <_tx_thread_system_suspend+0x12>
        thread_ptr -> tx_thread_suspending =  TX_FALSE;
  40263c:	2300      	movs	r3, #0
  40263e:	63a3      	str	r3, [r4, #56]	; 0x38
        priority =  thread_ptr -> tx_thread_priority;
  402640:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
        ready_next =      thread_ptr -> tx_thread_ready_next;
  402642:	6a23      	ldr	r3, [r4, #32]
        if (ready_next != thread_ptr)
  402644:	429c      	cmp	r4, r3
  402646:	d05b      	beq.n	402700 <_tx_thread_system_suspend+0x128>
            ready_previous =  thread_ptr -> tx_thread_ready_previous;
  402648:	6a62      	ldr	r2, [r4, #36]	; 0x24
            ready_next -> tx_thread_ready_previous =    ready_previous;
  40264a:	625a      	str	r2, [r3, #36]	; 0x24
            ready_previous -> tx_thread_ready_next =    ready_next;
  40264c:	6213      	str	r3, [r2, #32]
            if (_tx_thread_priority_list[priority] == thread_ptr)
  40264e:	4a4d      	ldr	r2, [pc, #308]	; (402784 <_tx_thread_system_suspend+0x1ac>)
  402650:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
  402654:	4294      	cmp	r4, r2
  402656:	d044      	beq.n	4026e2 <_tx_thread_system_suspend+0x10a>
        if (thread_ptr == _tx_thread_execute_ptr)
  402658:	4b46      	ldr	r3, [pc, #280]	; (402774 <_tx_thread_system_suspend+0x19c>)
  40265a:	681b      	ldr	r3, [r3, #0]
  40265c:	429c      	cmp	r4, r3
  40265e:	d1cb      	bne.n	4025f8 <_tx_thread_system_suspend+0x20>
            _tx_thread_execute_ptr =  _tx_thread_priority_list[_tx_thread_highest_priority];
  402660:	4b49      	ldr	r3, [pc, #292]	; (402788 <_tx_thread_system_suspend+0x1b0>)
  402662:	681a      	ldr	r2, [r3, #0]
  402664:	4b47      	ldr	r3, [pc, #284]	; (402784 <_tx_thread_system_suspend+0x1ac>)
  402666:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
  40266a:	4b42      	ldr	r3, [pc, #264]	; (402774 <_tx_thread_system_suspend+0x19c>)
  40266c:	601a      	str	r2, [r3, #0]
            if (_tx_thread_preempted_maps[MAP_INDEX] != ((ULONG) 0))
  40266e:	4b47      	ldr	r3, [pc, #284]	; (40278c <_tx_thread_system_suspend+0x1b4>)
  402670:	681b      	ldr	r3, [r3, #0]
  402672:	b313      	cbz	r3, 4026ba <_tx_thread_system_suspend+0xe2>
                _tx_thread_preempt_disable++;
  402674:	4b3e      	ldr	r3, [pc, #248]	; (402770 <_tx_thread_system_suspend+0x198>)
  402676:	681a      	ldr	r2, [r3, #0]
  402678:	3201      	adds	r2, #1
  40267a:	601a      	str	r2, [r3, #0]
  40267c:	f386 8810 	msr	PRIMASK, r6
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  402680:	f3ef 8610 	mrs	r6, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  402684:	b672      	cpsid	i
                _tx_thread_preempt_disable--;
  402686:	681a      	ldr	r2, [r3, #0]
  402688:	3a01      	subs	r2, #1
  40268a:	601a      	str	r2, [r3, #0]
                priority_map =  _tx_thread_preempted_maps[MAP_INDEX];
  40268c:	4b3f      	ldr	r3, [pc, #252]	; (40278c <_tx_thread_system_suspend+0x1b4>)
  40268e:	681a      	ldr	r2, [r3, #0]
                TX_LOWEST_SET_BIT_CALCULATE(priority_map, priority_bit)
  402690:	fa92 f3a2 	rbit	r3, r2
  402694:	fab3 f383 	clz	r3, r3
                if (_tx_thread_highest_priority >= (_tx_thread_priority_list[priority] -> tx_thread_preempt_threshold))
  402698:	493a      	ldr	r1, [pc, #232]	; (402784 <_tx_thread_system_suspend+0x1ac>)
  40269a:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
  40269e:	6bcc      	ldr	r4, [r1, #60]	; 0x3c
  4026a0:	4839      	ldr	r0, [pc, #228]	; (402788 <_tx_thread_system_suspend+0x1b0>)
  4026a2:	6800      	ldr	r0, [r0, #0]
  4026a4:	4284      	cmp	r4, r0
  4026a6:	d808      	bhi.n	4026ba <_tx_thread_system_suspend+0xe2>
                    _tx_thread_execute_ptr =  _tx_thread_priority_list[priority];
  4026a8:	4832      	ldr	r0, [pc, #200]	; (402774 <_tx_thread_system_suspend+0x19c>)
  4026aa:	6001      	str	r1, [r0, #0]
                    TX_MOD32_BIT_SET(priority, priority_bit)
  4026ac:	2101      	movs	r1, #1
  4026ae:	fa01 f303 	lsl.w	r3, r1, r3
                    _tx_thread_preempted_maps[MAP_INDEX] =  _tx_thread_preempted_maps[MAP_INDEX] & (~(priority_bit));
  4026b2:	ea22 0203 	bic.w	r2, r2, r3
  4026b6:	4b35      	ldr	r3, [pc, #212]	; (40278c <_tx_thread_system_suspend+0x1b4>)
  4026b8:	601a      	str	r2, [r3, #0]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  4026ba:	f386 8810 	msr	PRIMASK, r6
            TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
  4026be:	4b2c      	ldr	r3, [pc, #176]	; (402770 <_tx_thread_system_suspend+0x198>)
  4026c0:	681b      	ldr	r3, [r3, #0]
            if (combined_flags == ((ULONG) 0))
  4026c2:	2b00      	cmp	r3, #0
  4026c4:	d1ad      	bne.n	402622 <_tx_thread_system_suspend+0x4a>
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
  4026c6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  4026ca:	4b2b      	ldr	r3, [pc, #172]	; (402778 <_tx_thread_system_suspend+0x1a0>)
  4026cc:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
  4026ce:	f3ef 8305 	mrs	r3, IPSR
    if (__get_ipsr_value() == 0)
  4026d2:	2b00      	cmp	r3, #0
  4026d4:	d1a5      	bne.n	402622 <_tx_thread_system_suspend+0x4a>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  4026d6:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSIE  i": : : "memory");
  4026da:	b662      	cpsie	i
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  4026dc:	f383 8810 	msr	PRIMASK, r3
  4026e0:	bd70      	pop	{r4, r5, r6, pc}
                _tx_thread_priority_list[priority] =  ready_next;
  4026e2:	4a28      	ldr	r2, [pc, #160]	; (402784 <_tx_thread_system_suspend+0x1ac>)
  4026e4:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
                if (_tx_thread_preempted_maps[MAP_INDEX] != ((ULONG) 0))
  4026e8:	4b28      	ldr	r3, [pc, #160]	; (40278c <_tx_thread_system_suspend+0x1b4>)
  4026ea:	681b      	ldr	r3, [r3, #0]
  4026ec:	2b00      	cmp	r3, #0
  4026ee:	d0b3      	beq.n	402658 <_tx_thread_system_suspend+0x80>
                    TX_MOD32_BIT_SET(priority, priority_bit)
  4026f0:	2201      	movs	r2, #1
  4026f2:	fa02 f101 	lsl.w	r1, r2, r1
                    _tx_thread_preempted_maps[MAP_INDEX] =  _tx_thread_preempted_maps[MAP_INDEX] & (~(priority_bit));
  4026f6:	ea23 0301 	bic.w	r3, r3, r1
  4026fa:	4a24      	ldr	r2, [pc, #144]	; (40278c <_tx_thread_system_suspend+0x1b4>)
  4026fc:	6013      	str	r3, [r2, #0]
  4026fe:	e7ab      	b.n	402658 <_tx_thread_system_suspend+0x80>
            _tx_thread_priority_list[priority] =    TX_NULL;
  402700:	2200      	movs	r2, #0
  402702:	4b20      	ldr	r3, [pc, #128]	; (402784 <_tx_thread_system_suspend+0x1ac>)
  402704:	f843 2021 	str.w	r2, [r3, r1, lsl #2]
            TX_MOD32_BIT_SET(priority, priority_bit)
  402708:	2301      	movs	r3, #1
  40270a:	fa03 f101 	lsl.w	r1, r3, r1
            _tx_thread_priority_maps[MAP_INDEX] =  _tx_thread_priority_maps[MAP_INDEX] & (~(priority_bit));
  40270e:	43c9      	mvns	r1, r1
  402710:	4a1f      	ldr	r2, [pc, #124]	; (402790 <_tx_thread_system_suspend+0x1b8>)
  402712:	6813      	ldr	r3, [r2, #0]
  402714:	400b      	ands	r3, r1
  402716:	6013      	str	r3, [r2, #0]
            if (_tx_thread_preempted_maps[MAP_INDEX] != ((ULONG) 0))
  402718:	4a1c      	ldr	r2, [pc, #112]	; (40278c <_tx_thread_system_suspend+0x1b4>)
  40271a:	6812      	ldr	r2, [r2, #0]
  40271c:	b112      	cbz	r2, 402724 <_tx_thread_system_suspend+0x14c>
                _tx_thread_preempted_maps[MAP_INDEX] =  _tx_thread_preempted_maps[MAP_INDEX] & (~(priority_bit));
  40271e:	4011      	ands	r1, r2
  402720:	4a1a      	ldr	r2, [pc, #104]	; (40278c <_tx_thread_system_suspend+0x1b4>)
  402722:	6011      	str	r1, [r2, #0]
            if (priority_map == ((ULONG) 0))
  402724:	b9db      	cbnz	r3, 40275e <_tx_thread_system_suspend+0x186>
                _tx_thread_highest_priority =  ((UINT) TX_MAX_PRIORITIES);
  402726:	2220      	movs	r2, #32
  402728:	4b17      	ldr	r3, [pc, #92]	; (402788 <_tx_thread_system_suspend+0x1b0>)
  40272a:	601a      	str	r2, [r3, #0]
                _tx_thread_execute_ptr =       TX_NULL;
  40272c:	2200      	movs	r2, #0
  40272e:	4b11      	ldr	r3, [pc, #68]	; (402774 <_tx_thread_system_suspend+0x19c>)
  402730:	601a      	str	r2, [r3, #0]
  402732:	f386 8810 	msr	PRIMASK, r6
                TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
  402736:	4b0e      	ldr	r3, [pc, #56]	; (402770 <_tx_thread_system_suspend+0x198>)
  402738:	681b      	ldr	r3, [r3, #0]
                if (combined_flags == ((ULONG) 0))
  40273a:	2b00      	cmp	r3, #0
  40273c:	f47f af71 	bne.w	402622 <_tx_thread_system_suspend+0x4a>
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
  402740:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  402744:	4b0c      	ldr	r3, [pc, #48]	; (402778 <_tx_thread_system_suspend+0x1a0>)
  402746:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
  402748:	f3ef 8305 	mrs	r3, IPSR
    if (__get_ipsr_value() == 0)
  40274c:	2b00      	cmp	r3, #0
  40274e:	f47f af68 	bne.w	402622 <_tx_thread_system_suspend+0x4a>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  402752:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSIE  i": : : "memory");
  402756:	b662      	cpsie	i
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  402758:	f383 8810 	msr	PRIMASK, r3
  40275c:	bd70      	pop	{r4, r5, r6, pc}
                TX_LOWEST_SET_BIT_CALCULATE(priority_map, priority_bit)
  40275e:	fa93 f3a3 	rbit	r3, r3
  402762:	fab3 f383 	clz	r3, r3
                _tx_thread_highest_priority =  base_priority + ((UINT) priority_bit);
  402766:	4a08      	ldr	r2, [pc, #32]	; (402788 <_tx_thread_system_suspend+0x1b0>)
  402768:	6013      	str	r3, [r2, #0]
  40276a:	e775      	b.n	402658 <_tx_thread_system_suspend+0x80>
  40276c:	20400590 	.word	0x20400590
  402770:	2040058c 	.word	0x2040058c
  402774:	20400594 	.word	0x20400594
  402778:	e000ed04 	.word	0xe000ed04
  40277c:	0040292d 	.word	0x0040292d
  402780:	20400628 	.word	0x20400628
  402784:	204004f4 	.word	0x204004f4
  402788:	20400598 	.word	0x20400598
  40278c:	2040059c 	.word	0x2040059c
  402790:	20400578 	.word	0x20400578

00402794 <_tx_thread_timeout>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_timeout(ULONG timeout_input)
{
  402794:	b508      	push	{r3, lr}
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  402796:	f3ef 8210 	mrs	r2, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  40279a:	b672      	cpsid	i

    /* Disable interrupts.  */
    TX_DISABLE

    /* Determine how the thread is currently suspended.  */
    if (thread_ptr -> tx_thread_state == TX_SLEEP)
  40279c:	6b03      	ldr	r3, [r0, #48]	; 0x30
  40279e:	2b04      	cmp	r3, #4
  4027a0:	d007      	beq.n	4027b2 <_tx_thread_timeout+0x1e>
        /* Increment the number of timeouts for this thread.  */
        thread_ptr -> tx_thread_performance_timeout_count++;
#endif

        /* Pickup the cleanup routine address.  */
        suspend_cleanup =  thread_ptr -> tx_thread_suspend_cleanup;
  4027a2:	6e83      	ldr	r3, [r0, #104]	; 0x68

#ifndef TX_NOT_INTERRUPTABLE

        /* Pickup the suspension sequence number that is used later to verify that the
           cleanup is still necessary.  */
        suspension_sequence =  thread_ptr -> tx_thread_suspension_sequence;
  4027a4:	f8d0 10b0 	ldr.w	r1, [r0, #176]	; 0xb0
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  4027a8:	f382 8810 	msr	PRIMASK, r2
        /* Restore interrupts.  */
        TX_RESTORE
#endif

        /* Call any cleanup routines.  */
        if (suspend_cleanup != TX_NULL)
  4027ac:	b103      	cbz	r3, 4027b0 <_tx_thread_timeout+0x1c>
        {

            /* Yes, there is a function to call.  */
            (suspend_cleanup)(thread_ptr, suspension_sequence);
  4027ae:	4798      	blx	r3
  4027b0:	bd08      	pop	{r3, pc}
        _tx_thread_preempt_disable++;
  4027b2:	4904      	ldr	r1, [pc, #16]	; (4027c4 <_tx_thread_timeout+0x30>)
  4027b4:	680b      	ldr	r3, [r1, #0]
  4027b6:	3301      	adds	r3, #1
  4027b8:	600b      	str	r3, [r1, #0]
  4027ba:	f382 8810 	msr	PRIMASK, r2
        _tx_thread_system_resume(thread_ptr);
  4027be:	4b02      	ldr	r3, [pc, #8]	; (4027c8 <_tx_thread_timeout+0x34>)
  4027c0:	4798      	blx	r3
  4027c2:	bd08      	pop	{r3, pc}
  4027c4:	2040058c 	.word	0x2040058c
  4027c8:	004024a5 	.word	0x004024a5

004027cc <_tx_thread_time_slice>:
ULONG           system_state;
UINT            preempt_disable;
#endif

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
  4027cc:	4b11      	ldr	r3, [pc, #68]	; (402814 <_tx_thread_time_slice+0x48>)
  4027ce:	681b      	ldr	r3, [r3, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  4027d0:	f3ef 8210 	mrs	r2, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  4027d4:	b672      	cpsid	i

    /* Lockout interrupts while the time-slice is evaluated.  */
    TX_DISABLE

    /* Clear the expired time-slice flag.  */
    _tx_timer_expired_time_slice =  TX_FALSE;
  4027d6:	2000      	movs	r0, #0
  4027d8:	490f      	ldr	r1, [pc, #60]	; (402818 <_tx_thread_time_slice+0x4c>)
  4027da:	6008      	str	r0, [r1, #0]

    /* Make sure the thread pointer is valid.  */
    if (thread_ptr != TX_NULL)
  4027dc:	b163      	cbz	r3, 4027f8 <_tx_thread_time_slice+0x2c>
    {

        /* Make sure the thread is still active, i.e. not suspended.  */
        if (thread_ptr -> tx_thread_state == TX_READY)
  4027de:	6b19      	ldr	r1, [r3, #48]	; 0x30
  4027e0:	b951      	cbnz	r1, 4027f8 <_tx_thread_time_slice+0x2c>
        {

            /* Setup a fresh time-slice for the thread.  */
            thread_ptr -> tx_thread_time_slice =  thread_ptr -> tx_thread_new_time_slice;
  4027e2:	69d9      	ldr	r1, [r3, #28]
  4027e4:	6199      	str	r1, [r3, #24]

            /* Reset the actual time-slice variable.  */
            _tx_timer_time_slice =  thread_ptr -> tx_thread_time_slice;
  4027e6:	480d      	ldr	r0, [pc, #52]	; (40281c <_tx_thread_time_slice+0x50>)
  4027e8:	6001      	str	r1, [r0, #0]

            /* Determine if there is another thread at the same priority and preemption-threshold
               is not set.  Preemption-threshold overrides time-slicing.  */
            if (thread_ptr -> tx_thread_ready_next != thread_ptr)
  4027ea:	6a19      	ldr	r1, [r3, #32]
  4027ec:	428b      	cmp	r3, r1
  4027ee:	d003      	beq.n	4027f8 <_tx_thread_time_slice+0x2c>
            {

                /* Check to see if preemption-threshold is not being used.  */
                if (thread_ptr -> tx_thread_priority == thread_ptr -> tx_thread_preempt_threshold)
  4027f0:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
  4027f2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  4027f4:	4298      	cmp	r0, r3
  4027f6:	d002      	beq.n	4027fe <_tx_thread_time_slice+0x32>
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  4027f8:	f382 8810 	msr	PRIMASK, r2
  4027fc:	4770      	bx	lr

                    /* Preemption-threshold is not being used by this thread.  */

                    /* There is another thread at this priority, make it the highest at
                       this priority level.  */
                    _tx_thread_priority_list[thread_ptr -> tx_thread_priority] =  thread_ptr -> tx_thread_ready_next;
  4027fe:	4b08      	ldr	r3, [pc, #32]	; (402820 <_tx_thread_time_slice+0x54>)
  402800:	f843 1020 	str.w	r1, [r3, r0, lsl #2]

                    /* Designate the highest priority thread as the one to execute.  Don't use this
                       thread's priority as an index just in case a higher priority thread is now
                       ready!  */
                    _tx_thread_execute_ptr =  _tx_thread_priority_list[_tx_thread_highest_priority];
  402804:	4907      	ldr	r1, [pc, #28]	; (402824 <_tx_thread_time_slice+0x58>)
  402806:	6809      	ldr	r1, [r1, #0]
  402808:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
  40280c:	4b06      	ldr	r3, [pc, #24]	; (402828 <_tx_thread_time_slice+0x5c>)
  40280e:	6019      	str	r1, [r3, #0]
  402810:	e7f2      	b.n	4027f8 <_tx_thread_time_slice+0x2c>
  402812:	bf00      	nop
  402814:	20400590 	.word	0x20400590
  402818:	20400b00 	.word	0x20400b00
  40281c:	20400628 	.word	0x20400628
  402820:	204004f4 	.word	0x204004f4
  402824:	20400598 	.word	0x20400598
  402828:	20400594 	.word	0x20400594

0040282c <_tx_timer_expiration_process>:
/*                                            TX_NO_TIMER is defined,     */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_timer_expiration_process(VOID)
{
  40282c:	b508      	push	{r3, lr}
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  40282e:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  402832:	b672      	cpsid	i
    /* Restore interrupts.  */
    TX_RESTORE
#else

    /* Increment the preempt disable flag.  */
    _tx_thread_preempt_disable++;
  402834:	4904      	ldr	r1, [pc, #16]	; (402848 <_tx_timer_expiration_process+0x1c>)
  402836:	680a      	ldr	r2, [r1, #0]
  402838:	3201      	adds	r2, #1
  40283a:	600a      	str	r2, [r1, #0]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  40283c:	f383 8810 	msr	PRIMASK, r3

    /* Restore interrupts.  */
    TX_RESTORE

    /* Call the system resume function to activate the timer thread.  */
    _tx_thread_system_resume(&_tx_timer_thread);
  402840:	4802      	ldr	r0, [pc, #8]	; (40284c <_tx_timer_expiration_process+0x20>)
  402842:	4b03      	ldr	r3, [pc, #12]	; (402850 <_tx_timer_expiration_process+0x24>)
  402844:	4798      	blx	r3
  402846:	bd08      	pop	{r3, pc}
  402848:	2040058c 	.word	0x2040058c
  40284c:	20400634 	.word	0x20400634
  402850:	004024a5 	.word	0x004024a5

00402854 <_tx_timer_initialize>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_timer_initialize(VOID)
{
  402854:	b5f0      	push	{r4, r5, r6, r7, lr}
  402856:	b087      	sub	sp, #28
#endif

#ifndef TX_DISABLE_REDUNDANT_CLEARING

    /* Initialize the system clock to 0.  */
    _tx_timer_system_clock =  ((ULONG) 0);
  402858:	2400      	movs	r4, #0
  40285a:	4b1f      	ldr	r3, [pc, #124]	; (4028d8 <_tx_timer_initialize+0x84>)
  40285c:	601c      	str	r4, [r3, #0]

    /* Initialize the time-slice value to 0 to make sure it is disabled.  */
    _tx_timer_time_slice =  ((ULONG) 0);
  40285e:	4b1f      	ldr	r3, [pc, #124]	; (4028dc <_tx_timer_initialize+0x88>)
  402860:	601c      	str	r4, [r3, #0]

    /* Clear the expired flags.  */
    _tx_timer_expired_time_slice =  TX_FALSE;
  402862:	4b1f      	ldr	r3, [pc, #124]	; (4028e0 <_tx_timer_initialize+0x8c>)
  402864:	601c      	str	r4, [r3, #0]
    _tx_timer_expired =             TX_FALSE;
  402866:	4b1f      	ldr	r3, [pc, #124]	; (4028e4 <_tx_timer_initialize+0x90>)
  402868:	601c      	str	r4, [r3, #0]

    /* Set the currently expired timer being processed pointer to NULL.  */
    _tx_timer_expired_timer_ptr =  TX_NULL;
  40286a:	4b1f      	ldr	r3, [pc, #124]	; (4028e8 <_tx_timer_initialize+0x94>)
  40286c:	601c      	str	r4, [r3, #0]

    /* Initialize the thread and application timer management control structures.  */

    /* First, initialize the timer list.  */
    TX_MEMSET(&_tx_timer_list[0], 0, (sizeof(_tx_timer_list)));
  40286e:	4d1f      	ldr	r5, [pc, #124]	; (4028ec <_tx_timer_initialize+0x98>)
  402870:	2280      	movs	r2, #128	; 0x80
  402872:	4621      	mov	r1, r4
  402874:	4628      	mov	r0, r5
  402876:	4b1e      	ldr	r3, [pc, #120]	; (4028f0 <_tx_timer_initialize+0x9c>)
  402878:	4798      	blx	r3
#endif

    /* Initialize all of the list pointers.  */
    _tx_timer_list_start =   &_tx_timer_list[0];
  40287a:	4b1e      	ldr	r3, [pc, #120]	; (4028f4 <_tx_timer_initialize+0xa0>)
  40287c:	601d      	str	r5, [r3, #0]
    _tx_timer_current_ptr =  &_tx_timer_list[0];
  40287e:	4b1e      	ldr	r3, [pc, #120]	; (4028f8 <_tx_timer_initialize+0xa4>)
  402880:	601d      	str	r5, [r3, #0]

    /* Set the timer list end pointer to one past the actual timer list.  This is done
       to make the timer interrupt handling in assembly language a little easier.  */
    _tx_timer_list_end =     &_tx_timer_list[TX_TIMER_ENTRIES-((ULONG) 1)];
    _tx_timer_list_end =     TX_TIMER_POINTER_ADD(_tx_timer_list_end, ((ULONG) 1));
  402882:	3580      	adds	r5, #128	; 0x80
  402884:	4b1d      	ldr	r3, [pc, #116]	; (4028fc <_tx_timer_initialize+0xa8>)
  402886:	601d      	str	r5, [r3, #0]

#ifndef TX_TIMER_PROCESS_IN_ISR

    /* Setup the variables associated with the system timer thread's stack and
       priority.  */
    _tx_timer_stack_start =  (VOID *) &_tx_timer_thread_stack_area[0];
  402888:	4a1d      	ldr	r2, [pc, #116]	; (402900 <_tx_timer_initialize+0xac>)
  40288a:	4b1e      	ldr	r3, [pc, #120]	; (402904 <_tx_timer_initialize+0xb0>)
  40288c:	601a      	str	r2, [r3, #0]
    _tx_timer_stack_size =   ((ULONG) TX_TIMER_THREAD_STACK_SIZE);
  40288e:	f44f 6280 	mov.w	r2, #1024	; 0x400
  402892:	4b1d      	ldr	r3, [pc, #116]	; (402908 <_tx_timer_initialize+0xb4>)
  402894:	601a      	str	r2, [r3, #0]
    _tx_timer_priority =     ((UINT) TX_TIMER_THREAD_PRIORITY);
  402896:	4b1d      	ldr	r3, [pc, #116]	; (40290c <_tx_timer_initialize+0xb8>)
  402898:	601c      	str	r4, [r3, #0]
       low-level initialization component.  */
    do
    {

        /* Create the system timer thread.  */
        status =  _tx_thread_create(&_tx_timer_thread,
  40289a:	461f      	mov	r7, r3
  40289c:	4e1c      	ldr	r6, [pc, #112]	; (402910 <_tx_timer_initialize+0xbc>)
  40289e:	4d1d      	ldr	r5, [pc, #116]	; (402914 <_tx_timer_initialize+0xc0>)
  4028a0:	683b      	ldr	r3, [r7, #0]
  4028a2:	2200      	movs	r2, #0
  4028a4:	9205      	str	r2, [sp, #20]
  4028a6:	9204      	str	r2, [sp, #16]
  4028a8:	9303      	str	r3, [sp, #12]
  4028aa:	9302      	str	r3, [sp, #8]
  4028ac:	4b16      	ldr	r3, [pc, #88]	; (402908 <_tx_timer_initialize+0xb4>)
  4028ae:	681b      	ldr	r3, [r3, #0]
  4028b0:	9301      	str	r3, [sp, #4]
  4028b2:	4b14      	ldr	r3, [pc, #80]	; (402904 <_tx_timer_initialize+0xb0>)
  4028b4:	681b      	ldr	r3, [r3, #0]
  4028b6:	9300      	str	r3, [sp, #0]
  4028b8:	4633      	mov	r3, r6
  4028ba:	462a      	mov	r2, r5
  4028bc:	4916      	ldr	r1, [pc, #88]	; (402918 <_tx_timer_initialize+0xc4>)
  4028be:	4817      	ldr	r0, [pc, #92]	; (40291c <_tx_timer_initialize+0xc8>)
  4028c0:	4c17      	ldr	r4, [pc, #92]	; (402920 <_tx_timer_initialize+0xcc>)
  4028c2:	47a0      	blx	r4
#endif

        /* Define timer initialize extension.  */
        TX_TIMER_INITIALIZE_EXTENSION(status)

    } while (status != TX_SUCCESS);
  4028c4:	2800      	cmp	r0, #0
  4028c6:	d1eb      	bne.n	4028a0 <_tx_timer_initialize+0x4c>
#endif

#ifndef TX_DISABLE_REDUNDANT_CLEARING

    /* Initialize the head pointer of the created application timer list.  */
    _tx_timer_created_ptr =  TX_NULL;
  4028c8:	2300      	movs	r3, #0
  4028ca:	4a16      	ldr	r2, [pc, #88]	; (402924 <_tx_timer_initialize+0xd0>)
  4028cc:	6013      	str	r3, [r2, #0]

    /* Set the created count to zero.  */
    _tx_timer_created_count =  TX_EMPTY;
  4028ce:	4a16      	ldr	r2, [pc, #88]	; (402928 <_tx_timer_initialize+0xd4>)
  4028d0:	6013      	str	r3, [r2, #0]
    _tx_timer_performance_expiration_count =         ((ULONG) 0);
    _tx_timer_performance__expiration_adjust_count =  ((ULONG) 0);
#endif
#endif
#endif
}
  4028d2:	b007      	add	sp, #28
  4028d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
  4028d6:	bf00      	nop
  4028d8:	20400b04 	.word	0x20400b04
  4028dc:	20400628 	.word	0x20400628
  4028e0:	20400b00 	.word	0x20400b00
  4028e4:	20400624 	.word	0x20400624
  4028e8:	204006e8 	.word	0x204006e8
  4028ec:	204005a4 	.word	0x204005a4
  4028f0:	00403361 	.word	0x00403361
  4028f4:	204006ec 	.word	0x204006ec
  4028f8:	204005a0 	.word	0x204005a0
  4028fc:	20400630 	.word	0x20400630
  402900:	204006f8 	.word	0x204006f8
  402904:	20400af8 	.word	0x20400af8
  402908:	204006f4 	.word	0x204006f4
  40290c:	2040062c 	.word	0x2040062c
  402910:	4154494d 	.word	0x4154494d
  402914:	004029b1 	.word	0x004029b1
  402918:	0040351c 	.word	0x0040351c
  40291c:	20400634 	.word	0x20400634
  402920:	004021b9 	.word	0x004021b9
  402924:	204006f0 	.word	0x204006f0
  402928:	20400afc 	.word	0x20400afc

0040292c <_tx_timer_system_activate>:
ULONG                       remaining_ticks;
ULONG                       expiration_time;


    /* Pickup the remaining ticks.  */
    remaining_ticks =  timer_ptr -> tx_timer_internal_remaining_ticks;
  40292c:	6802      	ldr	r2, [r0, #0]
    /* Determine if there is a timer to activate.  */
    if (remaining_ticks != ((ULONG) 0))
    {

        /* Determine if the timer is set to wait forever.  */
        if (remaining_ticks != TX_WAIT_FOREVER)
  40292e:	1e53      	subs	r3, r2, #1
  402930:	f113 0f03 	cmn.w	r3, #3
  402934:	d801      	bhi.n	40293a <_tx_timer_system_activate+0xe>
        {

            /* Valid timer activate request.  */

            /* Determine if the timer still needs activation.  */
            if (timer_ptr -> tx_timer_internal_list_head == TX_NULL)
  402936:	6981      	ldr	r1, [r0, #24]
  402938:	b101      	cbz	r1, 40293c <_tx_timer_system_activate+0x10>
  40293a:	4770      	bx	lr
                /* Calculate the amount of time remaining for the timer.  */
                if (remaining_ticks > TX_TIMER_ENTRIES)
                {

                    /* Set expiration time to the maximum number of entries.  */
                    expiration_time =  TX_TIMER_ENTRIES - ((ULONG) 1);
  40293c:	2a21      	cmp	r2, #33	; 0x21
  40293e:	bf28      	it	cs
  402940:	231f      	movcs	r3, #31

                /* At this point, we are ready to put the timer on one of
                   the timer lists.  */

                /* Calculate the proper place for the timer.  */
                timer_list =  TX_TIMER_POINTER_ADD(_tx_timer_current_ptr, expiration_time);
  402942:	4a0c      	ldr	r2, [pc, #48]	; (402974 <_tx_timer_system_activate+0x48>)
  402944:	6812      	ldr	r2, [r2, #0]
  402946:	eb02 0383 	add.w	r3, r2, r3, lsl #2
                if (TX_TIMER_INDIRECT_TO_VOID_POINTER_CONVERT(timer_list) >= TX_TIMER_INDIRECT_TO_VOID_POINTER_CONVERT(_tx_timer_list_end))
  40294a:	4a0b      	ldr	r2, [pc, #44]	; (402978 <_tx_timer_system_activate+0x4c>)
  40294c:	6812      	ldr	r2, [r2, #0]
  40294e:	4293      	cmp	r3, r2
  402950:	d303      	bcc.n	40295a <_tx_timer_system_activate+0x2e>
                {

                    /* Wrap from the beginning of the list.  */
                    delta =  TX_TIMER_POINTER_DIF(timer_list, _tx_timer_list_end);
  402952:	1a9b      	subs	r3, r3, r2
                    timer_list =  TX_TIMER_POINTER_ADD(_tx_timer_list_start, delta);
  402954:	4a09      	ldr	r2, [pc, #36]	; (40297c <_tx_timer_system_activate+0x50>)
  402956:	6812      	ldr	r2, [r2, #0]
  402958:	4413      	add	r3, r2
                }

                /* Now put the timer on this list.  */
                if ((*timer_list) == TX_NULL)
  40295a:	681a      	ldr	r2, [r3, #0]
  40295c:	b132      	cbz	r2, 40296c <_tx_timer_system_activate+0x40>
                else
                {

                    /* This list is not NULL, add current timer to the end. */
                    next_timer =                                        *timer_list;
                    previous_timer =                                    next_timer -> tx_timer_internal_active_previous;
  40295e:	6951      	ldr	r1, [r2, #20]
                    previous_timer -> tx_timer_internal_active_next =   timer_ptr;
  402960:	6108      	str	r0, [r1, #16]
                    next_timer -> tx_timer_internal_active_previous =   timer_ptr;
  402962:	6150      	str	r0, [r2, #20]
                    timer_ptr -> tx_timer_internal_active_next =        next_timer;
  402964:	6102      	str	r2, [r0, #16]
                    timer_ptr -> tx_timer_internal_active_previous =    previous_timer;
  402966:	6141      	str	r1, [r0, #20]
                }

                /* Setup list head pointer.  */
                timer_ptr -> tx_timer_internal_list_head =  timer_list;
  402968:	6183      	str	r3, [r0, #24]
            }
        }
    }
}
  40296a:	e7e6      	b.n	40293a <_tx_timer_system_activate+0xe>
                    timer_ptr -> tx_timer_internal_active_next =      timer_ptr;
  40296c:	6100      	str	r0, [r0, #16]
                    timer_ptr -> tx_timer_internal_active_previous =  timer_ptr;
  40296e:	6140      	str	r0, [r0, #20]
                    *timer_list =  timer_ptr;
  402970:	6018      	str	r0, [r3, #0]
  402972:	e7f9      	b.n	402968 <_tx_timer_system_activate+0x3c>
  402974:	204005a0 	.word	0x204005a0
  402978:	20400630 	.word	0x20400630
  40297c:	204006ec 	.word	0x204006ec

00402980 <_tx_timer_system_deactivate>:
TX_TIMER_INTERNAL   *next_timer;
TX_TIMER_INTERNAL   *previous_timer;


    /* Pickup the list head pointer.  */
    list_head =  timer_ptr -> tx_timer_internal_list_head;
  402980:	6982      	ldr	r2, [r0, #24]

    /* Determine if the timer still needs deactivation.  */
    if (list_head != TX_NULL)
  402982:	b152      	cbz	r2, 40299a <_tx_timer_system_deactivate+0x1a>
    {

        /* Deactivate the timer.  */

        /* Pickup the next active timer.  */
        next_timer =  timer_ptr -> tx_timer_internal_active_next;
  402984:	6903      	ldr	r3, [r0, #16]

        /* See if this is the only timer in the list.  */
        if (timer_ptr == next_timer)
  402986:	4298      	cmp	r0, r3
  402988:	d008      	beq.n	40299c <_tx_timer_system_deactivate+0x1c>
        {

            /* At least one more timer is on the same expiration list.  */

            /* Update the links of the adjacent timers.  */
            previous_timer =                                   timer_ptr -> tx_timer_internal_active_previous;
  40298a:	6941      	ldr	r1, [r0, #20]
            next_timer -> tx_timer_internal_active_previous =  previous_timer;
  40298c:	6159      	str	r1, [r3, #20]
            previous_timer -> tx_timer_internal_active_next =  next_timer;
  40298e:	610b      	str	r3, [r1, #16]

            /* Determine if the head pointer needs to be updated.  */
            if (*(list_head) == timer_ptr)
  402990:	6811      	ldr	r1, [r2, #0]
  402992:	4288      	cmp	r0, r1
  402994:	d008      	beq.n	4029a8 <_tx_timer_system_deactivate+0x28>
                *(list_head) =  next_timer;
            }
        }

        /* Clear the timer's list head pointer.  */
        timer_ptr -> tx_timer_internal_list_head =  TX_NULL;
  402996:	2300      	movs	r3, #0
  402998:	6183      	str	r3, [r0, #24]
  40299a:	4770      	bx	lr
            if (*(list_head) == timer_ptr)
  40299c:	6813      	ldr	r3, [r2, #0]
  40299e:	4298      	cmp	r0, r3
  4029a0:	d1f9      	bne.n	402996 <_tx_timer_system_deactivate+0x16>
                *(list_head) =  TX_NULL;
  4029a2:	2300      	movs	r3, #0
  4029a4:	6013      	str	r3, [r2, #0]
  4029a6:	e7f6      	b.n	402996 <_tx_timer_system_deactivate+0x16>
                next_timer -> tx_timer_internal_list_head =  list_head;
  4029a8:	619a      	str	r2, [r3, #24]
                *(list_head) =  next_timer;
  4029aa:	6013      	str	r3, [r2, #0]
  4029ac:	e7f3      	b.n	402996 <_tx_timer_system_deactivate+0x16>
	...

004029b0 <_tx_timer_thread_entry>:
#endif


    /* Make sure the timer input is correct.  This also gets rid of the
       silly compiler warnings.  */
    if (timer_thread_input == TX_TIMER_ID)
  4029b0:	4b44      	ldr	r3, [pc, #272]	; (402ac4 <_tx_timer_thread_entry+0x114>)
  4029b2:	4298      	cmp	r0, r3
  4029b4:	f040 8085 	bne.w	402ac2 <_tx_timer_thread_entry+0x112>
{
  4029b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4029bc:	b083      	sub	sp, #12
  4029be:	f04f 0900 	mov.w	r9, #0
               expired value.  This allows the interrupt handling portion
               to continue looking for timer expirations.  */
            TX_DISABLE

            /* Save the current timer expiration list pointer.  */
            expired_timers =  *_tx_timer_current_ptr;
  4029c2:	f8df a120 	ldr.w	sl, [pc, #288]	; 402ae4 <_tx_timer_thread_entry+0x134>

                expired_timers -> tx_timer_internal_list_head =  &expired_timers;
            }

            /* Set the current list pointer to NULL.  */
            *_tx_timer_current_ptr =  TX_NULL;
  4029c6:	46c8      	mov	r8, r9

                _tx_timer_current_ptr =  _tx_timer_list_start;
            }

            /* Clear the expired flag.  */
            _tx_timer_expired =  TX_FALSE;
  4029c8:	f8df b11c 	ldr.w	fp, [pc, #284]	; 402ae8 <_tx_timer_thread_entry+0x138>
  4029cc:	464f      	mov	r7, r9
                        current_timer -> tx_timer_internal_list_head =  TX_NULL;
                    }
                }

                /* Set pointer to indicate the expired timer that is currently being processed.  */
                _tx_timer_expired_timer_ptr =  current_timer;
  4029ce:	4d3e      	ldr	r5, [pc, #248]	; (402ac8 <_tx_timer_thread_entry+0x118>)
  4029d0:	e049      	b.n	402a66 <_tx_timer_thread_entry+0xb6>
                _tx_timer_current_ptr =  _tx_timer_list_start;
  4029d2:	4b3e      	ldr	r3, [pc, #248]	; (402acc <_tx_timer_thread_entry+0x11c>)
  4029d4:	681b      	ldr	r3, [r3, #0]
  4029d6:	f8ca 3000 	str.w	r3, [sl]
  4029da:	e059      	b.n	402a90 <_tx_timer_thread_entry+0xe0>
                    expired_timers =  TX_NULL;
  4029dc:	9701      	str	r7, [sp, #4]
  4029de:	e029      	b.n	402a34 <_tx_timer_thread_entry+0x84>
                    timeout_function =  current_timer -> tx_timer_internal_timeout_function;
  4029e0:	68a3      	ldr	r3, [r4, #8]
                    timeout_param =     current_timer -> tx_timer_internal_timeout_param;
  4029e2:	f8d4 900c 	ldr.w	r9, [r4, #12]
                    current_timer -> tx_timer_internal_remaining_ticks =  current_timer -> tx_timer_internal_re_initialize_ticks;
  4029e6:	6862      	ldr	r2, [r4, #4]
  4029e8:	6022      	str	r2, [r4, #0]
                    if (current_timer -> tx_timer_internal_remaining_ticks != ((ULONG) 0))
  4029ea:	2a00      	cmp	r2, #0
  4029ec:	d02d      	beq.n	402a4a <_tx_timer_thread_entry+0x9a>
                        current_timer -> tx_timer_internal_list_head =    &reactivate_timer;
  4029ee:	f8c4 d018 	str.w	sp, [r4, #24]
                        current_timer -> tx_timer_internal_active_next =  current_timer;
  4029f2:	6124      	str	r4, [r4, #16]
                        reactivate_timer =  current_timer;
  4029f4:	9400      	str	r4, [sp, #0]
                _tx_timer_expired_timer_ptr =  current_timer;
  4029f6:	602c      	str	r4, [r5, #0]
  4029f8:	f381 8810 	msr	PRIMASK, r1

                /* Restore interrupts for timer expiration call.  */
                TX_RESTORE

                /* Call the timer-expiration function, if non-NULL.  */
                if (timeout_function != TX_NULL)
  4029fc:	b10b      	cbz	r3, 402a02 <_tx_timer_thread_entry+0x52>
                {

                    (timeout_function) (timeout_param);
  4029fe:	4648      	mov	r0, r9
  402a00:	4798      	blx	r3
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  402a02:	f3ef 8610 	mrs	r6, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  402a06:	b672      	cpsid	i

                /* Lockout interrupts again.  */
                TX_DISABLE

                /* Clear expired timer pointer.  */
                _tx_timer_expired_timer_ptr =  TX_NULL;
  402a08:	f8c5 8000 	str.w	r8, [r5]

                /* Determine if the timer needs to be reactivated.  */
                if (reactivate_timer == current_timer)
  402a0c:	9b00      	ldr	r3, [sp, #0]
  402a0e:	42a3      	cmp	r3, r4
  402a10:	d01e      	beq.n	402a50 <_tx_timer_thread_entry+0xa0>
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  402a12:	f386 8810 	msr	PRIMASK, r6
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  402a16:	f3ef 8110 	mrs	r1, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  402a1a:	b672      	cpsid	i
            while (expired_timers != TX_NULL)
  402a1c:	9c01      	ldr	r4, [sp, #4]
  402a1e:	b1ec      	cbz	r4, 402a5c <_tx_timer_thread_entry+0xac>
                next_timer =  expired_timers -> tx_timer_internal_active_next;
  402a20:	6923      	ldr	r3, [r4, #16]
                reactivate_timer =  TX_NULL;
  402a22:	9700      	str	r7, [sp, #0]
                if (current_timer == next_timer)
  402a24:	42a3      	cmp	r3, r4
  402a26:	d0d9      	beq.n	4029dc <_tx_timer_thread_entry+0x2c>
                    previous_timer =                                   current_timer -> tx_timer_internal_active_previous;
  402a28:	6962      	ldr	r2, [r4, #20]
                    next_timer -> tx_timer_internal_active_previous =  previous_timer;
  402a2a:	615a      	str	r2, [r3, #20]
                    previous_timer -> tx_timer_internal_active_next =  next_timer;
  402a2c:	6113      	str	r3, [r2, #16]
                    next_timer -> tx_timer_internal_list_head =  &expired_timers;
  402a2e:	aa01      	add	r2, sp, #4
  402a30:	619a      	str	r2, [r3, #24]
                    expired_timers =  next_timer;
  402a32:	9301      	str	r3, [sp, #4]
                if (current_timer -> tx_timer_internal_remaining_ticks > TX_TIMER_ENTRIES)
  402a34:	6823      	ldr	r3, [r4, #0]
  402a36:	2b20      	cmp	r3, #32
  402a38:	d9d2      	bls.n	4029e0 <_tx_timer_thread_entry+0x30>
                            current_timer -> tx_timer_internal_remaining_ticks - TX_TIMER_ENTRIES;
  402a3a:	3b20      	subs	r3, #32
                    current_timer -> tx_timer_internal_remaining_ticks =
  402a3c:	6023      	str	r3, [r4, #0]
                    current_timer -> tx_timer_internal_list_head =    &reactivate_timer;
  402a3e:	f8c4 d018 	str.w	sp, [r4, #24]
                    current_timer -> tx_timer_internal_active_next =  current_timer;
  402a42:	6124      	str	r4, [r4, #16]
                    reactivate_timer =  current_timer;
  402a44:	9400      	str	r4, [sp, #0]
                    timeout_function =  TX_NULL;
  402a46:	463b      	mov	r3, r7
  402a48:	e7d5      	b.n	4029f6 <_tx_timer_thread_entry+0x46>
                        current_timer -> tx_timer_internal_list_head =  TX_NULL;
  402a4a:	f8c4 8018 	str.w	r8, [r4, #24]
  402a4e:	e7d2      	b.n	4029f6 <_tx_timer_thread_entry+0x46>
#else

                    /* Reactivate through the timer activate function.  */

                    /* Clear the list head for the timer activate call.  */
                    current_timer -> tx_timer_internal_list_head = TX_NULL;
  402a50:	f8c4 8018 	str.w	r8, [r4, #24]

                    /* Activate the current timer.  */
                    _tx_timer_system_activate(current_timer);
  402a54:	4620      	mov	r0, r4
  402a56:	4b1e      	ldr	r3, [pc, #120]	; (402ad0 <_tx_timer_thread_entry+0x120>)
  402a58:	4798      	blx	r3
  402a5a:	e7da      	b.n	402a12 <_tx_timer_thread_entry+0x62>

            /* Finally, suspend this thread and wait for the next expiration.  */

            /* Determine if another expiration took place while we were in this
               thread.  If so, process another expiration.  */
            if (_tx_timer_expired == TX_FALSE)
  402a5c:	f8db 3000 	ldr.w	r3, [fp]
  402a60:	b30b      	cbz	r3, 402aa6 <_tx_timer_thread_entry+0xf6>
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  402a62:	f381 8810 	msr	PRIMASK, r1
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  402a66:	f3ef 8110 	mrs	r1, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  402a6a:	b672      	cpsid	i
            expired_timers =  *_tx_timer_current_ptr;
  402a6c:	f8da 2000 	ldr.w	r2, [sl]
  402a70:	6813      	ldr	r3, [r2, #0]
  402a72:	9301      	str	r3, [sp, #4]
            if (expired_timers != TX_NULL)
  402a74:	b10b      	cbz	r3, 402a7a <_tx_timer_thread_entry+0xca>
                expired_timers -> tx_timer_internal_list_head =  &expired_timers;
  402a76:	a801      	add	r0, sp, #4
  402a78:	6198      	str	r0, [r3, #24]
            *_tx_timer_current_ptr =  TX_NULL;
  402a7a:	f8c2 8000 	str.w	r8, [r2]
            _tx_timer_current_ptr =  TX_TIMER_POINTER_ADD(_tx_timer_current_ptr, 1);
  402a7e:	f8da 3000 	ldr.w	r3, [sl]
  402a82:	3304      	adds	r3, #4
  402a84:	f8ca 3000 	str.w	r3, [sl]
            if (_tx_timer_current_ptr == _tx_timer_list_end)
  402a88:	4a12      	ldr	r2, [pc, #72]	; (402ad4 <_tx_timer_thread_entry+0x124>)
  402a8a:	6812      	ldr	r2, [r2, #0]
  402a8c:	4293      	cmp	r3, r2
  402a8e:	d0a0      	beq.n	4029d2 <_tx_timer_thread_entry+0x22>
            _tx_timer_expired =  TX_FALSE;
  402a90:	f8cb 7000 	str.w	r7, [fp]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  402a94:	f381 8810 	msr	PRIMASK, r1
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  402a98:	f3ef 8110 	mrs	r1, PRIMASK
    __asm__ volatile ("CPSID i" : : : "memory");
  402a9c:	b672      	cpsid	i
            while (expired_timers != TX_NULL)
  402a9e:	9c01      	ldr	r4, [sp, #4]
  402aa0:	2c00      	cmp	r4, #0
  402aa2:	d1bd      	bne.n	402a20 <_tx_timer_thread_entry+0x70>
  402aa4:	e7da      	b.n	402a5c <_tx_timer_thread_entry+0xac>
                /* Build pointer to the timer thread.  */
                thread_ptr =  &_tx_timer_thread;

                /* Set the status to suspending, in order to indicate the
                   suspension is in progress.  */
                thread_ptr -> tx_thread_state =  TX_SUSPENDED;
  402aa6:	480c      	ldr	r0, [pc, #48]	; (402ad8 <_tx_timer_thread_entry+0x128>)
  402aa8:	2303      	movs	r3, #3
  402aaa:	6303      	str	r3, [r0, #48]	; 0x30
                /* Restore interrupts.  */
                TX_RESTORE
#else

                /* Set the suspending flag. */
                thread_ptr -> tx_thread_suspending =  TX_TRUE;
  402aac:	2301      	movs	r3, #1
  402aae:	6383      	str	r3, [r0, #56]	; 0x38

                /* Increment the preempt disable count prior to suspending.  */
                _tx_thread_preempt_disable++;
  402ab0:	4a0a      	ldr	r2, [pc, #40]	; (402adc <_tx_timer_thread_entry+0x12c>)
  402ab2:	6813      	ldr	r3, [r2, #0]
  402ab4:	3301      	adds	r3, #1
  402ab6:	6013      	str	r3, [r2, #0]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  402ab8:	f381 8810 	msr	PRIMASK, r1

                /* Restore interrupts.  */
                TX_RESTORE

                /* Call actual thread suspension routine.  */
                _tx_thread_system_suspend(thread_ptr);
  402abc:	4b08      	ldr	r3, [pc, #32]	; (402ae0 <_tx_timer_thread_entry+0x130>)
  402abe:	4798      	blx	r3
  402ac0:	e7d1      	b.n	402a66 <_tx_timer_thread_entry+0xb6>
  402ac2:	4770      	bx	lr
  402ac4:	4154494d 	.word	0x4154494d
  402ac8:	204006e8 	.word	0x204006e8
  402acc:	204006ec 	.word	0x204006ec
  402ad0:	0040292d 	.word	0x0040292d
  402ad4:	20400630 	.word	0x20400630
  402ad8:	20400634 	.word	0x20400634
  402adc:	2040058c 	.word	0x2040058c
  402ae0:	004025d9 	.word	0x004025d9
  402ae4:	204005a0 	.word	0x204005a0
  402ae8:	20400624 	.word	0x20400624
  402aec:	00000000 	.word	0x00000000

00402af0 <_tx_initialize_low_level>:
    .global  _tx_initialize_low_level
    .thumb_func
_tx_initialize_low_level:

    /* Disable interrupts during ThreadX initialization.  */
    CPSID   i
  402af0:	b672      	cpsid	i

    /* Set base of available memory to end of non-initialised RAM area.  */
    LDR     r0, =_tx_initialize_unused_memory       // Build address of unused memory pointer
  402af2:	481d      	ldr	r0, [pc, #116]	; (402b68 <__tx_DBGHandler+0x4>)
    LDR     r1, =__RAM_segment_used_end__           // Build first free address
  402af4:	491d      	ldr	r1, [pc, #116]	; (402b6c <__tx_DBGHandler+0x8>)
    ADD     r1, r1, #4                              //
  402af6:	f101 0104 	add.w	r1, r1, #4
    STR     r1, [r0]                                // Setup first unused memory pointer
  402afa:	6001      	str	r1, [r0, #0]

    /* Setup Vector Table Offset Register.  */
    MOV     r0, #0xE000E000                         // Build address of NVIC registers
  402afc:	f04f 20e0 	mov.w	r0, #3758153728	; 0xe000e000
    LDR     r1, =exception_table                           // Pickup address of vector table
  402b00:	491b      	ldr	r1, [pc, #108]	; (402b70 <__tx_DBGHandler+0xc>)
    STR     r1, [r0, #0xD08]                        // Set vector table address
  402b02:	f8c0 1d08 	str.w	r1, [r0, #3336]	; 0xd08

    /* Set system stack pointer from vector value.  */
    LDR     r0, =_tx_thread_system_stack_ptr        // Build address of system stack pointer
  402b06:	481b      	ldr	r0, [pc, #108]	; (402b74 <__tx_DBGHandler+0x10>)
    LDR     r1, =exception_table                           // Pickup address of vector table
  402b08:	4919      	ldr	r1, [pc, #100]	; (402b70 <__tx_DBGHandler+0xc>)
    LDR     r1, [r1]                                // Pickup reset stack pointer
  402b0a:	6809      	ldr	r1, [r1, #0]
    STR     r1, [r0]                                // Save system stack pointer
  402b0c:	6001      	str	r1, [r0, #0]

    /* Enable the cycle count register.  */
    LDR     r0, =0xE0001000                         // Build address of DWT register
  402b0e:	481a      	ldr	r0, [pc, #104]	; (402b78 <__tx_DBGHandler+0x14>)
    LDR     r1, [r0]                                // Pickup the current value
  402b10:	6801      	ldr	r1, [r0, #0]
    ORR     r1, r1, #1                              // Set the CYCCNTENA bit
  402b12:	f041 0101 	orr.w	r1, r1, #1
    STR     r1, [r0]                                // Enable the cycle count register
  402b16:	6001      	str	r1, [r0, #0]

    /* Configure SysTick.  */
    MOV     r0, #0xE000E000                         // Build address of NVIC registers
  402b18:	f04f 20e0 	mov.w	r0, #3758153728	; 0xe000e000
    LDR     r1, =SYSTICK_CYCLES
  402b1c:	f64e 215f 	movw	r1, #59999	; 0xea5f
    STR     r1, [r0, #0x14]                         // Setup SysTick Reload Value
  402b20:	6141      	str	r1, [r0, #20]
    MOV     r1, #0x7                                // Build SysTick Control Enable Value
  402b22:	f04f 0107 	mov.w	r1, #7
    STR     r1, [r0, #0x10]                         // Setup SysTick Control
  402b26:	6101      	str	r1, [r0, #16]

    /* Configure handler priorities.  */
    LDR     r1, =0x00000000                         // Rsrv, UsgF, BusF, MemM
  402b28:	f04f 0100 	mov.w	r1, #0
    STR     r1, [r0, #0xD18]                        // Setup System Handlers 4-7 Priority Registers
  402b2c:	f8c0 1d18 	str.w	r1, [r0, #3352]	; 0xd18
    LDR     r1, =0xFF000000                         // SVCl, Rsrv, Rsrv, Rsrv
  402b30:	f04f 417f 	mov.w	r1, #4278190080	; 0xff000000
    STR     r1, [r0, #0xD1C]                        // Setup System Handlers 8-11 Priority Registers
  402b34:	f8c0 1d1c 	str.w	r1, [r0, #3356]	; 0xd1c
                                                    // Note: SVC must be lowest priority, which is 0xFF
    LDR     r1, =0x40FF0000                         // SysT, PnSV, Rsrv, DbgM
  402b38:	4910      	ldr	r1, [pc, #64]	; (402b7c <__tx_DBGHandler+0x18>)
    STR     r1, [r0, #0xD20]                        // Setup System Handlers 12-15 Priority Registers
  402b3a:	f8c0 1d20 	str.w	r1, [r0, #3360]	; 0xd20
                                                    // Note: PnSV must be lowest priority, which is 0xFF

    /* Return to caller.  */
    BX      lr
  402b3e:	4770      	bx	lr

00402b40 <__tx_BadHandler>:

/* Define shells for each of the unused vectors.  */
    .global  __tx_BadHandler
    .thumb_func
__tx_BadHandler:
    B       __tx_BadHandler
  402b40:	f7ff bffe 	b.w	402b40 <__tx_BadHandler>

00402b44 <__tx_HardfaultHandler>:

/* added to catch the hardfault */
    .global  __tx_HardfaultHandler
    .thumb_func
__tx_HardfaultHandler:
    B       __tx_HardfaultHandler
  402b44:	f7ff bffe 	b.w	402b44 <__tx_HardfaultHandler>

00402b48 <__tx_SVCallHandler>:

/* added to catch the SVC */
    .global  __tx_SVCallHandler
    .thumb_func
__tx_SVCallHandler:
    B       __tx_SVCallHandler
  402b48:	f7ff bffe 	b.w	402b48 <__tx_SVCallHandler>

00402b4c <__tx_IntHandler>:
    .global  __tx_IntHandler
    .thumb_func
__tx_IntHandler:
// VOID InterruptHandler (VOID)
// {
    PUSH    {r0, lr}
  402b4c:	b501      	push	{r0, lr}
    /* Do interrupt handler work here */
    /* BL <your C Function>.... */
#ifdef TX_ENABLE_EXECUTION_CHANGE_NOTIFY
    BL      _tx_execution_isr_exit              // Call the ISR exit function
#endif
    POP     {r0, lr}
  402b4e:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
    BX      LR
  402b52:	4770      	bx	lr

00402b54 <SysTick_Handler>:
__tx_SysTickHandler:
    .thumb_func
SysTick_Handler:
// VOID SysTick_Handler (VOID)
// {
    PUSH    {r0, lr}
  402b54:	b501      	push	{r0, lr}
#ifdef TX_ENABLE_EXECUTION_CHANGE_NOTIFY
    BL      _tx_execution_isr_enter             // Call the ISR enter function
#endif
    BL      _tx_timer_interrupt
  402b56:	f000 f883 	bl	402c60 <_tx_timer_interrupt>
#ifdef TX_ENABLE_EXECUTION_CHANGE_NOTIFY
    BL      _tx_execution_isr_exit              // Call the ISR exit function
#endif
    POP     {r0, lr}
  402b5a:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
    BX      lr
  402b5e:	4770      	bx	lr

00402b60 <__tx_NMIHandler>:

/* NMI, DBG handlers */
    .global  __tx_NMIHandler
    .thumb_func
__tx_NMIHandler:
    B       __tx_NMIHandler
  402b60:	f7ff bffe 	b.w	402b60 <__tx_NMIHandler>

00402b64 <__tx_DBGHandler>:

    .global  __tx_DBGHandler
    .thumb_func
__tx_DBGHandler:
    B       __tx_DBGHandler
  402b64:	f7ff bffe 	b.w	402b64 <__tx_DBGHandler>
    LDR     r0, =_tx_initialize_unused_memory       // Build address of unused memory pointer
  402b68:	204004d8 	.word	0x204004d8
    LDR     r1, =__RAM_segment_used_end__           // Build first free address
  402b6c:	204057b0 	.word	0x204057b0
    LDR     r1, =exception_table                           // Pickup address of vector table
  402b70:	00400000 	.word	0x00400000
    LDR     r0, =_tx_thread_system_stack_ptr        // Build address of system stack pointer
  402b74:	20400588 	.word	0x20400588
    LDR     r0, =0xE0001000                         // Build address of DWT register
  402b78:	e0001000 	.word	0xe0001000
    LDR     r1, =0x40FF0000                         // SysT, PnSV, Rsrv, DbgM
  402b7c:	40ff0000 	.word	0x40ff0000

00402b80 <_tx_thread_schedule>:
       from the first schedule request. Subsequent scheduling occurs
       from the PendSV handling routine below. */

    /* Clear the preempt-disable flag to enable rescheduling after initialization on Cortex-M targets.  */

    MOV     r0, #0                                  // Build value for TX_FALSE
  402b80:	f04f 0000 	mov.w	r0, #0
    LDR     r2, =_tx_thread_preempt_disable         // Build address of preempt disable flag
  402b84:	4a22      	ldr	r2, [pc, #136]	; (402c10 <__tx_ts_ready+0x12>)
    STR     r0, [r2, #0]                            // Clear preempt disable flag
  402b86:	6010      	str	r0, [r2, #0]
    BIC     r0, r0, #4                              // Clear the FPCA bit
    MSR     CONTROL, r0                             // Setup new CONTROL register
#endif

    /* Enable interrupts */
    CPSIE   i
  402b88:	b662      	cpsie	i

    /* Enter the scheduler for the first time.  */

    MOV     r0, #0x10000000                         // Load PENDSVSET bit
  402b8a:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
    MOV     r1, #0xE000E000                         // Load NVIC base
  402b8e:	f04f 21e0 	mov.w	r1, #3758153728	; 0xe000e000
    STR     r0, [r1, #0xD04]                        // Set PENDSVBIT in ICSR
  402b92:	f8c1 0d04 	str.w	r0, [r1, #3332]	; 0xd04
    DSB                                             // Complete all memory accesses
  402b96:	f3bf 8f4f 	dsb	sy
    ISB                                             // Flush pipeline
  402b9a:	f3bf 8f6f 	isb	sy

00402b9e <__tx_wait_here>:

    /* Wait here for the PendSV to take place.  */

__tx_wait_here:
    B       __tx_wait_here                          // Wait for the PendSV to happen
  402b9e:	e7fe      	b.n	402b9e <__tx_wait_here>

00402ba0 <PendSV_Handler>:
#else
    CPSIE   i                                       // Enable interrupts
#endif  /* TX_PORT_USE_BASEPRI */
#endif  /* EXECUTION PROFILE */

    LDR     r0, =_tx_thread_current_ptr             // Build current thread pointer address
  402ba0:	481c      	ldr	r0, [pc, #112]	; (402c14 <__tx_ts_ready+0x16>)
    LDR     r2, =_tx_thread_execute_ptr             // Build execute thread pointer address
  402ba2:	4a1d      	ldr	r2, [pc, #116]	; (402c18 <__tx_ts_ready+0x1a>)
    MOV     r3, #0                                  // Build NULL value
  402ba4:	f04f 0300 	mov.w	r3, #0
    LDR     r1, [r0]                                // Pickup current thread pointer
  402ba8:	6801      	ldr	r1, [r0, #0]

    /* Determine if there is a current thread to finish preserving.  */

    CBZ     r1, __tx_ts_new                         // If NULL, skip preservation
  402baa:	b169      	cbz	r1, 402bc8 <__tx_ts_new>

    /* Recover PSP and preserve current thread context.  */

    STR     r3, [r0]                                // Set _tx_thread_current_ptr to NULL
  402bac:	6003      	str	r3, [r0, #0]
    MRS     r12, PSP                                // Pickup PSP pointer (thread's stack pointer)
  402bae:	f3ef 8c09 	mrs	ip, PSP
    STMDB   r12!, {r4-r11}                          // Save its remaining registers
  402bb2:	e92c 0ff0 	stmdb	ip!, {r4, r5, r6, r7, r8, r9, sl, fp}
    TST     LR, #0x10                               // Determine if the VFP extended frame is present
    BNE     _skip_vfp_save
    VSTMDB  r12!,{s16-s31}                          // Yes, save additional VFP registers
_skip_vfp_save:
#endif
    LDR     r4, =_tx_timer_time_slice               // Build address of time-slice variable
  402bb6:	4c19      	ldr	r4, [pc, #100]	; (402c1c <__tx_ts_ready+0x1e>)
    STMDB   r12!, {LR}                              // Save LR on the stack
  402bb8:	f84c ed04 	str.w	lr, [ip, #-4]!

    /* Determine if time-slice is active. If it isn't, skip time handling processing.  */

    LDR     r5, [r4]                                // Pickup current time-slice
  402bbc:	6825      	ldr	r5, [r4, #0]
    STR     r12, [r1, #8]                           // Save the thread stack pointer
  402bbe:	f8c1 c008 	str.w	ip, [r1, #8]
    CBZ     r5, __tx_ts_new                         // If not active, skip processing
  402bc2:	b10d      	cbz	r5, 402bc8 <__tx_ts_new>

    /* Time-slice is active, save the current thread's time-slice and clear the global time-slice variable.  */

    STR     r5, [r1, #24]                           // Save current time-slice
  402bc4:	618d      	str	r5, [r1, #24]

    /* Clear the global time-slice.  */

    STR     r3, [r4]                                // Clear time-slice
  402bc6:	6023      	str	r3, [r4, #0]

00402bc8 <__tx_ts_new>:

#ifdef TX_PORT_USE_BASEPRI
    LDR     r1, =TX_PORT_BASEPRI                    // Mask interrupt priorities =< TX_PORT_BASEPRI
    MSR     BASEPRI, r1
#else
    CPSID   i                                       // Disable interrupts
  402bc8:	b672      	cpsid	i
#endif
    LDR     r1, [r2]                                // Is there another thread ready to execute?
  402bca:	6811      	ldr	r1, [r2, #0]
    CBZ     r1, __tx_ts_wait                        // No, skip to the wait processing
  402bcc:	b189      	cbz	r1, 402bf2 <__tx_ts_wait>

    /* Yes, another thread is ready for else, make the current thread the new thread.  */

    STR     r1, [r0]                                // Setup the current thread pointer to the new thread
  402bce:	6001      	str	r1, [r0, #0]
#ifdef TX_PORT_USE_BASEPRI
    MOV     r4, #0                                  // Disable BASEPRI masking (enable interrupts)
    MSR     BASEPRI, r4
#else
    CPSIE   i                                       // Enable interrupts
  402bd0:	b662      	cpsie	i

00402bd2 <__tx_ts_restore>:
#endif

    /* Increment the thread run count.  */

__tx_ts_restore:
    LDR     r7, [r1, #4]                            // Pickup the current thread run count
  402bd2:	684f      	ldr	r7, [r1, #4]
    LDR     r4, =_tx_timer_time_slice               // Build address of time-slice variable
  402bd4:	4c11      	ldr	r4, [pc, #68]	; (402c1c <__tx_ts_ready+0x1e>)
    LDR     r5, [r1, #24]                           // Pickup thread's current time-slice
  402bd6:	698d      	ldr	r5, [r1, #24]
    ADD     r7, r7, #1                              // Increment the thread run count
  402bd8:	f107 0701 	add.w	r7, r7, #1
    STR     r7, [r1, #4]                            // Store the new run count
  402bdc:	604f      	str	r7, [r1, #4]

    /* Setup global time-slice with thread's current time-slice.  */

    STR     r5, [r4]                                // Setup global time-slice
  402bde:	6025      	str	r5, [r4, #0]
    POP     {r0, r1}                                // Recover r0 and r1
#endif

    /* Restore the thread context and PSP.  */

    LDR     r12, [r1, #8]                           // Pickup thread's stack pointer
  402be0:	f8d1 c008 	ldr.w	ip, [r1, #8]
    LDMIA   r12!, {LR}                              // Pickup LR
  402be4:	f85c eb04 	ldr.w	lr, [ip], #4
    TST     LR, #0x10                               // Determine if the VFP extended frame is present
    BNE     _skip_vfp_restore                       // If not, skip VFP restore
    VLDMIA  r12!, {s16-s31}                         // Yes, restore additional VFP registers
_skip_vfp_restore:
#endif
    LDMIA   r12!, {r4-r11}                          // Recover thread's registers
  402be8:	e8bc 0ff0 	ldmia.w	ip!, {r4, r5, r6, r7, r8, r9, sl, fp}
    MSR     PSP, r12                                // Setup the thread's stack pointer
  402bec:	f38c 8809 	msr	PSP, ip

    /* Return to thread.  */

    BX      lr                                      // Return to thread!
  402bf0:	4770      	bx	lr

00402bf2 <__tx_ts_wait>:
__tx_ts_wait:
#ifdef TX_PORT_USE_BASEPRI
    LDR     r1, =TX_PORT_BASEPRI                    // Mask interrupt priorities =< TX_PORT_BASEPRI
    MSR     BASEPRI, r1
#else
    CPSID   i                                       // Disable interrupts
  402bf2:	b672      	cpsid	i
#endif
    LDR     r1, [r2]                                // Pickup the next thread to execute pointer
  402bf4:	6811      	ldr	r1, [r2, #0]
    STR     r1, [r0]                                // Store it in the current pointer
  402bf6:	6001      	str	r1, [r0, #0]
    CBNZ    r1, __tx_ts_ready                       // If non-NULL, a new thread is ready!
  402bf8:	b909      	cbnz	r1, 402bfe <__tx_ts_ready>

#ifdef TX_PORT_USE_BASEPRI
    MOV     r4, #0                                  // Disable BASEPRI masking (enable interrupts)
    MSR     BASEPRI, r4
#else
    CPSIE   i                                       // Enable interrupts
  402bfa:	b662      	cpsie	i
#endif
    B       __tx_ts_wait                            // Loop to continue waiting
  402bfc:	e7f9      	b.n	402bf2 <__tx_ts_wait>

00402bfe <__tx_ts_ready>:

    /* At this point, we have a new thread ready to go. Clear any newly pended PendSV - since we are
       already in the handler!  */

__tx_ts_ready:
    MOV     r7, #0x08000000                         // Build clear PendSV value
  402bfe:	f04f 6700 	mov.w	r7, #134217728	; 0x8000000
    MOV     r8, #0xE000E000                         // Build base NVIC address
  402c02:	f04f 28e0 	mov.w	r8, #3758153728	; 0xe000e000
    STR     r7, [r8, #0xD04]                        // Clear any PendSV
  402c06:	f8c8 7d04 	str.w	r7, [r8, #3332]	; 0xd04
    /* Re-enable interrupts and restore new thread.  */
#ifdef TX_PORT_USE_BASEPRI
    MOV     r4, #0                                  // Disable BASEPRI masking (enable interrupts)
    MSR     BASEPRI, r4
#else
    CPSIE   i                                       // Enable interrupts
  402c0a:	b662      	cpsie	i
#endif
    B       __tx_ts_restore                         // Restore the thread
  402c0c:	e7e1      	b.n	402bd2 <__tx_ts_restore>
  402c0e:	0000      	.short	0x0000
    LDR     r2, =_tx_thread_preempt_disable         // Build address of preempt disable flag
  402c10:	2040058c 	.word	0x2040058c
    LDR     r0, =_tx_thread_current_ptr             // Build current thread pointer address
  402c14:	20400590 	.word	0x20400590
    LDR     r2, =_tx_thread_execute_ptr             // Build execute thread pointer address
  402c18:	20400594 	.word	0x20400594
    LDR     r4, =_tx_timer_time_slice               // Build address of time-slice variable
  402c1c:	20400628 	.word	0x20400628

00402c20 <_tx_thread_stack_build>:
                       pc          Initial value for pc
                       xPSR        Initial value for xPSR

    Stack Bottom: (higher memory address)  */

    LDR     r2, [r0, #16]                           // Pickup end of stack area
  402c20:	6902      	ldr	r2, [r0, #16]
    BIC     r2, r2, #0x7                            // Align frame for 8-byte alignment
  402c22:	f022 0207 	bic.w	r2, r2, #7
    SUB     r2, r2, #68                             // Subtract frame size
  402c26:	f1a2 0244 	sub.w	r2, r2, #68	; 0x44
    LDR     r3, =0xFFFFFFFD                         // Build initial LR value
  402c2a:	f06f 0302 	mvn.w	r3, #2
    STR     r3, [r2, #0]                            // Save on the stack
  402c2e:	6013      	str	r3, [r2, #0]

    /* Actually build the stack frame.  */

    MOV     r3, #0                                  // Build initial register value
  402c30:	f04f 0300 	mov.w	r3, #0
    STR     r3, [r2, #4]                            // Store initial r4
  402c34:	6053      	str	r3, [r2, #4]
    STR     r3, [r2, #8]                            // Store initial r5
  402c36:	6093      	str	r3, [r2, #8]
    STR     r3, [r2, #12]                           // Store initial r6
  402c38:	60d3      	str	r3, [r2, #12]
    STR     r3, [r2, #16]                           // Store initial r7
  402c3a:	6113      	str	r3, [r2, #16]
    STR     r3, [r2, #20]                           // Store initial r8
  402c3c:	6153      	str	r3, [r2, #20]
    STR     r3, [r2, #24]                           // Store initial r9
  402c3e:	6193      	str	r3, [r2, #24]
    STR     r3, [r2, #28]                           // Store initial r10
  402c40:	61d3      	str	r3, [r2, #28]
    STR     r3, [r2, #32]                           // Store initial r11
  402c42:	6213      	str	r3, [r2, #32]

    /* Hardware stack follows.  */

    STR     r3, [r2, #36]                           // Store initial r0
  402c44:	6253      	str	r3, [r2, #36]	; 0x24
    STR     r3, [r2, #40]                           // Store initial r1
  402c46:	6293      	str	r3, [r2, #40]	; 0x28
    STR     r3, [r2, #44]                           // Store initial r2
  402c48:	62d3      	str	r3, [r2, #44]	; 0x2c
    STR     r3, [r2, #48]                           // Store initial r3
  402c4a:	6313      	str	r3, [r2, #48]	; 0x30
    STR     r3, [r2, #52]                           // Store initial r12
  402c4c:	6353      	str	r3, [r2, #52]	; 0x34
    MOV     r3, #0xFFFFFFFF                         // Poison EXC_RETURN value
  402c4e:	f04f 33ff 	mov.w	r3, #4294967295
    STR     r3, [r2, #56]                           // Store initial lr
  402c52:	6393      	str	r3, [r2, #56]	; 0x38
    STR     r1, [r2, #60]                           // Store initial pc
  402c54:	63d1      	str	r1, [r2, #60]	; 0x3c
    MOV     r3, #0x01000000                         // Only T-bit need be set
  402c56:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
    STR     r3, [r2, #64]                           // Store initial xPSR
  402c5a:	6413      	str	r3, [r2, #64]	; 0x40

    /* Setup stack pointer.  */
    // thread_ptr -> tx_thread_stack_ptr =  r2;

    STR     r2, [r0, #8]                            // Save stack pointer in thread's
  402c5c:	6082      	str	r2, [r0, #8]
                                                    //   control block
    BX      lr                                      // Return to caller
  402c5e:	4770      	bx	lr

00402c60 <_tx_timer_interrupt>:
       for use.  */

    /* Increment the system clock.  */
    // _tx_timer_system_clock++;

    LDR     r1, =_tx_timer_system_clock             // Pickup address of system clock
  402c60:	4922      	ldr	r1, [pc, #136]	; (402cec <__tx_timer_nothing_expired+0x6>)
    LDR     r0, [r1, #0]                            // Pickup system clock
  402c62:	6808      	ldr	r0, [r1, #0]
    ADD     r0, r0, #1                              // Increment system clock
  402c64:	f100 0001 	add.w	r0, r0, #1
    STR     r0, [r1, #0]                            // Store new system clock
  402c68:	6008      	str	r0, [r1, #0]

    /* Test for time-slice expiration.  */
    // if (_tx_timer_time_slice)
    // {

    LDR     r3, =_tx_timer_time_slice               // Pickup address of time-slice
  402c6a:	4b21      	ldr	r3, [pc, #132]	; (402cf0 <__tx_timer_nothing_expired+0xa>)
    LDR     r2, [r3, #0]                            // Pickup time-slice
  402c6c:	681a      	ldr	r2, [r3, #0]
    CBZ     r2, __tx_timer_no_time_slice            // Is it non-active?
  402c6e:	b13a      	cbz	r2, 402c80 <__tx_timer_no_time_slice>
                                                    // Yes, skip time-slice processing

       /* Decrement the time_slice.  */
       // _tx_timer_time_slice--;

    SUB     r2, r2, #1                              // Decrement the time-slice
  402c70:	f1a2 0201 	sub.w	r2, r2, #1
    STR     r2, [r3, #0]                            // Store new time-slice value
  402c74:	601a      	str	r2, [r3, #0]

       /* Check for expiration.  */
       // if (__tx_timer_time_slice == 0)

    CBNZ    r2, __tx_timer_no_time_slice            // Has it expired?
  402c76:	b91a      	cbnz	r2, 402c80 <__tx_timer_no_time_slice>
                                                    // No, skip expiration processing

       /* Set the time-slice expired flag.  */
       // _tx_timer_expired_time_slice =  TX_TRUE;

    LDR     r3, =_tx_timer_expired_time_slice       // Pickup address of expired flag
  402c78:	4b1e      	ldr	r3, [pc, #120]	; (402cf4 <__tx_timer_nothing_expired+0xe>)
    MOV     r0, #1                                  // Build expired value
  402c7a:	f04f 0001 	mov.w	r0, #1
    STR     r0, [r3, #0]                            // Set time-slice expiration flag
  402c7e:	6018      	str	r0, [r3, #0]

00402c80 <__tx_timer_no_time_slice>:

    /* Test for timer expiration.  */
    // if (*_tx_timer_current_ptr)
    // {

    LDR     r1, =_tx_timer_current_ptr              // Pickup current timer pointer address
  402c80:	491d      	ldr	r1, [pc, #116]	; (402cf8 <__tx_timer_nothing_expired+0x12>)
    LDR     r0, [r1, #0]                            // Pickup current timer
  402c82:	6808      	ldr	r0, [r1, #0]
    LDR     r2, [r0, #0]                            // Pickup timer list entry
  402c84:	6802      	ldr	r2, [r0, #0]
    CBZ     r2, __tx_timer_no_timer                 // Is there anything in the list?
  402c86:	b122      	cbz	r2, 402c92 <__tx_timer_no_timer>
                                                    // No, just increment the timer

        /* Set expiration flag.  */
        // _tx_timer_expired =  TX_TRUE;

    LDR     r3, =_tx_timer_expired                  // Pickup expiration flag address
  402c88:	4b1c      	ldr	r3, [pc, #112]	; (402cfc <__tx_timer_nothing_expired+0x16>)
    MOV     r2, #1                                  // Build expired value
  402c8a:	f04f 0201 	mov.w	r2, #1
    STR     r2, [r3, #0]                            // Set expired flag
  402c8e:	601a      	str	r2, [r3, #0]
    B       __tx_timer_done                         // Finished timer processing
  402c90:	e008      	b.n	402ca4 <__tx_timer_done>

00402c92 <__tx_timer_no_timer>:
__tx_timer_no_timer:

        /* No timer expired, increment the timer pointer.  */
        // _tx_timer_current_ptr++;

    ADD     r0, r0, #4                              // Move to next timer
  402c92:	f100 0004 	add.w	r0, r0, #4

        /* Check for wrap-around.  */
        // if (_tx_timer_current_ptr == _tx_timer_list_end)

    LDR     r3, =_tx_timer_list_end                 // Pickup addr of timer list end
  402c96:	4b1a      	ldr	r3, [pc, #104]	; (402d00 <__tx_timer_nothing_expired+0x1a>)
    LDR     r2, [r3, #0]                            // Pickup list end
  402c98:	681a      	ldr	r2, [r3, #0]
    CMP     r0, r2                                  // Are we at list end?
  402c9a:	4290      	cmp	r0, r2
    BNE     __tx_timer_skip_wrap                    // No, skip wrap-around logic
  402c9c:	d101      	bne.n	402ca2 <__tx_timer_skip_wrap>

            /* Wrap to beginning of list.  */
            // _tx_timer_current_ptr =  _tx_timer_list_start;

    LDR     r3, =_tx_timer_list_start               // Pickup addr of timer list start
  402c9e:	4b19      	ldr	r3, [pc, #100]	; (402d04 <__tx_timer_nothing_expired+0x1e>)
    LDR     r0, [r3, #0]                            // Set current pointer to list start
  402ca0:	6818      	ldr	r0, [r3, #0]

00402ca2 <__tx_timer_skip_wrap>:

__tx_timer_skip_wrap:

    STR     r0, [r1, #0]                            // Store new current timer pointer
  402ca2:	6008      	str	r0, [r1, #0]

00402ca4 <__tx_timer_done>:

    /* See if anything has expired.  */
    // if ((_tx_timer_expired_time_slice) || (_tx_timer_expired))
    // {

    LDR     r3, =_tx_timer_expired_time_slice       // Pickup addr of expired flag
  402ca4:	4b13      	ldr	r3, [pc, #76]	; (402cf4 <__tx_timer_nothing_expired+0xe>)
    LDR     r2, [r3, #0]                            // Pickup time-slice expired flag
  402ca6:	681a      	ldr	r2, [r3, #0]
    CBNZ    r2, __tx_something_expired              // Did a time-slice expire?
  402ca8:	b912      	cbnz	r2, 402cb0 <__tx_something_expired>
                                                    // If non-zero, time-slice expired
    LDR     r1, =_tx_timer_expired                  // Pickup addr of other expired flag
  402caa:	4914      	ldr	r1, [pc, #80]	; (402cfc <__tx_timer_nothing_expired+0x16>)
    LDR     r0, [r1, #0]                            // Pickup timer expired flag
  402cac:	6808      	ldr	r0, [r1, #0]
    CBZ     r0, __tx_timer_nothing_expired          // Did a timer expire?
  402cae:	b1d0      	cbz	r0, 402ce6 <__tx_timer_nothing_expired>

00402cb0 <__tx_something_expired>:
                                                    // No, nothing expired

__tx_something_expired:

    STMDB   sp!, {r0, lr}                           // Save the lr register on the stack
  402cb0:	e92d 4001 	stmdb	sp!, {r0, lr}

    /* Did a timer expire?  */
    // if (_tx_timer_expired)
    // {

    LDR     r1, =_tx_timer_expired                  // Pickup addr of expired flag
  402cb4:	4911      	ldr	r1, [pc, #68]	; (402cfc <__tx_timer_nothing_expired+0x16>)
    LDR     r0, [r1, #0]                            // Pickup timer expired flag
  402cb6:	6808      	ldr	r0, [r1, #0]
    CBZ     r0, __tx_timer_dont_activate            // Check for timer expiration
  402cb8:	b108      	cbz	r0, 402cbe <__tx_timer_dont_activate>
                                                    // If not set, skip timer activation

        /* Process timer expiration.  */
        // _tx_timer_expiration_process();

    BL      _tx_timer_expiration_process            // Call the timer expiration handling routine
  402cba:	f7ff fdb7 	bl	40282c <_tx_timer_expiration_process>

00402cbe <__tx_timer_dont_activate>:

    /* Did time slice expire?  */
    // if (_tx_timer_expired_time_slice)
    // {

    LDR     r3, =_tx_timer_expired_time_slice       // Pickup addr of time-slice expired
  402cbe:	4b0d      	ldr	r3, [pc, #52]	; (402cf4 <__tx_timer_nothing_expired+0xe>)
    LDR     r2, [r3, #0]                            // Pickup the actual flag
  402cc0:	681a      	ldr	r2, [r3, #0]
    CBZ     r2, __tx_timer_not_ts_expiration        // See if the flag is set
  402cc2:	b172      	cbz	r2, 402ce2 <__tx_timer_not_ts_expiration>
                                                    // No, skip time-slice processing

        /* Time slice interrupted thread.  */
        // _tx_thread_time_slice();

    BL      _tx_thread_time_slice                   // Call time-slice processing
  402cc4:	f7ff fd82 	bl	4027cc <_tx_thread_time_slice>
    LDR     r0, =_tx_thread_preempt_disable         // Build address of preempt disable flag
  402cc8:	480f      	ldr	r0, [pc, #60]	; (402d08 <__tx_timer_nothing_expired+0x22>)
    LDR     r1, [r0]                                // Is the preempt disable flag set?
  402cca:	6801      	ldr	r1, [r0, #0]
    CBNZ    r1, __tx_timer_skip_time_slice          // Yes, skip the PendSV logic
  402ccc:	b949      	cbnz	r1, 402ce2 <__tx_timer_not_ts_expiration>
    LDR     r0, =_tx_thread_current_ptr             // Build current thread pointer address
  402cce:	480f      	ldr	r0, [pc, #60]	; (402d0c <__tx_timer_nothing_expired+0x26>)
    LDR     r1, [r0]                                // Pickup the current thread pointer
  402cd0:	6801      	ldr	r1, [r0, #0]
    LDR     r2, =_tx_thread_execute_ptr             // Build execute thread pointer address
  402cd2:	4a0f      	ldr	r2, [pc, #60]	; (402d10 <__tx_timer_nothing_expired+0x2a>)
    LDR     r3, [r2]                                // Pickup the execute thread pointer
  402cd4:	6813      	ldr	r3, [r2, #0]
    LDR     r0, =0xE000ED04                         // Build address of control register
  402cd6:	480f      	ldr	r0, [pc, #60]	; (402d14 <__tx_timer_nothing_expired+0x2e>)
    LDR     r2, =0x10000000                         // Build value for PendSV bit
  402cd8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    CMP     r1, r3                                  // Are they the same?
  402cdc:	4299      	cmp	r1, r3
    BEQ     __tx_timer_skip_time_slice              // If the same, there was no time-slice performed
  402cde:	d000      	beq.n	402ce2 <__tx_timer_not_ts_expiration>
    STR     r2, [r0]                                // Not the same, issue the PendSV for preemption
  402ce0:	6002      	str	r2, [r0, #0]

00402ce2 <__tx_timer_not_ts_expiration>:

    // }

__tx_timer_not_ts_expiration:

    LDMIA   sp!, {r0, lr}                           // Recover lr register (r0 is just there for
  402ce2:	e8bd 4001 	ldmia.w	sp!, {r0, lr}

00402ce6 <__tx_timer_nothing_expired>:

    // }

__tx_timer_nothing_expired:

    DSB                                             // Complete all memory access
  402ce6:	f3bf 8f4f 	dsb	sy
    BX      lr                                      // Return to caller
  402cea:	4770      	bx	lr
    LDR     r1, =_tx_timer_system_clock             // Pickup address of system clock
  402cec:	20400b04 	.word	0x20400b04
    LDR     r3, =_tx_timer_time_slice               // Pickup address of time-slice
  402cf0:	20400628 	.word	0x20400628
    LDR     r3, =_tx_timer_expired_time_slice       // Pickup address of expired flag
  402cf4:	20400b00 	.word	0x20400b00
    LDR     r1, =_tx_timer_current_ptr              // Pickup current timer pointer address
  402cf8:	204005a0 	.word	0x204005a0
    LDR     r3, =_tx_timer_expired                  // Pickup expiration flag address
  402cfc:	20400624 	.word	0x20400624
    LDR     r3, =_tx_timer_list_end                 // Pickup addr of timer list end
  402d00:	20400630 	.word	0x20400630
    LDR     r3, =_tx_timer_list_start               // Pickup addr of timer list start
  402d04:	204006ec 	.word	0x204006ec
    LDR     r0, =_tx_thread_preempt_disable         // Build address of preempt disable flag
  402d08:	2040058c 	.word	0x2040058c
    LDR     r0, =_tx_thread_current_ptr             // Build current thread pointer address
  402d0c:	20400590 	.word	0x20400590
    LDR     r2, =_tx_thread_execute_ptr             // Build execute thread pointer address
  402d10:	20400594 	.word	0x20400594
    LDR     r0, =0xE000ED04                         // Build address of control register
  402d14:	e000ed04 	.word	0xe000ed04

00402d18 <pio_get_interrupt_status>:
 *
 * \return The interrupt status value.
 */
uint32_t pio_get_interrupt_status(const Pio *p_pio)
{
	return p_pio->PIO_ISR;
  402d18:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
}
  402d1a:	4770      	bx	lr

00402d1c <pio_get_interrupt_mask>:
 *
 * \return The interrupt mask value.
 */
uint32_t pio_get_interrupt_mask(const Pio *p_pio)
{
	return p_pio->PIO_IMR;
  402d1c:	6c80      	ldr	r0, [r0, #72]	; 0x48
}
  402d1e:	4770      	bx	lr

00402d20 <pio_handler_process>:
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
{
  402d20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  402d24:	4604      	mov	r4, r0
  402d26:	4688      	mov	r8, r1
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
  402d28:	4b0e      	ldr	r3, [pc, #56]	; (402d64 <pio_handler_process+0x44>)
  402d2a:	4798      	blx	r3
  402d2c:	4605      	mov	r5, r0
	status &= pio_get_interrupt_mask(p_pio);
  402d2e:	4620      	mov	r0, r4
  402d30:	4b0d      	ldr	r3, [pc, #52]	; (402d68 <pio_handler_process+0x48>)
  402d32:	4798      	blx	r3

	/* Check pending events */
	if (status != 0) {
  402d34:	4005      	ands	r5, r0
  402d36:	d013      	beq.n	402d60 <pio_handler_process+0x40>
  402d38:	4c0c      	ldr	r4, [pc, #48]	; (402d6c <pio_handler_process+0x4c>)
  402d3a:	f104 0660 	add.w	r6, r4, #96	; 0x60
  402d3e:	e003      	b.n	402d48 <pio_handler_process+0x28>
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
				}
			}
			i++;
			if (i >= MAX_INTERRUPT_SOURCES) {
  402d40:	42b4      	cmp	r4, r6
  402d42:	d00d      	beq.n	402d60 <pio_handler_process+0x40>
  402d44:	3410      	adds	r4, #16
		while (status != 0) {
  402d46:	b15d      	cbz	r5, 402d60 <pio_handler_process+0x40>
			if (gs_interrupt_sources[i].id == ul_id) {
  402d48:	6820      	ldr	r0, [r4, #0]
  402d4a:	4540      	cmp	r0, r8
  402d4c:	d1f8      	bne.n	402d40 <pio_handler_process+0x20>
				if ((status & gs_interrupt_sources[i].mask) != 0) {
  402d4e:	6861      	ldr	r1, [r4, #4]
  402d50:	4229      	tst	r1, r5
  402d52:	d0f5      	beq.n	402d40 <pio_handler_process+0x20>
					gs_interrupt_sources[i].handler(gs_interrupt_sources[i].id,
  402d54:	68e3      	ldr	r3, [r4, #12]
  402d56:	4798      	blx	r3
					status &= ~(gs_interrupt_sources[i].mask);
  402d58:	6863      	ldr	r3, [r4, #4]
  402d5a:	ea25 0503 	bic.w	r5, r5, r3
  402d5e:	e7ef      	b.n	402d40 <pio_handler_process+0x20>
  402d60:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  402d64:	00402d19 	.word	0x00402d19
  402d68:	00402d1d 	.word	0x00402d1d
  402d6c:	20400450 	.word	0x20400450

00402d70 <PIOA_Handler>:
/**
 * \brief Parallel IO Controller A interrupt handler.
 * Redefined PIOA interrupt handler for NVIC interrupt table.
 */
void PIOA_Handler(void)
{
  402d70:	b508      	push	{r3, lr}
	pio_handler_process(PIOA, ID_PIOA);
  402d72:	210a      	movs	r1, #10
  402d74:	4801      	ldr	r0, [pc, #4]	; (402d7c <PIOA_Handler+0xc>)
  402d76:	4b02      	ldr	r3, [pc, #8]	; (402d80 <PIOA_Handler+0x10>)
  402d78:	4798      	blx	r3
  402d7a:	bd08      	pop	{r3, pc}
  402d7c:	400e0e00 	.word	0x400e0e00
  402d80:	00402d21 	.word	0x00402d21

00402d84 <PIOB_Handler>:
/**
 * \brief Parallel IO Controller B interrupt handler
 * Redefined PIOB interrupt handler for NVIC interrupt table.
 */
void PIOB_Handler(void)
{
  402d84:	b508      	push	{r3, lr}
    pio_handler_process(PIOB, ID_PIOB);
  402d86:	210b      	movs	r1, #11
  402d88:	4801      	ldr	r0, [pc, #4]	; (402d90 <PIOB_Handler+0xc>)
  402d8a:	4b02      	ldr	r3, [pc, #8]	; (402d94 <PIOB_Handler+0x10>)
  402d8c:	4798      	blx	r3
  402d8e:	bd08      	pop	{r3, pc}
  402d90:	400e1000 	.word	0x400e1000
  402d94:	00402d21 	.word	0x00402d21

00402d98 <PIOC_Handler>:
/**
 * \brief Parallel IO Controller C interrupt handler.
 * Redefined PIOC interrupt handler for NVIC interrupt table.
 */
void PIOC_Handler(void)
{
  402d98:	b508      	push	{r3, lr}
	pio_handler_process(PIOC, ID_PIOC);
  402d9a:	210c      	movs	r1, #12
  402d9c:	4801      	ldr	r0, [pc, #4]	; (402da4 <PIOC_Handler+0xc>)
  402d9e:	4b02      	ldr	r3, [pc, #8]	; (402da8 <PIOC_Handler+0x10>)
  402da0:	4798      	blx	r3
  402da2:	bd08      	pop	{r3, pc}
  402da4:	400e1200 	.word	0x400e1200
  402da8:	00402d21 	.word	0x00402d21

00402dac <PIOD_Handler>:
/**
 * \brief Parallel IO Controller D interrupt handler.
 * Redefined PIOD interrupt handler for NVIC interrupt table.
 */
void PIOD_Handler(void)
{
  402dac:	b508      	push	{r3, lr}
	pio_handler_process(PIOD, ID_PIOD);
  402dae:	2110      	movs	r1, #16
  402db0:	4801      	ldr	r0, [pc, #4]	; (402db8 <PIOD_Handler+0xc>)
  402db2:	4b02      	ldr	r3, [pc, #8]	; (402dbc <PIOD_Handler+0x10>)
  402db4:	4798      	blx	r3
  402db6:	bd08      	pop	{r3, pc}
  402db8:	400e1400 	.word	0x400e1400
  402dbc:	00402d21 	.word	0x00402d21

00402dc0 <PIOE_Handler>:
/**
 * \brief Parallel IO Controller E interrupt handler.
 * Redefined PIOE interrupt handler for NVIC interrupt table.
 */
void PIOE_Handler(void)
{
  402dc0:	b508      	push	{r3, lr}
	pio_handler_process(PIOE, ID_PIOE);
  402dc2:	2111      	movs	r1, #17
  402dc4:	4801      	ldr	r0, [pc, #4]	; (402dcc <PIOE_Handler+0xc>)
  402dc6:	4b02      	ldr	r3, [pc, #8]	; (402dd0 <PIOE_Handler+0x10>)
  402dc8:	4798      	blx	r3
  402dca:	bd08      	pop	{r3, pc}
  402dcc:	400e1600 	.word	0x400e1600
  402dd0:	00402d21 	.word	0x00402d21

00402dd4 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
  402dd4:	e7fe      	b.n	402dd4 <Dummy_Handler>
	...

00402dd8 <Reset_Handler>:
{
  402dd8:	b500      	push	{lr}
  402dda:	b083      	sub	sp, #12
        if (pSrc != pDest) {
  402ddc:	4b25      	ldr	r3, [pc, #148]	; (402e74 <Reset_Handler+0x9c>)
  402dde:	4a26      	ldr	r2, [pc, #152]	; (402e78 <Reset_Handler+0xa0>)
  402de0:	429a      	cmp	r2, r3
  402de2:	d010      	beq.n	402e06 <Reset_Handler+0x2e>
                for (; pDest < &_erelocate;) {
  402de4:	4b25      	ldr	r3, [pc, #148]	; (402e7c <Reset_Handler+0xa4>)
  402de6:	4a23      	ldr	r2, [pc, #140]	; (402e74 <Reset_Handler+0x9c>)
  402de8:	429a      	cmp	r2, r3
  402dea:	d20c      	bcs.n	402e06 <Reset_Handler+0x2e>
  402dec:	3b01      	subs	r3, #1
  402dee:	1a9b      	subs	r3, r3, r2
  402df0:	f023 0303 	bic.w	r3, r3, #3
  402df4:	3304      	adds	r3, #4
  402df6:	4413      	add	r3, r2
  402df8:	491f      	ldr	r1, [pc, #124]	; (402e78 <Reset_Handler+0xa0>)
                        *pDest++ = *pSrc++;
  402dfa:	f851 0b04 	ldr.w	r0, [r1], #4
  402dfe:	f842 0b04 	str.w	r0, [r2], #4
                for (; pDest < &_erelocate;) {
  402e02:	429a      	cmp	r2, r3
  402e04:	d1f9      	bne.n	402dfa <Reset_Handler+0x22>
        for (pDest = &_szero; pDest < &_ezero;) {
  402e06:	4b1e      	ldr	r3, [pc, #120]	; (402e80 <Reset_Handler+0xa8>)
  402e08:	4a1e      	ldr	r2, [pc, #120]	; (402e84 <Reset_Handler+0xac>)
  402e0a:	429a      	cmp	r2, r3
  402e0c:	d20a      	bcs.n	402e24 <Reset_Handler+0x4c>
  402e0e:	3b01      	subs	r3, #1
  402e10:	1a9b      	subs	r3, r3, r2
  402e12:	f023 0303 	bic.w	r3, r3, #3
  402e16:	3304      	adds	r3, #4
  402e18:	4413      	add	r3, r2
                *pDest++ = 0;
  402e1a:	2100      	movs	r1, #0
  402e1c:	f842 1b04 	str.w	r1, [r2], #4
        for (pDest = &_szero; pDest < &_ezero;) {
  402e20:	4293      	cmp	r3, r2
  402e22:	d1fb      	bne.n	402e1c <Reset_Handler+0x44>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
  402e24:	4a18      	ldr	r2, [pc, #96]	; (402e88 <Reset_Handler+0xb0>)
  402e26:	4b19      	ldr	r3, [pc, #100]	; (402e8c <Reset_Handler+0xb4>)
  402e28:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  402e2c:	6093      	str	r3, [r2, #8]
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
  402e2e:	f3ef 8310 	mrs	r3, PRIMASK
static volatile uint32_t cpu_irq_critical_section_counter;
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = cpu_irq_is_enabled();
  402e32:	fab3 f383 	clz	r3, r3
  402e36:	095b      	lsrs	r3, r3, #5
  402e38:	9301      	str	r3, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
  402e3a:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
  402e3c:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
  402e40:	2200      	movs	r2, #0
  402e42:	4b13      	ldr	r3, [pc, #76]	; (402e90 <Reset_Handler+0xb8>)
  402e44:	701a      	strb	r2, [r3, #0]
	return flags;
  402e46:	9901      	ldr	r1, [sp, #4]
 */
__always_inline static void fpu_enable(void)
{
	irqflags_t flags;
	flags = cpu_irq_save();
	REG_CPACR |=  (0xFu << 20);
  402e48:	4a12      	ldr	r2, [pc, #72]	; (402e94 <Reset_Handler+0xbc>)
  402e4a:	6813      	ldr	r3, [r2, #0]
  402e4c:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
  402e50:	6013      	str	r3, [r2, #0]
  __ASM volatile ("dsb 0xF":::"memory");
  402e52:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  402e56:	f3bf 8f6f 	isb	sy
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
  402e5a:	b129      	cbz	r1, 402e68 <Reset_Handler+0x90>
		cpu_irq_enable();
  402e5c:	2201      	movs	r2, #1
  402e5e:	4b0c      	ldr	r3, [pc, #48]	; (402e90 <Reset_Handler+0xb8>)
  402e60:	701a      	strb	r2, [r3, #0]
  __ASM volatile ("dmb 0xF":::"memory");
  402e62:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
  402e66:	b662      	cpsie	i
        __libc_init_array();
  402e68:	4b0b      	ldr	r3, [pc, #44]	; (402e98 <Reset_Handler+0xc0>)
  402e6a:	4798      	blx	r3
        main();
  402e6c:	4b0b      	ldr	r3, [pc, #44]	; (402e9c <Reset_Handler+0xc4>)
  402e6e:	4798      	blx	r3
  402e70:	e7fe      	b.n	402e70 <Reset_Handler+0x98>
  402e72:	bf00      	nop
  402e74:	20400000 	.word	0x20400000
  402e78:	00403600 	.word	0x00403600
  402e7c:	20400434 	.word	0x20400434
  402e80:	204035b0 	.word	0x204035b0
  402e84:	20400434 	.word	0x20400434
  402e88:	e000ed00 	.word	0xe000ed00
  402e8c:	00400000 	.word	0x00400000
  402e90:	20400004 	.word	0x20400004
  402e94:	e000ed88 	.word	0xe000ed88
  402e98:	00403311 	.word	0x00403311
  402e9c:	00403045 	.word	0x00403045

00402ea0 <thread_0_entry>:


/* Define the test threads.  */

void    thread_0_entry(ULONG thread_input)
{
  402ea0:	b570      	push	{r4, r5, r6, lr}
    /* This thread simply sits in while-forever-sleep loop.  */
    while(1)
    {

        /* Increment the thread counter.  */
        thread_0_counter++;
  402ea2:	4c08      	ldr	r4, [pc, #32]	; (402ec4 <thread_0_entry+0x24>)

        /* Sleep for 10 ticks.  */
        tx_thread_sleep(10);
  402ea4:	4e08      	ldr	r6, [pc, #32]	; (402ec8 <thread_0_entry+0x28>)

        /* Set event flag 0 to wakeup thread 5.  */
        status =  tx_event_flags_set(&event_flags_0, 0x1, TX_OR);
  402ea6:	4d09      	ldr	r5, [pc, #36]	; (402ecc <thread_0_entry+0x2c>)
        thread_0_counter++;
  402ea8:	6823      	ldr	r3, [r4, #0]
  402eaa:	3301      	adds	r3, #1
  402eac:	6023      	str	r3, [r4, #0]
        tx_thread_sleep(10);
  402eae:	200a      	movs	r0, #10
  402eb0:	47b0      	blx	r6
        status =  tx_event_flags_set(&event_flags_0, 0x1, TX_OR);
  402eb2:	2200      	movs	r2, #0
  402eb4:	2101      	movs	r1, #1
  402eb6:	4628      	mov	r0, r5
  402eb8:	4b05      	ldr	r3, [pc, #20]	; (402ed0 <thread_0_entry+0x30>)
  402eba:	4798      	blx	r3

        /* Check status.  */
        if (status != TX_SUCCESS)
  402ebc:	2800      	cmp	r0, #0
  402ebe:	d0f3      	beq.n	402ea8 <thread_0_entry+0x8>
            break;
    }
}
  402ec0:	bd70      	pop	{r4, r5, r6, pc}
  402ec2:	bf00      	nop
  402ec4:	20400c9c 	.word	0x20400c9c
  402ec8:	004023dd 	.word	0x004023dd
  402ecc:	20403480 	.word	0x20403480
  402ed0:	004005cd 	.word	0x004005cd

00402ed4 <thread_1_entry>:


void    thread_1_entry(ULONG thread_input)
{
  402ed4:	b570      	push	{r4, r5, r6, lr}
    /* This thread simply sends messages to a queue shared by thread 2.  */
    while(1)
    {

        /* Increment the thread counter.  */
        thread_1_counter++;
  402ed6:	4d09      	ldr	r5, [pc, #36]	; (402efc <thread_1_entry+0x28>)

        /* Send message to queue 0.  */
        status =  tx_queue_send(&queue_0, &thread_1_messages_sent, TX_WAIT_FOREVER);
  402ed8:	4c09      	ldr	r4, [pc, #36]	; (402f00 <thread_1_entry+0x2c>)
  402eda:	4e0a      	ldr	r6, [pc, #40]	; (402f04 <thread_1_entry+0x30>)
        thread_1_counter++;
  402edc:	682b      	ldr	r3, [r5, #0]
  402ede:	3301      	adds	r3, #1
  402ee0:	602b      	str	r3, [r5, #0]
        status =  tx_queue_send(&queue_0, &thread_1_messages_sent, TX_WAIT_FOREVER);
  402ee2:	f04f 32ff 	mov.w	r2, #4294967295
  402ee6:	4621      	mov	r1, r4
  402ee8:	4630      	mov	r0, r6
  402eea:	4b07      	ldr	r3, [pc, #28]	; (402f08 <thread_1_entry+0x34>)
  402eec:	4798      	blx	r3

        /* Check completion status.  */
        if (status != TX_SUCCESS)
  402eee:	b918      	cbnz	r0, 402ef8 <thread_1_entry+0x24>
            break;

        /* Increment the message sent.  */
        thread_1_messages_sent++;
  402ef0:	6823      	ldr	r3, [r4, #0]
  402ef2:	3301      	adds	r3, #1
  402ef4:	6023      	str	r3, [r4, #0]
        thread_1_counter++;
  402ef6:	e7f1      	b.n	402edc <thread_1_entry+0x8>
  402ef8:	bd70      	pop	{r4, r5, r6, pc}
  402efa:	bf00      	nop
  402efc:	20400ec4 	.word	0x20400ec4
  402f00:	20403474 	.word	0x20403474
  402f04:	20403438 	.word	0x20403438
  402f08:	004008c5 	.word	0x004008c5

00402f0c <thread_2_entry>:
    }
}


void    thread_2_entry(ULONG thread_input)
{
  402f0c:	b570      	push	{r4, r5, r6, lr}
  402f0e:	b082      	sub	sp, #8
    /* This thread retrieves messages placed on the queue by thread 1.  */
    while(1)
    {

        /* Increment the thread counter.  */
        thread_2_counter++;
  402f10:	4c0b      	ldr	r4, [pc, #44]	; (402f40 <thread_2_entry+0x34>)

        /* Retrieve a message from the queue.  */
        status = tx_queue_receive(&queue_0, &received_message, TX_WAIT_FOREVER);
  402f12:	4e0c      	ldr	r6, [pc, #48]	; (402f44 <thread_2_entry+0x38>)
  402f14:	4d0c      	ldr	r5, [pc, #48]	; (402f48 <thread_2_entry+0x3c>)
        thread_2_counter++;
  402f16:	6823      	ldr	r3, [r4, #0]
  402f18:	3301      	adds	r3, #1
  402f1a:	6023      	str	r3, [r4, #0]
        status = tx_queue_receive(&queue_0, &received_message, TX_WAIT_FOREVER);
  402f1c:	f04f 32ff 	mov.w	r2, #4294967295
  402f20:	a901      	add	r1, sp, #4
  402f22:	4630      	mov	r0, r6
  402f24:	47a8      	blx	r5

        /* Check completion status and make sure the message is what we 
           expected.  */
        if ((status != TX_SUCCESS) || (received_message != thread_2_messages_received))
  402f26:	b940      	cbnz	r0, 402f3a <thread_2_entry+0x2e>
  402f28:	9b01      	ldr	r3, [sp, #4]
  402f2a:	4a08      	ldr	r2, [pc, #32]	; (402f4c <thread_2_entry+0x40>)
  402f2c:	6812      	ldr	r2, [r2, #0]
  402f2e:	4293      	cmp	r3, r2
  402f30:	d103      	bne.n	402f3a <thread_2_entry+0x2e>
            break;
        
        /* Otherwise, all is okay.  Increment the received message count.  */
        thread_2_messages_received++;
  402f32:	3301      	adds	r3, #1
  402f34:	4a05      	ldr	r2, [pc, #20]	; (402f4c <thread_2_entry+0x40>)
  402f36:	6013      	str	r3, [r2, #0]
        thread_2_counter++;
  402f38:	e7ed      	b.n	402f16 <thread_2_entry+0xa>
    }
}
  402f3a:	b002      	add	sp, #8
  402f3c:	bd70      	pop	{r4, r5, r6, pc}
  402f3e:	bf00      	nop
  402f40:	20400ca0 	.word	0x20400ca0
  402f44:	20403438 	.word	0x20403438
  402f48:	0040086d 	.word	0x0040086d
  402f4c:	20403478 	.word	0x20403478

00402f50 <thread_3_and_4_entry>:


void    thread_3_and_4_entry(ULONG thread_input)
{
  402f50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  402f52:	4606      	mov	r6, r0

        /* Increment the thread counter.  */
        if (thread_input == 3)
            thread_3_counter++;
        else
            thread_4_counter++;
  402f54:	4d0d      	ldr	r5, [pc, #52]	; (402f8c <thread_3_and_4_entry+0x3c>)
            thread_3_counter++;
  402f56:	4f0e      	ldr	r7, [pc, #56]	; (402f90 <thread_3_and_4_entry+0x40>)

        /* Get the semaphore with suspension.  */
        status =  tx_semaphore_get(&semaphore_0, TX_WAIT_FOREVER);
  402f58:	4c0e      	ldr	r4, [pc, #56]	; (402f94 <thread_3_and_4_entry+0x44>)
  402f5a:	e00f      	b.n	402f7c <thread_3_and_4_entry+0x2c>
            thread_3_counter++;
  402f5c:	683b      	ldr	r3, [r7, #0]
  402f5e:	3301      	adds	r3, #1
  402f60:	603b      	str	r3, [r7, #0]
        status =  tx_semaphore_get(&semaphore_0, TX_WAIT_FOREVER);
  402f62:	f04f 31ff 	mov.w	r1, #4294967295
  402f66:	4620      	mov	r0, r4
  402f68:	4b0b      	ldr	r3, [pc, #44]	; (402f98 <thread_3_and_4_entry+0x48>)
  402f6a:	4798      	blx	r3

        /* Check status.  */
        if (status != TX_SUCCESS)
  402f6c:	b960      	cbnz	r0, 402f88 <thread_3_and_4_entry+0x38>
            break;

        /* Sleep for 2 ticks to hold the semaphore.  */
        tx_thread_sleep(2);
  402f6e:	2002      	movs	r0, #2
  402f70:	4b0a      	ldr	r3, [pc, #40]	; (402f9c <thread_3_and_4_entry+0x4c>)
  402f72:	4798      	blx	r3

        /* Release the semaphore.  */
        status =  tx_semaphore_put(&semaphore_0);
  402f74:	4620      	mov	r0, r4
  402f76:	4b0a      	ldr	r3, [pc, #40]	; (402fa0 <thread_3_and_4_entry+0x50>)
  402f78:	4798      	blx	r3

        /* Check status.  */
        if (status != TX_SUCCESS)
  402f7a:	b928      	cbnz	r0, 402f88 <thread_3_and_4_entry+0x38>
        if (thread_input == 3)
  402f7c:	2e03      	cmp	r6, #3
  402f7e:	d0ed      	beq.n	402f5c <thread_3_and_4_entry+0xc>
            thread_4_counter++;
  402f80:	682b      	ldr	r3, [r5, #0]
  402f82:	3301      	adds	r3, #1
  402f84:	602b      	str	r3, [r5, #0]
  402f86:	e7ec      	b.n	402f62 <thread_3_and_4_entry+0x12>
  402f88:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  402f8a:	bf00      	nop
  402f8c:	20400d58 	.word	0x20400d58
  402f90:	20400bbc 	.word	0x20400bbc
  402f94:	20400bc4 	.word	0x20400bc4
  402f98:	004009d5 	.word	0x004009d5
  402f9c:	004023dd 	.word	0x004023dd
  402fa0:	00400a29 	.word	0x00400a29

00402fa4 <thread_5_entry>:
    }
}


void    thread_5_entry(ULONG thread_input)
{
  402fa4:	b570      	push	{r4, r5, r6, lr}
  402fa6:	b084      	sub	sp, #16
    /* This thread simply waits for an event in a forever loop.  */
    while(1)
    {

        /* Increment the thread counter.  */
        thread_5_counter++;
  402fa8:	4c09      	ldr	r4, [pc, #36]	; (402fd0 <thread_5_entry+0x2c>)

        /* Wait for event flag 0.  */
        status =  tx_event_flags_get(&event_flags_0, 0x1, TX_OR_CLEAR, 
  402faa:	4e0a      	ldr	r6, [pc, #40]	; (402fd4 <thread_5_entry+0x30>)
  402fac:	4d0a      	ldr	r5, [pc, #40]	; (402fd8 <thread_5_entry+0x34>)
        thread_5_counter++;
  402fae:	6823      	ldr	r3, [r4, #0]
  402fb0:	3301      	adds	r3, #1
  402fb2:	6023      	str	r3, [r4, #0]
        status =  tx_event_flags_get(&event_flags_0, 0x1, TX_OR_CLEAR, 
  402fb4:	f04f 33ff 	mov.w	r3, #4294967295
  402fb8:	9300      	str	r3, [sp, #0]
  402fba:	ab03      	add	r3, sp, #12
  402fbc:	2201      	movs	r2, #1
  402fbe:	4611      	mov	r1, r2
  402fc0:	4630      	mov	r0, r6
  402fc2:	47a8      	blx	r5
                                                &actual_flags, TX_WAIT_FOREVER);

        /* Check status.  */
        if ((status != TX_SUCCESS) || (actual_flags != 0x1))
  402fc4:	b910      	cbnz	r0, 402fcc <thread_5_entry+0x28>
  402fc6:	9b03      	ldr	r3, [sp, #12]
  402fc8:	2b01      	cmp	r3, #1
  402fca:	d0f0      	beq.n	402fae <thread_5_entry+0xa>
            break;
    }
}
  402fcc:	b004      	add	sp, #16
  402fce:	bd70      	pop	{r4, r5, r6, pc}
  402fd0:	20400bc0 	.word	0x20400bc0
  402fd4:	20403480 	.word	0x20403480
  402fd8:	00400561 	.word	0x00400561

00402fdc <thread_6_and_7_entry>:


void    thread_6_and_7_entry(ULONG thread_input)
{
  402fdc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  402fde:	4606      	mov	r6, r0

        /* Increment the thread counter.  */
        if (thread_input == 6)
            thread_6_counter++;
        else
            thread_7_counter++;
  402fe0:	4d12      	ldr	r5, [pc, #72]	; (40302c <thread_6_and_7_entry+0x50>)
            thread_6_counter++;
  402fe2:	4f13      	ldr	r7, [pc, #76]	; (403030 <thread_6_and_7_entry+0x54>)

        /* Get the mutex with suspension.  */
        status =  tx_mutex_get(&mutex_0, TX_WAIT_FOREVER);
  402fe4:	4c13      	ldr	r4, [pc, #76]	; (403034 <thread_6_and_7_entry+0x58>)
  402fe6:	e019      	b.n	40301c <thread_6_and_7_entry+0x40>
            thread_6_counter++;
  402fe8:	683b      	ldr	r3, [r7, #0]
  402fea:	3301      	adds	r3, #1
  402fec:	603b      	str	r3, [r7, #0]
        status =  tx_mutex_get(&mutex_0, TX_WAIT_FOREVER);
  402fee:	f04f 31ff 	mov.w	r1, #4294967295
  402ff2:	4620      	mov	r0, r4
  402ff4:	4b10      	ldr	r3, [pc, #64]	; (403038 <thread_6_and_7_entry+0x5c>)
  402ff6:	4798      	blx	r3

        /* Check status.  */
        if (status != TX_SUCCESS)
  402ff8:	b9b0      	cbnz	r0, 403028 <thread_6_and_7_entry+0x4c>
            break;

        /* Get the mutex again with suspension.  This shows
           that an owning thread may retrieve the mutex it
           owns multiple times.  */
        status =  tx_mutex_get(&mutex_0, TX_WAIT_FOREVER);
  402ffa:	f04f 31ff 	mov.w	r1, #4294967295
  402ffe:	4620      	mov	r0, r4
  403000:	4b0d      	ldr	r3, [pc, #52]	; (403038 <thread_6_and_7_entry+0x5c>)
  403002:	4798      	blx	r3

        /* Check status.  */
        if (status != TX_SUCCESS)
  403004:	b980      	cbnz	r0, 403028 <thread_6_and_7_entry+0x4c>
            break;

        /* Sleep for 2 ticks to hold the mutex.  */
        tx_thread_sleep(2);
  403006:	2002      	movs	r0, #2
  403008:	4b0c      	ldr	r3, [pc, #48]	; (40303c <thread_6_and_7_entry+0x60>)
  40300a:	4798      	blx	r3

        /* Release the mutex.  */
        status =  tx_mutex_put(&mutex_0);
  40300c:	4620      	mov	r0, r4
  40300e:	4b0c      	ldr	r3, [pc, #48]	; (403040 <thread_6_and_7_entry+0x64>)
  403010:	4798      	blx	r3

        /* Check status.  */
        if (status != TX_SUCCESS)
  403012:	b948      	cbnz	r0, 403028 <thread_6_and_7_entry+0x4c>
            break;

        /* Release the mutex again.  This will actually 
           release ownership since it was obtained twice.  */
        status =  tx_mutex_put(&mutex_0);
  403014:	4620      	mov	r0, r4
  403016:	4b0a      	ldr	r3, [pc, #40]	; (403040 <thread_6_and_7_entry+0x64>)
  403018:	4798      	blx	r3

        /* Check status.  */
        if (status != TX_SUCCESS)
  40301a:	b928      	cbnz	r0, 403028 <thread_6_and_7_entry+0x4c>
        if (thread_input == 6)
  40301c:	2e06      	cmp	r6, #6
  40301e:	d0e3      	beq.n	402fe8 <thread_6_and_7_entry+0xc>
            thread_7_counter++;
  403020:	682b      	ldr	r3, [r5, #0]
  403022:	3301      	adds	r3, #1
  403024:	602b      	str	r3, [r5, #0]
  403026:	e7e2      	b.n	402fee <thread_6_and_7_entry+0x12>
  403028:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40302a:	bf00      	nop
  40302c:	20400c98 	.word	0x20400c98
  403030:	2040347c 	.word	0x2040347c
  403034:	20400efc 	.word	0x20400efc
  403038:	004006c1 	.word	0x004006c1
  40303c:	004023dd 	.word	0x004023dd
  403040:	00400735 	.word	0x00400735

00403044 <main>:
{
  403044:	b508      	push	{r3, lr}
    tx_kernel_enter();
  403046:	4b02      	ldr	r3, [pc, #8]	; (403050 <main+0xc>)
  403048:	4798      	blx	r3
}
  40304a:	2000      	movs	r0, #0
  40304c:	bd08      	pop	{r3, pc}
  40304e:	bf00      	nop
  403050:	00401529 	.word	0x00401529

00403054 <tx_application_define>:
{
  403054:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  403058:	b08d      	sub	sp, #52	; 0x34
CHAR    *pointer = TX_NULL;
  40305a:	2400      	movs	r4, #0
  40305c:	ab0c      	add	r3, sp, #48	; 0x30
  40305e:	f843 4d04 	str.w	r4, [r3, #-4]!
  403062:	461e      	mov	r6, r3
    tx_byte_pool_create(&byte_pool_0, "byte pool 0", memory_area, DEMO_BYTE_POOL_SIZE);
  403064:	2334      	movs	r3, #52	; 0x34
  403066:	9300      	str	r3, [sp, #0]
  403068:	f242 33a0 	movw	r3, #9120	; 0x23a0
  40306c:	4a7b      	ldr	r2, [pc, #492]	; (40325c <tx_application_define+0x208>)
  40306e:	497c      	ldr	r1, [pc, #496]	; (403260 <tx_application_define+0x20c>)
  403070:	487c      	ldr	r0, [pc, #496]	; (403264 <tx_application_define+0x210>)
  403072:	4d7d      	ldr	r5, [pc, #500]	; (403268 <tx_application_define+0x214>)
  403074:	47a8      	blx	r5
    tx_byte_allocate(&byte_pool_0, (VOID **) &pointer, DEMO_STACK_SIZE, TX_NO_WAIT);
  403076:	4623      	mov	r3, r4
  403078:	f44f 6280 	mov.w	r2, #1024	; 0x400
  40307c:	4631      	mov	r1, r6
  40307e:	4879      	ldr	r0, [pc, #484]	; (403264 <tx_application_define+0x210>)
  403080:	f8df 8284 	ldr.w	r8, [pc, #644]	; 403308 <tx_application_define+0x2b4>
  403084:	47c0      	blx	r8
    tx_thread_create(&thread_0, "thread 0", thread_0_entry, 0,  
  403086:	f04f 0bb4 	mov.w	fp, #180	; 0xb4
  40308a:	f8cd b018 	str.w	fp, [sp, #24]
  40308e:	2701      	movs	r7, #1
  403090:	9705      	str	r7, [sp, #20]
  403092:	9404      	str	r4, [sp, #16]
  403094:	9703      	str	r7, [sp, #12]
  403096:	9702      	str	r7, [sp, #8]
  403098:	f44f 6580 	mov.w	r5, #1024	; 0x400
  40309c:	9501      	str	r5, [sp, #4]
  40309e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  4030a0:	9300      	str	r3, [sp, #0]
  4030a2:	4623      	mov	r3, r4
  4030a4:	4a71      	ldr	r2, [pc, #452]	; (40326c <tx_application_define+0x218>)
  4030a6:	4972      	ldr	r1, [pc, #456]	; (403270 <tx_application_define+0x21c>)
  4030a8:	4872      	ldr	r0, [pc, #456]	; (403274 <tx_application_define+0x220>)
  4030aa:	f8df 9260 	ldr.w	r9, [pc, #608]	; 40330c <tx_application_define+0x2b8>
  4030ae:	47c8      	blx	r9
    tx_byte_allocate(&byte_pool_0, (VOID **) &pointer, DEMO_STACK_SIZE, TX_NO_WAIT);
  4030b0:	4623      	mov	r3, r4
  4030b2:	462a      	mov	r2, r5
  4030b4:	9609      	str	r6, [sp, #36]	; 0x24
  4030b6:	4631      	mov	r1, r6
  4030b8:	486a      	ldr	r0, [pc, #424]	; (403264 <tx_application_define+0x210>)
  4030ba:	47c0      	blx	r8
    tx_thread_create(&thread_1, "thread 1", thread_1_entry, 1,  
  4030bc:	f8cd b018 	str.w	fp, [sp, #24]
  4030c0:	9705      	str	r7, [sp, #20]
  4030c2:	2604      	movs	r6, #4
  4030c4:	9604      	str	r6, [sp, #16]
  4030c6:	f04f 0a10 	mov.w	sl, #16
  4030ca:	f8cd a00c 	str.w	sl, [sp, #12]
  4030ce:	f8cd a008 	str.w	sl, [sp, #8]
  4030d2:	9501      	str	r5, [sp, #4]
  4030d4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  4030d6:	9300      	str	r3, [sp, #0]
  4030d8:	463b      	mov	r3, r7
  4030da:	4a67      	ldr	r2, [pc, #412]	; (403278 <tx_application_define+0x224>)
  4030dc:	4967      	ldr	r1, [pc, #412]	; (40327c <tx_application_define+0x228>)
  4030de:	4868      	ldr	r0, [pc, #416]	; (403280 <tx_application_define+0x22c>)
  4030e0:	47c8      	blx	r9
    tx_byte_allocate(&byte_pool_0, (VOID **) &pointer, DEMO_STACK_SIZE, TX_NO_WAIT);
  4030e2:	4623      	mov	r3, r4
  4030e4:	462a      	mov	r2, r5
  4030e6:	9909      	ldr	r1, [sp, #36]	; 0x24
  4030e8:	485e      	ldr	r0, [pc, #376]	; (403264 <tx_application_define+0x210>)
  4030ea:	47c0      	blx	r8
    tx_thread_create(&thread_2, "thread 2", thread_2_entry, 2,  
  4030ec:	f8cd b018 	str.w	fp, [sp, #24]
  4030f0:	9705      	str	r7, [sp, #20]
  4030f2:	9604      	str	r6, [sp, #16]
  4030f4:	f8cd a00c 	str.w	sl, [sp, #12]
  4030f8:	f8cd a008 	str.w	sl, [sp, #8]
  4030fc:	9501      	str	r5, [sp, #4]
  4030fe:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  403100:	9300      	str	r3, [sp, #0]
  403102:	2302      	movs	r3, #2
  403104:	4a5f      	ldr	r2, [pc, #380]	; (403284 <tx_application_define+0x230>)
  403106:	4960      	ldr	r1, [pc, #384]	; (403288 <tx_application_define+0x234>)
  403108:	4860      	ldr	r0, [pc, #384]	; (40328c <tx_application_define+0x238>)
  40310a:	47c8      	blx	r9
    tx_byte_allocate(&byte_pool_0, (VOID **) &pointer, DEMO_STACK_SIZE, TX_NO_WAIT);
  40310c:	4623      	mov	r3, r4
  40310e:	462a      	mov	r2, r5
  403110:	9909      	ldr	r1, [sp, #36]	; 0x24
  403112:	4854      	ldr	r0, [pc, #336]	; (403264 <tx_application_define+0x210>)
  403114:	47c0      	blx	r8
    tx_thread_create(&thread_3, "thread 3", thread_3_and_4_entry, 3,  
  403116:	f8cd b018 	str.w	fp, [sp, #24]
  40311a:	9705      	str	r7, [sp, #20]
  40311c:	9404      	str	r4, [sp, #16]
  40311e:	f04f 0a08 	mov.w	sl, #8
  403122:	f8cd a00c 	str.w	sl, [sp, #12]
  403126:	f8cd a008 	str.w	sl, [sp, #8]
  40312a:	9501      	str	r5, [sp, #4]
  40312c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  40312e:	9300      	str	r3, [sp, #0]
  403130:	2303      	movs	r3, #3
  403132:	4a57      	ldr	r2, [pc, #348]	; (403290 <tx_application_define+0x23c>)
  403134:	4957      	ldr	r1, [pc, #348]	; (403294 <tx_application_define+0x240>)
  403136:	4858      	ldr	r0, [pc, #352]	; (403298 <tx_application_define+0x244>)
  403138:	47c8      	blx	r9
    tx_byte_allocate(&byte_pool_0, (VOID **) &pointer, DEMO_STACK_SIZE, TX_NO_WAIT);
  40313a:	4623      	mov	r3, r4
  40313c:	462a      	mov	r2, r5
  40313e:	9909      	ldr	r1, [sp, #36]	; 0x24
  403140:	4848      	ldr	r0, [pc, #288]	; (403264 <tx_application_define+0x210>)
  403142:	47c0      	blx	r8
    tx_thread_create(&thread_4, "thread 4", thread_3_and_4_entry, 4,  
  403144:	f8cd b018 	str.w	fp, [sp, #24]
  403148:	9705      	str	r7, [sp, #20]
  40314a:	9404      	str	r4, [sp, #16]
  40314c:	f8cd a00c 	str.w	sl, [sp, #12]
  403150:	f8cd a008 	str.w	sl, [sp, #8]
  403154:	9501      	str	r5, [sp, #4]
  403156:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  403158:	9300      	str	r3, [sp, #0]
  40315a:	4633      	mov	r3, r6
  40315c:	4a4c      	ldr	r2, [pc, #304]	; (403290 <tx_application_define+0x23c>)
  40315e:	494f      	ldr	r1, [pc, #316]	; (40329c <tx_application_define+0x248>)
  403160:	484f      	ldr	r0, [pc, #316]	; (4032a0 <tx_application_define+0x24c>)
  403162:	47c8      	blx	r9
    tx_byte_allocate(&byte_pool_0, (VOID **) &pointer, DEMO_STACK_SIZE, TX_NO_WAIT);
  403164:	4623      	mov	r3, r4
  403166:	462a      	mov	r2, r5
  403168:	9909      	ldr	r1, [sp, #36]	; 0x24
  40316a:	483e      	ldr	r0, [pc, #248]	; (403264 <tx_application_define+0x210>)
  40316c:	47c0      	blx	r8
    tx_thread_create(&thread_5, "thread 5", thread_5_entry, 5,  
  40316e:	f8cd b018 	str.w	fp, [sp, #24]
  403172:	9705      	str	r7, [sp, #20]
  403174:	9404      	str	r4, [sp, #16]
  403176:	9603      	str	r6, [sp, #12]
  403178:	9602      	str	r6, [sp, #8]
  40317a:	9501      	str	r5, [sp, #4]
  40317c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  40317e:	9300      	str	r3, [sp, #0]
  403180:	2305      	movs	r3, #5
  403182:	4a48      	ldr	r2, [pc, #288]	; (4032a4 <tx_application_define+0x250>)
  403184:	4948      	ldr	r1, [pc, #288]	; (4032a8 <tx_application_define+0x254>)
  403186:	4849      	ldr	r0, [pc, #292]	; (4032ac <tx_application_define+0x258>)
  403188:	47c8      	blx	r9
    tx_byte_allocate(&byte_pool_0, (VOID **) &pointer, DEMO_STACK_SIZE, TX_NO_WAIT);
  40318a:	4623      	mov	r3, r4
  40318c:	462a      	mov	r2, r5
  40318e:	9909      	ldr	r1, [sp, #36]	; 0x24
  403190:	4834      	ldr	r0, [pc, #208]	; (403264 <tx_application_define+0x210>)
  403192:	47c0      	blx	r8
    tx_thread_create(&thread_6, "thread 6", thread_6_and_7_entry, 6,  
  403194:	f8cd b018 	str.w	fp, [sp, #24]
  403198:	9705      	str	r7, [sp, #20]
  40319a:	9404      	str	r4, [sp, #16]
  40319c:	f8cd a00c 	str.w	sl, [sp, #12]
  4031a0:	f8cd a008 	str.w	sl, [sp, #8]
  4031a4:	9501      	str	r5, [sp, #4]
  4031a6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  4031a8:	9300      	str	r3, [sp, #0]
  4031aa:	2306      	movs	r3, #6
  4031ac:	4a40      	ldr	r2, [pc, #256]	; (4032b0 <tx_application_define+0x25c>)
  4031ae:	4941      	ldr	r1, [pc, #260]	; (4032b4 <tx_application_define+0x260>)
  4031b0:	4841      	ldr	r0, [pc, #260]	; (4032b8 <tx_application_define+0x264>)
  4031b2:	47c8      	blx	r9
    tx_byte_allocate(&byte_pool_0, (VOID **) &pointer, DEMO_STACK_SIZE, TX_NO_WAIT);
  4031b4:	4623      	mov	r3, r4
  4031b6:	462a      	mov	r2, r5
  4031b8:	9909      	ldr	r1, [sp, #36]	; 0x24
  4031ba:	482a      	ldr	r0, [pc, #168]	; (403264 <tx_application_define+0x210>)
  4031bc:	47c0      	blx	r8
    tx_thread_create(&thread_7, "thread 7", thread_6_and_7_entry, 7,  
  4031be:	f8cd b018 	str.w	fp, [sp, #24]
  4031c2:	9705      	str	r7, [sp, #20]
  4031c4:	9404      	str	r4, [sp, #16]
  4031c6:	f8cd a00c 	str.w	sl, [sp, #12]
  4031ca:	f8cd a008 	str.w	sl, [sp, #8]
  4031ce:	9501      	str	r5, [sp, #4]
  4031d0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  4031d2:	9300      	str	r3, [sp, #0]
  4031d4:	2307      	movs	r3, #7
  4031d6:	4a36      	ldr	r2, [pc, #216]	; (4032b0 <tx_application_define+0x25c>)
  4031d8:	4938      	ldr	r1, [pc, #224]	; (4032bc <tx_application_define+0x268>)
  4031da:	4839      	ldr	r0, [pc, #228]	; (4032c0 <tx_application_define+0x26c>)
  4031dc:	47c8      	blx	r9
    tx_byte_allocate(&byte_pool_0, (VOID **) &pointer, DEMO_QUEUE_SIZE*sizeof(ULONG), TX_NO_WAIT);
  4031de:	4623      	mov	r3, r4
  4031e0:	f44f 72c8 	mov.w	r2, #400	; 0x190
  4031e4:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
  4031e8:	4649      	mov	r1, r9
  4031ea:	481e      	ldr	r0, [pc, #120]	; (403264 <tx_application_define+0x210>)
  4031ec:	47c0      	blx	r8
    tx_queue_create(&queue_0, "queue 0", TX_1_ULONG, pointer, DEMO_QUEUE_SIZE*sizeof(ULONG));
  4031ee:	233c      	movs	r3, #60	; 0x3c
  4031f0:	9301      	str	r3, [sp, #4]
  4031f2:	f44f 73c8 	mov.w	r3, #400	; 0x190
  4031f6:	9300      	str	r3, [sp, #0]
  4031f8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  4031fa:	463a      	mov	r2, r7
  4031fc:	4931      	ldr	r1, [pc, #196]	; (4032c4 <tx_application_define+0x270>)
  4031fe:	4832      	ldr	r0, [pc, #200]	; (4032c8 <tx_application_define+0x274>)
  403200:	4d32      	ldr	r5, [pc, #200]	; (4032cc <tx_application_define+0x278>)
  403202:	47a8      	blx	r5
    tx_semaphore_create(&semaphore_0, "semaphore 0", 1);
  403204:	2320      	movs	r3, #32
  403206:	463a      	mov	r2, r7
  403208:	4931      	ldr	r1, [pc, #196]	; (4032d0 <tx_application_define+0x27c>)
  40320a:	4832      	ldr	r0, [pc, #200]	; (4032d4 <tx_application_define+0x280>)
  40320c:	4d32      	ldr	r5, [pc, #200]	; (4032d8 <tx_application_define+0x284>)
  40320e:	47a8      	blx	r5
    tx_event_flags_create(&event_flags_0, "event flags 0");
  403210:	2228      	movs	r2, #40	; 0x28
  403212:	4932      	ldr	r1, [pc, #200]	; (4032dc <tx_application_define+0x288>)
  403214:	4832      	ldr	r0, [pc, #200]	; (4032e0 <tx_application_define+0x28c>)
  403216:	4b33      	ldr	r3, [pc, #204]	; (4032e4 <tx_application_define+0x290>)
  403218:	4798      	blx	r3
    tx_mutex_create(&mutex_0, "mutex 0", TX_NO_INHERIT);
  40321a:	2334      	movs	r3, #52	; 0x34
  40321c:	4622      	mov	r2, r4
  40321e:	4932      	ldr	r1, [pc, #200]	; (4032e8 <tx_application_define+0x294>)
  403220:	4832      	ldr	r0, [pc, #200]	; (4032ec <tx_application_define+0x298>)
  403222:	4d33      	ldr	r5, [pc, #204]	; (4032f0 <tx_application_define+0x29c>)
  403224:	47a8      	blx	r5
    tx_byte_allocate(&byte_pool_0, (VOID **) &pointer, DEMO_BLOCK_POOL_SIZE, TX_NO_WAIT);
  403226:	4623      	mov	r3, r4
  403228:	2264      	movs	r2, #100	; 0x64
  40322a:	4649      	mov	r1, r9
  40322c:	480d      	ldr	r0, [pc, #52]	; (403264 <tx_application_define+0x210>)
  40322e:	47c0      	blx	r8
    tx_block_pool_create(&block_pool_0, "block pool 0", sizeof(ULONG), pointer, DEMO_BLOCK_POOL_SIZE);
  403230:	4d30      	ldr	r5, [pc, #192]	; (4032f4 <tx_application_define+0x2a0>)
  403232:	2330      	movs	r3, #48	; 0x30
  403234:	9301      	str	r3, [sp, #4]
  403236:	2364      	movs	r3, #100	; 0x64
  403238:	9300      	str	r3, [sp, #0]
  40323a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  40323c:	4632      	mov	r2, r6
  40323e:	492e      	ldr	r1, [pc, #184]	; (4032f8 <tx_application_define+0x2a4>)
  403240:	4628      	mov	r0, r5
  403242:	4f2e      	ldr	r7, [pc, #184]	; (4032fc <tx_application_define+0x2a8>)
  403244:	47b8      	blx	r7
    tx_block_allocate(&block_pool_0, (VOID **) &pointer, TX_NO_WAIT);
  403246:	4622      	mov	r2, r4
  403248:	4649      	mov	r1, r9
  40324a:	4628      	mov	r0, r5
  40324c:	4b2c      	ldr	r3, [pc, #176]	; (403300 <tx_application_define+0x2ac>)
  40324e:	4798      	blx	r3
    tx_block_release(pointer);
  403250:	980b      	ldr	r0, [sp, #44]	; 0x2c
  403252:	4b2c      	ldr	r3, [pc, #176]	; (403304 <tx_application_define+0x2b0>)
  403254:	4798      	blx	r3
}
  403256:	b00d      	add	sp, #52	; 0x34
  403258:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40325c:	20400fe4 	.word	0x20400fe4
  403260:	00403530 	.word	0x00403530
  403264:	20400ec8 	.word	0x20400ec8
  403268:	004003cd 	.word	0x004003cd
  40326c:	00402ea1 	.word	0x00402ea1
  403270:	0040353c 	.word	0x0040353c
  403274:	20403384 	.word	0x20403384
  403278:	00402ed5 	.word	0x00402ed5
  40327c:	00403548 	.word	0x00403548
  403280:	20400d5c 	.word	0x20400d5c
  403284:	00402f0d 	.word	0x00402f0d
  403288:	00403554 	.word	0x00403554
  40328c:	20400b08 	.word	0x20400b08
  403290:	00402f51 	.word	0x00402f51
  403294:	00403560 	.word	0x00403560
  403298:	20400f30 	.word	0x20400f30
  40329c:	0040356c 	.word	0x0040356c
  4032a0:	20400ca4 	.word	0x20400ca4
  4032a4:	00402fa5 	.word	0x00402fa5
  4032a8:	00403578 	.word	0x00403578
  4032ac:	204034d8 	.word	0x204034d8
  4032b0:	00402fdd 	.word	0x00402fdd
  4032b4:	00403584 	.word	0x00403584
  4032b8:	20400e10 	.word	0x20400e10
  4032bc:	00403590 	.word	0x00403590
  4032c0:	20400be4 	.word	0x20400be4
  4032c4:	0040359c 	.word	0x0040359c
  4032c8:	20403438 	.word	0x20403438
  4032cc:	00400781 	.word	0x00400781
  4032d0:	004035a4 	.word	0x004035a4
  4032d4:	20400bc4 	.word	0x20400bc4
  4032d8:	0040091d 	.word	0x0040091d
  4032dc:	004035b0 	.word	0x004035b0
  4032e0:	20403480 	.word	0x20403480
  4032e4:	004004a9 	.word	0x004004a9
  4032e8:	004035c0 	.word	0x004035c0
  4032ec:	20400efc 	.word	0x20400efc
  4032f0:	004005fd 	.word	0x004005fd
  4032f4:	204034a8 	.word	0x204034a8
  4032f8:	004035c8 	.word	0x004035c8
  4032fc:	0040022d 	.word	0x0040022d
  403300:	004001d5 	.word	0x004001d5
  403304:	00400315 	.word	0x00400315
  403308:	00400341 	.word	0x00400341
  40330c:	00400a4d 	.word	0x00400a4d

00403310 <__libc_init_array>:
  403310:	b570      	push	{r4, r5, r6, lr}
  403312:	4e0f      	ldr	r6, [pc, #60]	; (403350 <__libc_init_array+0x40>)
  403314:	4d0f      	ldr	r5, [pc, #60]	; (403354 <__libc_init_array+0x44>)
  403316:	1b76      	subs	r6, r6, r5
  403318:	10b6      	asrs	r6, r6, #2
  40331a:	bf18      	it	ne
  40331c:	2400      	movne	r4, #0
  40331e:	d005      	beq.n	40332c <__libc_init_array+0x1c>
  403320:	3401      	adds	r4, #1
  403322:	f855 3b04 	ldr.w	r3, [r5], #4
  403326:	4798      	blx	r3
  403328:	42a6      	cmp	r6, r4
  40332a:	d1f9      	bne.n	403320 <__libc_init_array+0x10>
  40332c:	4e0a      	ldr	r6, [pc, #40]	; (403358 <__libc_init_array+0x48>)
  40332e:	4d0b      	ldr	r5, [pc, #44]	; (40335c <__libc_init_array+0x4c>)
  403330:	1b76      	subs	r6, r6, r5
  403332:	f000 f953 	bl	4035dc <_init>
  403336:	10b6      	asrs	r6, r6, #2
  403338:	bf18      	it	ne
  40333a:	2400      	movne	r4, #0
  40333c:	d006      	beq.n	40334c <__libc_init_array+0x3c>
  40333e:	3401      	adds	r4, #1
  403340:	f855 3b04 	ldr.w	r3, [r5], #4
  403344:	4798      	blx	r3
  403346:	42a6      	cmp	r6, r4
  403348:	d1f9      	bne.n	40333e <__libc_init_array+0x2e>
  40334a:	bd70      	pop	{r4, r5, r6, pc}
  40334c:	bd70      	pop	{r4, r5, r6, pc}
  40334e:	bf00      	nop
  403350:	004035e8 	.word	0x004035e8
  403354:	004035e8 	.word	0x004035e8
  403358:	004035f0 	.word	0x004035f0
  40335c:	004035e8 	.word	0x004035e8

00403360 <memset>:
  403360:	b470      	push	{r4, r5, r6}
  403362:	0786      	lsls	r6, r0, #30
  403364:	d046      	beq.n	4033f4 <memset+0x94>
  403366:	1e54      	subs	r4, r2, #1
  403368:	2a00      	cmp	r2, #0
  40336a:	d041      	beq.n	4033f0 <memset+0x90>
  40336c:	b2ca      	uxtb	r2, r1
  40336e:	4603      	mov	r3, r0
  403370:	e002      	b.n	403378 <memset+0x18>
  403372:	f114 34ff 	adds.w	r4, r4, #4294967295
  403376:	d33b      	bcc.n	4033f0 <memset+0x90>
  403378:	f803 2b01 	strb.w	r2, [r3], #1
  40337c:	079d      	lsls	r5, r3, #30
  40337e:	d1f8      	bne.n	403372 <memset+0x12>
  403380:	2c03      	cmp	r4, #3
  403382:	d92e      	bls.n	4033e2 <memset+0x82>
  403384:	b2cd      	uxtb	r5, r1
  403386:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
  40338a:	2c0f      	cmp	r4, #15
  40338c:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
  403390:	d919      	bls.n	4033c6 <memset+0x66>
  403392:	f103 0210 	add.w	r2, r3, #16
  403396:	4626      	mov	r6, r4
  403398:	3e10      	subs	r6, #16
  40339a:	2e0f      	cmp	r6, #15
  40339c:	f842 5c10 	str.w	r5, [r2, #-16]
  4033a0:	f842 5c0c 	str.w	r5, [r2, #-12]
  4033a4:	f842 5c08 	str.w	r5, [r2, #-8]
  4033a8:	f842 5c04 	str.w	r5, [r2, #-4]
  4033ac:	f102 0210 	add.w	r2, r2, #16
  4033b0:	d8f2      	bhi.n	403398 <memset+0x38>
  4033b2:	f1a4 0210 	sub.w	r2, r4, #16
  4033b6:	f022 020f 	bic.w	r2, r2, #15
  4033ba:	f004 040f 	and.w	r4, r4, #15
  4033be:	3210      	adds	r2, #16
  4033c0:	2c03      	cmp	r4, #3
  4033c2:	4413      	add	r3, r2
  4033c4:	d90d      	bls.n	4033e2 <memset+0x82>
  4033c6:	461e      	mov	r6, r3
  4033c8:	4622      	mov	r2, r4
  4033ca:	3a04      	subs	r2, #4
  4033cc:	2a03      	cmp	r2, #3
  4033ce:	f846 5b04 	str.w	r5, [r6], #4
  4033d2:	d8fa      	bhi.n	4033ca <memset+0x6a>
  4033d4:	1f22      	subs	r2, r4, #4
  4033d6:	f022 0203 	bic.w	r2, r2, #3
  4033da:	3204      	adds	r2, #4
  4033dc:	4413      	add	r3, r2
  4033de:	f004 0403 	and.w	r4, r4, #3
  4033e2:	b12c      	cbz	r4, 4033f0 <memset+0x90>
  4033e4:	b2c9      	uxtb	r1, r1
  4033e6:	441c      	add	r4, r3
  4033e8:	f803 1b01 	strb.w	r1, [r3], #1
  4033ec:	429c      	cmp	r4, r3
  4033ee:	d1fb      	bne.n	4033e8 <memset+0x88>
  4033f0:	bc70      	pop	{r4, r5, r6}
  4033f2:	4770      	bx	lr
  4033f4:	4614      	mov	r4, r2
  4033f6:	4603      	mov	r3, r0
  4033f8:	e7c2      	b.n	403380 <memset+0x20>
  4033fa:	bf00      	nop

004033fc <register_fini>:
  4033fc:	4b02      	ldr	r3, [pc, #8]	; (403408 <register_fini+0xc>)
  4033fe:	b113      	cbz	r3, 403406 <register_fini+0xa>
  403400:	4802      	ldr	r0, [pc, #8]	; (40340c <register_fini+0x10>)
  403402:	f000 b805 	b.w	403410 <atexit>
  403406:	4770      	bx	lr
  403408:	00000000 	.word	0x00000000
  40340c:	0040341d 	.word	0x0040341d

00403410 <atexit>:
  403410:	2300      	movs	r3, #0
  403412:	4601      	mov	r1, r0
  403414:	461a      	mov	r2, r3
  403416:	4618      	mov	r0, r3
  403418:	f000 b81e 	b.w	403458 <__register_exitproc>

0040341c <__libc_fini_array>:
  40341c:	b538      	push	{r3, r4, r5, lr}
  40341e:	4c0a      	ldr	r4, [pc, #40]	; (403448 <__libc_fini_array+0x2c>)
  403420:	4d0a      	ldr	r5, [pc, #40]	; (40344c <__libc_fini_array+0x30>)
  403422:	1b64      	subs	r4, r4, r5
  403424:	10a4      	asrs	r4, r4, #2
  403426:	d00a      	beq.n	40343e <__libc_fini_array+0x22>
  403428:	f104 4380 	add.w	r3, r4, #1073741824	; 0x40000000
  40342c:	3b01      	subs	r3, #1
  40342e:	eb05 0583 	add.w	r5, r5, r3, lsl #2
  403432:	3c01      	subs	r4, #1
  403434:	f855 3904 	ldr.w	r3, [r5], #-4
  403438:	4798      	blx	r3
  40343a:	2c00      	cmp	r4, #0
  40343c:	d1f9      	bne.n	403432 <__libc_fini_array+0x16>
  40343e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  403442:	f000 b8d5 	b.w	4035f0 <_fini>
  403446:	bf00      	nop
  403448:	00403600 	.word	0x00403600
  40344c:	004035fc 	.word	0x004035fc

00403450 <__retarget_lock_acquire_recursive>:
  403450:	4770      	bx	lr
  403452:	bf00      	nop

00403454 <__retarget_lock_release_recursive>:
  403454:	4770      	bx	lr
  403456:	bf00      	nop

00403458 <__register_exitproc>:
  403458:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  40345c:	4d2c      	ldr	r5, [pc, #176]	; (403510 <__register_exitproc+0xb8>)
  40345e:	4606      	mov	r6, r0
  403460:	6828      	ldr	r0, [r5, #0]
  403462:	4698      	mov	r8, r3
  403464:	460f      	mov	r7, r1
  403466:	4691      	mov	r9, r2
  403468:	f7ff fff2 	bl	403450 <__retarget_lock_acquire_recursive>
  40346c:	4b29      	ldr	r3, [pc, #164]	; (403514 <__register_exitproc+0xbc>)
  40346e:	681c      	ldr	r4, [r3, #0]
  403470:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
  403474:	2b00      	cmp	r3, #0
  403476:	d03e      	beq.n	4034f6 <__register_exitproc+0x9e>
  403478:	685a      	ldr	r2, [r3, #4]
  40347a:	2a1f      	cmp	r2, #31
  40347c:	dc1c      	bgt.n	4034b8 <__register_exitproc+0x60>
  40347e:	f102 0e01 	add.w	lr, r2, #1
  403482:	b176      	cbz	r6, 4034a2 <__register_exitproc+0x4a>
  403484:	eb03 0182 	add.w	r1, r3, r2, lsl #2
  403488:	2401      	movs	r4, #1
  40348a:	f8c1 9088 	str.w	r9, [r1, #136]	; 0x88
  40348e:	f8d3 0188 	ldr.w	r0, [r3, #392]	; 0x188
  403492:	4094      	lsls	r4, r2
  403494:	4320      	orrs	r0, r4
  403496:	2e02      	cmp	r6, #2
  403498:	f8c3 0188 	str.w	r0, [r3, #392]	; 0x188
  40349c:	f8c1 8108 	str.w	r8, [r1, #264]	; 0x108
  4034a0:	d023      	beq.n	4034ea <__register_exitproc+0x92>
  4034a2:	3202      	adds	r2, #2
  4034a4:	f8c3 e004 	str.w	lr, [r3, #4]
  4034a8:	6828      	ldr	r0, [r5, #0]
  4034aa:	f843 7022 	str.w	r7, [r3, r2, lsl #2]
  4034ae:	f7ff ffd1 	bl	403454 <__retarget_lock_release_recursive>
  4034b2:	2000      	movs	r0, #0
  4034b4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  4034b8:	4b17      	ldr	r3, [pc, #92]	; (403518 <__register_exitproc+0xc0>)
  4034ba:	b30b      	cbz	r3, 403500 <__register_exitproc+0xa8>
  4034bc:	f44f 70c8 	mov.w	r0, #400	; 0x190
  4034c0:	f3af 8000 	nop.w
  4034c4:	4603      	mov	r3, r0
  4034c6:	b1d8      	cbz	r0, 403500 <__register_exitproc+0xa8>
  4034c8:	f8d4 2148 	ldr.w	r2, [r4, #328]	; 0x148
  4034cc:	6002      	str	r2, [r0, #0]
  4034ce:	2100      	movs	r1, #0
  4034d0:	6041      	str	r1, [r0, #4]
  4034d2:	460a      	mov	r2, r1
  4034d4:	f8c4 0148 	str.w	r0, [r4, #328]	; 0x148
  4034d8:	f04f 0e01 	mov.w	lr, #1
  4034dc:	f8c0 1188 	str.w	r1, [r0, #392]	; 0x188
  4034e0:	f8c0 118c 	str.w	r1, [r0, #396]	; 0x18c
  4034e4:	2e00      	cmp	r6, #0
  4034e6:	d0dc      	beq.n	4034a2 <__register_exitproc+0x4a>
  4034e8:	e7cc      	b.n	403484 <__register_exitproc+0x2c>
  4034ea:	f8d3 118c 	ldr.w	r1, [r3, #396]	; 0x18c
  4034ee:	430c      	orrs	r4, r1
  4034f0:	f8c3 418c 	str.w	r4, [r3, #396]	; 0x18c
  4034f4:	e7d5      	b.n	4034a2 <__register_exitproc+0x4a>
  4034f6:	f504 73a6 	add.w	r3, r4, #332	; 0x14c
  4034fa:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
  4034fe:	e7bb      	b.n	403478 <__register_exitproc+0x20>
  403500:	6828      	ldr	r0, [r5, #0]
  403502:	f7ff ffa7 	bl	403454 <__retarget_lock_release_recursive>
  403506:	f04f 30ff 	mov.w	r0, #4294967295
  40350a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  40350e:	bf00      	nop
  403510:	20400430 	.word	0x20400430
  403514:	004035d8 	.word	0x004035d8
  403518:	00000000 	.word	0x00000000
  40351c:	74737953 	.word	0x74737953
  403520:	54206d65 	.word	0x54206d65
  403524:	72656d69 	.word	0x72656d69
  403528:	72685420 	.word	0x72685420
  40352c:	00646165 	.word	0x00646165
  403530:	65747962 	.word	0x65747962
  403534:	6f6f7020 	.word	0x6f6f7020
  403538:	0030206c 	.word	0x0030206c
  40353c:	65726874 	.word	0x65726874
  403540:	30206461 	.word	0x30206461
  403544:	00000000 	.word	0x00000000
  403548:	65726874 	.word	0x65726874
  40354c:	31206461 	.word	0x31206461
  403550:	00000000 	.word	0x00000000
  403554:	65726874 	.word	0x65726874
  403558:	32206461 	.word	0x32206461
  40355c:	00000000 	.word	0x00000000
  403560:	65726874 	.word	0x65726874
  403564:	33206461 	.word	0x33206461
  403568:	00000000 	.word	0x00000000
  40356c:	65726874 	.word	0x65726874
  403570:	34206461 	.word	0x34206461
  403574:	00000000 	.word	0x00000000
  403578:	65726874 	.word	0x65726874
  40357c:	35206461 	.word	0x35206461
  403580:	00000000 	.word	0x00000000
  403584:	65726874 	.word	0x65726874
  403588:	36206461 	.word	0x36206461
  40358c:	00000000 	.word	0x00000000
  403590:	65726874 	.word	0x65726874
  403594:	37206461 	.word	0x37206461
  403598:	00000000 	.word	0x00000000
  40359c:	75657571 	.word	0x75657571
  4035a0:	00302065 	.word	0x00302065
  4035a4:	616d6573 	.word	0x616d6573
  4035a8:	726f6870 	.word	0x726f6870
  4035ac:	00302065 	.word	0x00302065
  4035b0:	6e657665 	.word	0x6e657665
  4035b4:	6c662074 	.word	0x6c662074
  4035b8:	20736761 	.word	0x20736761
  4035bc:	00000030 	.word	0x00000030
  4035c0:	6574756d 	.word	0x6574756d
  4035c4:	00302078 	.word	0x00302078
  4035c8:	636f6c62 	.word	0x636f6c62
  4035cc:	6f70206b 	.word	0x6f70206b
  4035d0:	30206c6f 	.word	0x30206c6f
  4035d4:	00000000 	.word	0x00000000

004035d8 <_global_impure_ptr>:
  4035d8:	20400008                                ..@ 

004035dc <_init>:
  4035dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  4035de:	bf00      	nop
  4035e0:	bcf8      	pop	{r3, r4, r5, r6, r7}
  4035e2:	bc08      	pop	{r3}
  4035e4:	469e      	mov	lr, r3
  4035e6:	4770      	bx	lr

004035e8 <__init_array_start>:
  4035e8:	004033fd 	.word	0x004033fd

004035ec <__frame_dummy_init_array_entry>:
  4035ec:	0040018d                                ..@.

004035f0 <_fini>:
  4035f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  4035f2:	bf00      	nop
  4035f4:	bcf8      	pop	{r3, r4, r5, r6, r7}
  4035f6:	bc08      	pop	{r3}
  4035f8:	469e      	mov	lr, r3
  4035fa:	4770      	bx	lr

004035fc <__fini_array_start>:
  4035fc:	00400169 	.word	0x00400169
